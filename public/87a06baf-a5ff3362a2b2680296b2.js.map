{"version":3,"file":"87a06baf-a5ff3362a2b2680296b2.js","mappings":"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","sources":["webpack://bonsai-web/./node_modules/@babylonjs/core/Meshes/mesh.js"],"sourcesContent":["import _slicedToArray from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _assertThisInitialized from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _inherits from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _createClass from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _regeneratorRuntime from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/regenerator/index.js\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { Observable } from \"../Misc/observable.js\";\nimport { Tools, AsyncLoop } from \"../Misc/tools.js\";\nimport { DeepCopier } from \"../Misc/deepCopier.js\";\nimport { Tags } from \"../Misc/tags.js\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"../Misc/coroutine.js\";\nimport { ScenePerformancePriority } from \"../scene.js\";\nimport { Quaternion, Matrix, Vector3, Vector2 } from \"../Maths/math.vector.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { Node } from \"../node.js\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer.js\";\nimport { VertexData } from \"./mesh.vertexData.js\";\nimport { Geometry } from \"./geometry.js\";\nimport { AbstractMesh } from \"./abstractMesh.js\";\nimport { SubMesh } from \"./subMesh.js\";\nimport { Material } from \"../Materials/material.js\";\nimport { MultiMaterial } from \"../Materials/multiMaterial.js\";\nimport { SceneLoaderFlags } from \"../Loading/sceneLoaderFlags.js\";\nimport { SerializationHelper } from \"../Misc/decorators.js\";\nimport { Logger } from \"../Misc/logger.js\";\nimport { GetClass, RegisterClass } from \"../Misc/typeStore.js\";\nimport { _WarnImport } from \"../Misc/devTools.js\";\nimport { SceneComponentConstants } from \"../sceneComponent.js\";\nimport { MeshLODLevel } from \"./meshLODLevel.js\";\n/**\n * @internal\n **/\n\nexport var _CreationDataStorage = /*#__PURE__*/_createClass(function _CreationDataStorage() {\n  _classCallCheck(this, _CreationDataStorage);\n});\n/**\n * @internal\n **/\n\nvar _InstanceDataStorage = /*#__PURE__*/_createClass(function _InstanceDataStorage() {\n  _classCallCheck(this, _InstanceDataStorage);\n\n  this.visibleInstances = {};\n  this.batchCache = new _InstancesBatch();\n  this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();\n  this.instancesBufferSize = 32 * 16 * 4; // let's start with a maximum of 32 instances\n});\n/**\n * @internal\n **/\n\n\nexport var _InstancesBatch = /*#__PURE__*/_createClass(function _InstancesBatch() {\n  _classCallCheck(this, _InstancesBatch);\n\n  this.mustReturn = false;\n  this.visibleInstances = new Array();\n  this.renderSelf = new Array();\n  this.hardwareInstancedRendering = new Array();\n});\n/**\n * @internal\n **/\n\nvar _ThinInstanceDataStorage = /*#__PURE__*/_createClass(function _ThinInstanceDataStorage() {\n  _classCallCheck(this, _ThinInstanceDataStorage);\n\n  this.instancesCount = 0;\n  this.matrixBuffer = null;\n  this.previousMatrixBuffer = null;\n  this.matrixBufferSize = 32 * 16; // let's start with a maximum of 32 thin instances\n\n  this.matrixData = null;\n  this.boundingVectors = [];\n  this.worldMatrices = null;\n});\n/**\n * @internal\n **/\n\n\nvar _InternalMeshDataInfo = /*#__PURE__*/_createClass(function _InternalMeshDataInfo() {\n  _classCallCheck(this, _InternalMeshDataInfo);\n\n  this._areNormalsFrozen = false; // Will be used by ribbons mainly\n  // Will be used to save a source mesh reference, If any\n\n  this._source = null; // Will be used to for fast cloned mesh lookup\n\n  this.meshMap = null;\n  this._preActivateId = -1; // eslint-disable-next-line @typescript-eslint/naming-convention\n\n  this._LODLevels = new Array();\n  /** Alternative definition of LOD level, using screen coverage instead of distance */\n\n  this._useLODScreenCoverage = false;\n  this._effectiveMaterial = null;\n  this._forcedInstanceCount = 0;\n});\n/**\n * Class used to represent renderable models\n */\n\n\nexport var Mesh = /*#__PURE__*/function (_AbstractMesh) {\n  _inherits(Mesh, _AbstractMesh);\n\n  var _super = _createSuper(Mesh);\n\n  /**\n   * @constructor\n   * @param name The value used by scene.getMeshByName() to do a lookup.\n   * @param scene The scene to add this mesh to.\n   * @param parent The parent of this mesh, if it has one\n   * @param source An optional Mesh from which geometry is shared, cloned.\n   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\n   *                  When false, achieved by calling a clone(), also passing False.\n   *                  This will make creation of children, recursive.\n   * @param clonePhysicsImpostor When cloning, include cloning mesh physics impostor, default True.\n   */\n  function Mesh(name) {\n    var _this;\n\n    var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var doNotCloneChildren = arguments.length > 4 ? arguments[4] : undefined;\n    var clonePhysicsImpostor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    _classCallCheck(this, Mesh);\n\n    _this = _super.call(this, name, scene); // Internal data\n\n    _this._internalMeshDataInfo = new _InternalMeshDataInfo(); // Members\n\n    /**\n     * Gets the delay loading state of the mesh (when delay loading is turned on)\n     * @see https://doc.babylonjs.com/how_to/using_the_incremental_loading_system\n     */\n\n    _this.delayLoadState = 0;\n    /**\n     * Gets the list of instances created from this mesh\n     * it is not supposed to be modified manually.\n     * Note also that the order of the InstancedMesh wihin the array is not significant and might change.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n     */\n\n    _this.instances = new Array(); // Private\n\n    /** @internal */\n\n    _this._creationDataStorage = null;\n    /** @internal */\n\n    _this._geometry = null;\n    /** @internal */\n\n    _this._instanceDataStorage = new _InstanceDataStorage();\n    /** @internal */\n\n    _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();\n    /** @internal */\n\n    _this._shouldGenerateFlatShading = false; // Use by builder only to know what orientation were the mesh build in.\n\n    /** @internal */\n\n    _this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;\n    /**\n     * Use this property to change the original side orientation defined at construction time\n     */\n\n    _this.overrideMaterialSideOrientation = null;\n    /**\n     * Gets or sets a boolean indicating whether to render ignoring the active camera's max z setting. (false by default)\n     * Note this will reduce performance when set to true.\n     */\n\n    _this.ignoreCameraMaxZ = false;\n    scene = _this.getScene();\n\n    _this._onBeforeDraw = function (isInstance, world, effectiveMaterial) {\n      if (isInstance && effectiveMaterial) {\n        if (_this._uniformBuffer) {\n          _this.transferToEffect(world);\n        } else {\n          effectiveMaterial.bindOnlyWorldMatrix(world);\n        }\n      }\n    };\n\n    if (source) {\n      // Geometry\n      if (source._geometry) {\n        source._geometry.applyToMesh(_assertThisInitialized(_this));\n      } // Deep copy\n\n\n      DeepCopier.DeepCopy(source, _assertThisInitialized(_this), [\"name\", \"material\", \"skeleton\", \"instances\", \"parent\", \"uniqueId\", \"source\", \"metadata\", \"morphTargetManager\", \"hasInstances\", \"worldMatrixInstancedBuffer\", \"previousWorldMatrixInstancedBuffer\", \"hasLODLevels\", \"geometry\", \"isBlocked\", \"areNormalsFrozen\", \"facetNb\", \"isFacetDataEnabled\", \"lightSources\", \"useBones\", \"isAnInstance\", \"collider\", \"edgesRenderer\", \"forward\", \"up\", \"right\", \"absolutePosition\", \"absoluteScaling\", \"absoluteRotationQuaternion\", \"isWorldMatrixFrozen\", \"nonUniformScaling\", \"behaviors\", \"worldMatrixFromCache\", \"hasThinInstances\", \"cloneMeshMap\", \"hasBoundingInfo\"], [\"_poseMatrix\"]); // Source mesh\n\n      _this._internalMeshDataInfo._source = source;\n\n      if (scene.useClonedMeshMap) {\n        if (!source._internalMeshDataInfo.meshMap) {\n          source._internalMeshDataInfo.meshMap = {};\n        }\n\n        source._internalMeshDataInfo.meshMap[_this.uniqueId] = _assertThisInitialized(_this);\n      } // Construction Params\n      // Clone parameters allowing mesh to be updated in case of parametric shapes.\n\n\n      _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;\n      _this._creationDataStorage = source._creationDataStorage; // Animation ranges\n\n      if (source._ranges) {\n        var ranges = source._ranges;\n\n        for (var _name in ranges) {\n          if (!Object.prototype.hasOwnProperty.call(ranges, _name)) {\n            continue;\n          }\n\n          if (!ranges[_name]) {\n            continue;\n          }\n\n          _this.createAnimationRange(_name, ranges[_name].from, ranges[_name].to);\n        }\n      } // Metadata\n\n\n      if (source.metadata && source.metadata.clone) {\n        _this.metadata = source.metadata.clone();\n      } else {\n        _this.metadata = source.metadata;\n      } // Tags\n\n\n      if (Tags && Tags.HasTags(source)) {\n        Tags.AddTagsTo(_assertThisInitialized(_this), Tags.GetTags(source, true));\n      } // Enabled. We shouldn't need to check the source's ancestors, as this mesh\n      // will have the same ones.\n\n\n      _this.setEnabled(source.isEnabled(false)); // Parent\n\n\n      _this.parent = source.parent; // Pivot\n\n      _this.setPivotMatrix(source.getPivotMatrix());\n\n      _this.id = name + \".\" + source.id; // Material\n\n      _this.material = source.material;\n\n      if (!doNotCloneChildren) {\n        // Children\n        var directDescendants = source.getDescendants(true);\n\n        for (var index = 0; index < directDescendants.length; index++) {\n          var child = directDescendants[index];\n\n          if (child.clone) {\n            child.clone(name + \".\" + child.name, _assertThisInitialized(_this));\n          }\n        }\n      } // Morphs\n\n\n      if (source.morphTargetManager) {\n        _this.morphTargetManager = source.morphTargetManager;\n      } // Physics clone\n\n\n      if (scene.getPhysicsEngine) {\n        var physicsEngine = scene.getPhysicsEngine();\n\n        if (clonePhysicsImpostor && physicsEngine) {\n          var impostor = physicsEngine.getImpostorForPhysicsObject(source);\n\n          if (impostor) {\n            _this.physicsImpostor = impostor.clone(_assertThisInitialized(_this));\n          }\n        }\n      } // Particles\n\n\n      for (var _index = 0; _index < scene.particleSystems.length; _index++) {\n        var system = scene.particleSystems[_index];\n\n        if (system.emitter === source) {\n          system.clone(system.name, _assertThisInitialized(_this));\n        }\n      } // Skeleton\n\n\n      _this.skeleton = source.skeleton;\n\n      _this.refreshBoundingInfo(true, true);\n\n      _this.computeWorldMatrix(true);\n    } // Parent\n\n\n    if (parent !== null) {\n      _this.parent = parent;\n    }\n\n    _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;\n\n    _this._internalMeshDataInfo._onMeshReadyObserverAdded = function (observer) {\n      // only notify once! then unregister the observer\n      observer.unregisterOnNextCall = true;\n\n      if (_this.isReady(true)) {\n        _this.onMeshReadyObservable.notifyObservers(_assertThisInitialized(_this));\n      } else {\n        if (!_this._internalMeshDataInfo._checkReadinessObserver) {\n          _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function () {\n            // check for complete readiness\n            if (_this.isReady(true)) {\n              _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);\n\n              _this._internalMeshDataInfo._checkReadinessObserver = null;\n\n              _this.onMeshReadyObservable.notifyObservers(_assertThisInitialized(_this));\n            }\n          });\n        }\n      }\n    };\n\n    _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);\n\n    if (source) {\n      source.onClonedObservable.notifyObservers(_assertThisInitialized(_this));\n    }\n\n    return _this;\n  }\n  /**\n   * Gets the default side orientation.\n   * @param orientation the orientation to value to attempt to get\n   * @returns the default orientation\n   * @internal\n   */\n\n\n  _createClass(Mesh, [{\n    key: \"useLODScreenCoverage\",\n    get:\n    /**\n     * Determines if the LOD levels are intended to be calculated using screen coverage (surface area ratio) instead of distance\n     */\n    function get() {\n      return this._internalMeshDataInfo._useLODScreenCoverage;\n    },\n    set: function set(value) {\n      this._internalMeshDataInfo._useLODScreenCoverage = value;\n    }\n  }, {\n    key: \"computeBonesUsingShaders\",\n    get: function get() {\n      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;\n    },\n    set: function set(value) {\n      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {\n        return;\n      }\n\n      if (value && this._internalMeshDataInfo._sourcePositions) {\n        // switch from software to GPU computation: we need to reset the vertex and normal buffers that have been updated by the software process\n        this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);\n\n        if (this._internalMeshDataInfo._sourceNormals) {\n          this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);\n        }\n\n        this._internalMeshDataInfo._sourcePositions = null;\n        this._internalMeshDataInfo._sourceNormals = null;\n      }\n\n      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;\n\n      this._markSubMeshesAsAttributesDirty();\n    }\n    /**\n     * An event triggered before rendering the mesh\n     */\n\n  }, {\n    key: \"onBeforeRenderObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeRenderObservable) {\n        this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();\n      }\n\n      return this._internalMeshDataInfo._onBeforeRenderObservable;\n    }\n    /**\n     * An event triggered before binding the mesh\n     */\n\n  }, {\n    key: \"onBeforeBindObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeBindObservable) {\n        this._internalMeshDataInfo._onBeforeBindObservable = new Observable();\n      }\n\n      return this._internalMeshDataInfo._onBeforeBindObservable;\n    }\n    /**\n     * An event triggered after rendering the mesh\n     */\n\n  }, {\n    key: \"onAfterRenderObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onAfterRenderObservable) {\n        this._internalMeshDataInfo._onAfterRenderObservable = new Observable();\n      }\n\n      return this._internalMeshDataInfo._onAfterRenderObservable;\n    }\n    /**\n     * An event triggeredbetween rendering pass when using separateCullingPass = true\n     */\n\n  }, {\n    key: \"onBetweenPassObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBetweenPassObservable) {\n        this._internalMeshDataInfo._onBetweenPassObservable = new Observable();\n      }\n\n      return this._internalMeshDataInfo._onBetweenPassObservable;\n    }\n    /**\n     * An event triggered before drawing the mesh\n     */\n\n  }, {\n    key: \"onBeforeDrawObservable\",\n    get: function get() {\n      if (!this._internalMeshDataInfo._onBeforeDrawObservable) {\n        this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();\n      }\n\n      return this._internalMeshDataInfo._onBeforeDrawObservable;\n    }\n    /**\n     * Sets a callback to call before drawing the mesh. It is recommended to use onBeforeDrawObservable instead\n     */\n\n  }, {\n    key: \"onBeforeDraw\",\n    set: function set(callback) {\n      if (this._onBeforeDrawObserver) {\n        this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);\n      }\n\n      this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);\n    }\n  }, {\n    key: \"hasInstances\",\n    get: function get() {\n      return this.instances.length > 0;\n    }\n  }, {\n    key: \"hasThinInstances\",\n    get: function get() {\n      var _this$_thinInstanceDa;\n\n      return ((_this$_thinInstanceDa = this._thinInstanceDataStorage.instancesCount) !== null && _this$_thinInstanceDa !== void 0 ? _this$_thinInstanceDa : 0) > 0;\n    }\n    /**\n     * Gets or sets the forced number of instances to display.\n     * If 0 (default value), the number of instances is not forced and depends on the draw type\n     * (regular / instance / thin instances mesh)\n     */\n\n  }, {\n    key: \"forcedInstanceCount\",\n    get: function get() {\n      return this._internalMeshDataInfo._forcedInstanceCount;\n    },\n    set: function set(count) {\n      this._internalMeshDataInfo._forcedInstanceCount = count;\n    }\n    /**\n     * Gets the source mesh (the one used to clone this one from)\n     */\n\n  }, {\n    key: \"source\",\n    get: function get() {\n      return this._internalMeshDataInfo._source;\n    }\n    /**\n     * Gets the list of clones of this mesh\n     * The scene must have been constructed with useClonedMeshMap=true for this to work!\n     * Note that useClonedMeshMap=true is the default setting\n     */\n\n  }, {\n    key: \"cloneMeshMap\",\n    get: function get() {\n      return this._internalMeshDataInfo.meshMap;\n    }\n    /**\n     * Gets or sets a boolean indicating that this mesh does not use index buffer\n     */\n\n  }, {\n    key: \"isUnIndexed\",\n    get: function get() {\n      return this._unIndexed;\n    },\n    set: function set(value) {\n      if (this._unIndexed !== value) {\n        this._unIndexed = value;\n\n        this._markSubMeshesAsAttributesDirty();\n      }\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' world matrices */\n\n  }, {\n    key: \"worldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.instancesData;\n    }\n    /** Gets the array buffer used to store the instanced buffer used for instances' previous world matrices */\n\n  }, {\n    key: \"previousWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.instancesPreviousData;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n\n  }, {\n    key: \"manualUpdateOfWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.manualUpdate;\n    },\n    set: function set(value) {\n      this._instanceDataStorage.manualUpdate = value;\n    }\n    /** Gets or sets a boolean indicating that the update of the instance buffer of the world matrices is manual */\n\n  }, {\n    key: \"manualUpdateOfPreviousWorldMatrixInstancedBuffer\",\n    get: function get() {\n      return this._instanceDataStorage.previousManualUpdate;\n    },\n    set: function set(value) {\n      this._instanceDataStorage.previousManualUpdate = value;\n    }\n  }, {\n    key: \"instantiateHierarchy\",\n    value: function instantiateHierarchy() {\n      var newParent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      var onNewNodeCreated = arguments.length > 2 ? arguments[2] : undefined;\n      var instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone(\"Clone of \" + (this.name || this.id), newParent || this.parent, true) : this.createInstance(\"instance of \" + (this.name || this.id));\n      instance.parent = newParent || this.parent;\n      instance.position = this.position.clone();\n      instance.scaling = this.scaling.clone();\n\n      if (this.rotationQuaternion) {\n        instance.rotationQuaternion = this.rotationQuaternion.clone();\n      } else {\n        instance.rotation = this.rotation.clone();\n      }\n\n      if (onNewNodeCreated) {\n        onNewNodeCreated(this, instance);\n      }\n\n      var _iterator = _createForOfIteratorHelper(this.getChildTransformNodes(true)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var child = _step.value;\n\n          // instancedMesh should have a different sourced mesh\n          if (child.getClassName() === \"InstancedMesh\" && instance.getClassName() === \"Mesh\") {\n            child.instantiateHierarchy(instance, {\n              doNotInstantiate: options && options.doNotInstantiate || false,\n              newSourcedMesh: instance\n            }, onNewNodeCreated);\n          } else {\n            child.instantiateHierarchy(instance, options, onNewNodeCreated);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return instance;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Mesh\".\n     */\n\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return \"Mesh\";\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isMesh\",\n    get: function get() {\n      return true;\n    }\n    /**\n     * Returns a description of this mesh\n     * @param fullDetails define if full details about this mesh must be used\n     * @returns a descriptive string representing this mesh\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(fullDetails) {\n      var ret = _get(_getPrototypeOf(Mesh.prototype), \"toString\", this).call(this, fullDetails);\n\n      ret += \", n vertices: \" + this.getTotalVertices();\n      ret += \", parent: \" + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : \"NONE\");\n\n      if (this.animations) {\n        for (var i = 0; i < this.animations.length; i++) {\n          ret += \", animation[0]: \" + this.animations[i].toString(fullDetails);\n        }\n      }\n\n      if (fullDetails) {\n        if (this._geometry) {\n          var ib = this.getIndices();\n          var vb = this.getVerticesData(VertexBuffer.PositionKind);\n\n          if (vb && ib) {\n            ret += \", flat shading: \" + (vb.length / 3 === ib.length ? \"YES\" : \"NO\");\n          }\n        } else {\n          ret += \", flat shading: UNKNOWN\";\n        }\n      }\n\n      return ret;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_unBindEffect\",\n    value: function _unBindEffect() {\n      _get(_getPrototypeOf(Mesh.prototype), \"_unBindEffect\", this).call(this);\n\n      var _iterator2 = _createForOfIteratorHelper(this.instances),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var instance = _step2.value;\n\n          instance._unBindEffect();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Gets a boolean indicating if this mesh has LOD\n     */\n\n  }, {\n    key: \"hasLODLevels\",\n    get: function get() {\n      return this._internalMeshDataInfo._LODLevels.length > 0;\n    }\n    /**\n     * Gets the list of MeshLODLevel associated with the current mesh\n     * @returns an array of MeshLODLevel\n     */\n\n  }, {\n    key: \"getLODLevels\",\n    value: function getLODLevels() {\n      return this._internalMeshDataInfo._LODLevels;\n    }\n  }, {\n    key: \"_sortLODLevels\",\n    value: function _sortLODLevels() {\n      var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;\n\n      this._internalMeshDataInfo._LODLevels.sort(function (a, b) {\n        if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {\n          return sortingOrderFactor;\n        }\n\n        if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {\n          return -sortingOrderFactor;\n        }\n\n        return 0;\n      });\n    }\n    /**\n     * Add a mesh as LOD level triggered at the given distance.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param distanceOrScreenCoverage Either distance from the center of the object to show this level or the screen coverage if `useScreenCoverage` is set to `true`.\n     * If screen coverage, value is a fraction of the screen's total surface, between 0 and 1.\n     * @param mesh The mesh to be added as LOD level (can be null)\n     * @returns This mesh (for chaining)\n     */\n\n  }, {\n    key: \"addLODLevel\",\n    value: function addLODLevel(distanceOrScreenCoverage, mesh) {\n      if (mesh && mesh._masterMesh) {\n        Logger.Warn(\"You cannot use a mesh as LOD level twice\");\n        return this;\n      }\n\n      var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);\n\n      this._internalMeshDataInfo._LODLevels.push(level);\n\n      if (mesh) {\n        mesh._masterMesh = this;\n      }\n\n      this._sortLODLevels();\n\n      return this;\n    }\n    /**\n     * Returns the LOD level mesh at the passed distance or null if not found.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param distance The distance from the center of the object to show this level\n     * @returns a Mesh or `null`\n     */\n\n  }, {\n    key: \"getLODLevelAtDistance\",\n    value: function getLODLevelAtDistance(distance) {\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        var level = internalDataInfo._LODLevels[index];\n\n        if (level.distanceOrScreenCoverage === distance) {\n          return level.mesh;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Remove a mesh from the LOD array\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param mesh defines the mesh to be removed\n     * @returns This mesh (for chaining)\n     */\n\n  }, {\n    key: \"removeLODLevel\",\n    value: function removeLODLevel(mesh) {\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        if (internalDataInfo._LODLevels[index].mesh === mesh) {\n          internalDataInfo._LODLevels.splice(index, 1);\n\n          if (mesh) {\n            mesh._masterMesh = null;\n          }\n        }\n      }\n\n      this._sortLODLevels();\n\n      return this;\n    }\n    /**\n     * Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_lod\n     * @param camera defines the camera to use to compute distance\n     * @param boundingSphere defines a custom bounding sphere to use instead of the one from this mesh\n     * @returns This mesh (for chaining)\n     */\n\n  }, {\n    key: \"getLOD\",\n    value: function getLOD(camera, boundingSphere) {\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {\n        return this;\n      }\n\n      var bSphere;\n\n      if (boundingSphere) {\n        bSphere = boundingSphere;\n      } else {\n        var boundingInfo = this.getBoundingInfo();\n        bSphere = boundingInfo.boundingSphere;\n      }\n\n      var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();\n      var useScreenCoverage = internalDataInfo._useLODScreenCoverage;\n      var compareValue = distanceToCamera;\n      var compareSign = 1;\n\n      if (useScreenCoverage) {\n        var screenArea = camera.screenArea;\n        var meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;\n        meshArea = meshArea * meshArea * Math.PI;\n        compareValue = meshArea / screenArea;\n        compareSign = -1;\n      }\n\n      if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {\n        if (this.onLODLevelSelection) {\n          this.onLODLevelSelection(compareValue, this, this);\n        }\n\n        return this;\n      }\n\n      for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {\n        var level = internalDataInfo._LODLevels[index];\n\n        if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {\n          if (level.mesh) {\n            if (level.mesh.delayLoadState === 4) {\n              level.mesh._checkDelayState();\n\n              return this;\n            }\n\n            if (level.mesh.delayLoadState === 2) {\n              return this;\n            }\n\n            level.mesh._preActivate();\n\n            level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);\n          }\n\n          if (this.onLODLevelSelection) {\n            this.onLODLevelSelection(compareValue, this, level.mesh);\n          }\n\n          return level.mesh;\n        }\n      }\n\n      if (this.onLODLevelSelection) {\n        this.onLODLevelSelection(compareValue, this, this);\n      }\n\n      return this;\n    }\n    /**\n     * Gets the mesh internal Geometry object\n     */\n\n  }, {\n    key: \"geometry\",\n    get: function get() {\n      return this._geometry;\n    }\n    /**\n     * Returns the total number of vertices within the mesh geometry or zero if the mesh has no geometry.\n     * @returns the total number of vertices\n     */\n\n  }, {\n    key: \"getTotalVertices\",\n    value: function getTotalVertices() {\n      if (this._geometry === null || this._geometry === undefined) {\n        return 0;\n      }\n\n      return this._geometry.getTotalVertices();\n    }\n    /**\n     * Returns the content of an associated vertex buffer\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param copyWhenShared defines a boolean indicating that if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one\n     * @param forceCopy defines a boolean forcing the copy of the buffer no matter what the value of copyWhenShared is\n     * @returns a FloatArray or null if the mesh has no geometry or no vertex buffer for this kind.\n     */\n\n  }, {\n    key: \"getVerticesData\",\n    value: function getVerticesData(kind, copyWhenShared, forceCopy) {\n      var _this$_userInstancedB, _this$_userInstancedB2;\n\n      if (!this._geometry) {\n        return null;\n      }\n\n      var data = (_this$_userInstancedB = this._userInstancedBuffersStorage) === null || _this$_userInstancedB === void 0 ? void 0 : (_this$_userInstancedB2 = _this$_userInstancedB.vertexBuffers[kind]) === null || _this$_userInstancedB2 === void 0 ? void 0 : _this$_userInstancedB2.getFloatData(this._geometry.getTotalVertices(), forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);\n\n      if (!data) {\n        data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);\n      }\n\n      return data;\n    }\n    /**\n     * Returns the mesh VertexBuffer object from the requested `kind`\n     * @param kind defines which buffer to read from (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a FloatArray or null if the mesh has no vertex buffer for this kind.\n     */\n\n  }, {\n    key: \"getVertexBuffer\",\n    value: function getVertexBuffer(kind) {\n      var _this$_userInstancedB3, _this$_userInstancedB4;\n\n      if (!this._geometry) {\n        return null;\n      }\n\n      return (_this$_userInstancedB3 = (_this$_userInstancedB4 = this._userInstancedBuffersStorage) === null || _this$_userInstancedB4 === void 0 ? void 0 : _this$_userInstancedB4.vertexBuffers[kind]) !== null && _this$_userInstancedB3 !== void 0 ? _this$_userInstancedB3 : this._geometry.getVertexBuffer(kind);\n    }\n    /**\n     * Tests if a specific vertex buffer is associated with this mesh\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.NormalKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a boolean\n     */\n\n  }, {\n    key: \"isVerticesDataPresent\",\n    value: function isVerticesDataPresent(kind) {\n      var _this$_userInstancedB5;\n\n      if (!this._geometry) {\n        if (this._delayInfo) {\n          return this._delayInfo.indexOf(kind) !== -1;\n        }\n\n        return false;\n      }\n\n      return ((_this$_userInstancedB5 = this._userInstancedBuffersStorage) === null || _this$_userInstancedB5 === void 0 ? void 0 : _this$_userInstancedB5.vertexBuffers[kind]) !== undefined || this._geometry.isVerticesDataPresent(kind);\n    }\n    /**\n     * Returns a boolean defining if the vertex data for the requested `kind` is updatable.\n     * @param kind defines which buffer to check (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @returns a boolean\n     */\n\n  }, {\n    key: \"isVertexBufferUpdatable\",\n    value: function isVertexBufferUpdatable(kind) {\n      var _this$_userInstancedB6, _this$_userInstancedB7;\n\n      if (!this._geometry) {\n        if (this._delayInfo) {\n          return this._delayInfo.indexOf(kind) !== -1;\n        }\n\n        return false;\n      }\n\n      return ((_this$_userInstancedB6 = this._userInstancedBuffersStorage) === null || _this$_userInstancedB6 === void 0 ? void 0 : (_this$_userInstancedB7 = _this$_userInstancedB6.vertexBuffers[kind]) === null || _this$_userInstancedB7 === void 0 ? void 0 : _this$_userInstancedB7.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);\n    }\n    /**\n     * Returns a string which contains the list of existing `kinds` of Vertex Data associated with this mesh.\n     * @returns an array of strings\n     */\n\n  }, {\n    key: \"getVerticesDataKinds\",\n    value: function getVerticesDataKinds() {\n      if (!this._geometry) {\n        var result = new Array();\n\n        if (this._delayInfo) {\n          this._delayInfo.forEach(function (kind) {\n            result.push(kind);\n          });\n        }\n\n        return result;\n      }\n\n      var kinds = this._geometry.getVerticesDataKinds();\n\n      if (this._userInstancedBuffersStorage) {\n        for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n          kinds.push(kind);\n        }\n      }\n\n      return kinds;\n    }\n    /**\n     * Returns a positive integer : the total number of indices in this mesh geometry.\n     * @returns the numner of indices or zero if the mesh has no geometry.\n     */\n\n  }, {\n    key: \"getTotalIndices\",\n    value: function getTotalIndices() {\n      if (!this._geometry) {\n        return 0;\n      }\n\n      return this._geometry.getTotalIndices();\n    }\n    /**\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\n     * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n     * @returns the indices array or an empty array if the mesh has no geometry\n     */\n\n  }, {\n    key: \"getIndices\",\n    value: function getIndices(copyWhenShared, forceCopy) {\n      if (!this._geometry) {\n        return [];\n      }\n\n      return this._geometry.getIndices(copyWhenShared, forceCopy);\n    }\n  }, {\n    key: \"isBlocked\",\n    get: function get() {\n      return this._masterMesh !== null && this._masterMesh !== undefined;\n    }\n    /**\n     * Determine if the current mesh is ready to be rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @param forceInstanceSupport will check if the mesh will be ready when used with instances (false by default)\n     * @returns true if all associated assets are ready (material, textures, shaders)\n     */\n\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      var completeCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var forceInstanceSupport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.delayLoadState === 2) {\n        return false;\n      }\n\n      if (!_get(_getPrototypeOf(Mesh.prototype), \"isReady\", this).call(this, completeCheck)) {\n        return false;\n      }\n\n      if (!this.subMeshes || this.subMeshes.length === 0) {\n        return true;\n      }\n\n      if (!completeCheck) {\n        return true;\n      }\n\n      var engine = this.getEngine();\n      var scene = this.getScene();\n      var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);\n      this.computeWorldMatrix();\n      var mat = this.material || scene.defaultMaterial;\n\n      if (mat) {\n        if (mat._storeEffectOnSubMeshes) {\n          var _iterator3 = _createForOfIteratorHelper(this.subMeshes),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var subMesh = _step3.value;\n              var effectiveMaterial = subMesh.getMaterial();\n\n              if (effectiveMaterial) {\n                if (effectiveMaterial._storeEffectOnSubMeshes) {\n                  if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n                    return false;\n                  }\n                } else {\n                  if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {\n                    return false;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } else {\n          if (!mat.isReady(this, hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      } // Shadows\n\n\n      var currentRenderPassId = engine.currentRenderPassId;\n\n      var _iterator4 = _createForOfIteratorHelper(this.lightSources),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _generator$getShadowM, _generator$getShadowM2, _generator$getShadowM3, _generator$getShadowM4;\n\n          var light = _step4.value;\n          var generator = light.getShadowGenerator();\n\n          if (generator && (!((_generator$getShadowM = generator.getShadowMap()) !== null && _generator$getShadowM !== void 0 && _generator$getShadowM.renderList) || (_generator$getShadowM2 = generator.getShadowMap()) !== null && _generator$getShadowM2 !== void 0 && _generator$getShadowM2.renderList && ((_generator$getShadowM3 = generator.getShadowMap()) === null || _generator$getShadowM3 === void 0 ? void 0 : (_generator$getShadowM4 = _generator$getShadowM3.renderList) === null || _generator$getShadowM4 === void 0 ? void 0 : _generator$getShadowM4.indexOf(this)) !== -1)) {\n            if (generator.getShadowMap()) {\n              engine.currentRenderPassId = generator.getShadowMap().renderPassId;\n            }\n\n            var _iterator6 = _createForOfIteratorHelper(this.subMeshes),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var _subMesh$getMaterial$, _subMesh$getMaterial;\n\n                var _subMesh = _step6.value;\n\n                if (!generator.isReady(_subMesh, hardwareInstancedRendering, (_subMesh$getMaterial$ = (_subMesh$getMaterial = _subMesh.getMaterial()) === null || _subMesh$getMaterial === void 0 ? void 0 : _subMesh$getMaterial.needAlphaBlendingForMesh(this)) !== null && _subMesh$getMaterial$ !== void 0 ? _subMesh$getMaterial$ : false)) {\n                  engine.currentRenderPassId = currentRenderPassId;\n                  return false;\n                }\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            engine.currentRenderPassId = currentRenderPassId;\n          }\n        } // LOD\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(this._internalMeshDataInfo._LODLevels),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var lod = _step5.value;\n\n          if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return true;\n    }\n    /**\n     * Gets a boolean indicating if the normals aren't to be recomputed on next mesh `positions` array update. This property is pertinent only for updatable parametric shapes.\n     */\n\n  }, {\n    key: \"areNormalsFrozen\",\n    get: function get() {\n      return this._internalMeshDataInfo._areNormalsFrozen;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It prevents the mesh normals from being recomputed on next `positions` array update.\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"freezeNormals\",\n    value: function freezeNormals() {\n      this._internalMeshDataInfo._areNormalsFrozen = true;\n      return this;\n    }\n    /**\n     * This function affects parametric shapes on vertex position update only : ribbons, tubes, etc. It has no effect at all on other shapes. It reactivates the mesh normals computation if it was previously frozen\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"unfreezeNormals\",\n    value: function unfreezeNormals() {\n      this._internalMeshDataInfo._areNormalsFrozen = false;\n      return this;\n    }\n    /**\n     * Sets a value overriding the instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs\n     */\n\n  }, {\n    key: \"overridenInstanceCount\",\n    set: function set(count) {\n      this._instanceDataStorage.overridenInstanceCount = count;\n    } // Methods\n\n    /** @internal */\n\n  }, {\n    key: \"_preActivate\",\n    value: function _preActivate() {\n      var internalDataInfo = this._internalMeshDataInfo;\n      var sceneRenderId = this.getScene().getRenderId();\n\n      if (internalDataInfo._preActivateId === sceneRenderId) {\n        return this;\n      }\n\n      internalDataInfo._preActivateId = sceneRenderId;\n      this._instanceDataStorage.visibleInstances = null;\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_preActivateForIntermediateRendering\",\n    value: function _preActivateForIntermediateRendering(renderId) {\n      if (this._instanceDataStorage.visibleInstances) {\n        this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;\n      }\n\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_registerInstanceForRenderId\",\n    value: function _registerInstanceForRenderId(instance, renderId) {\n      if (!this._instanceDataStorage.visibleInstances) {\n        this._instanceDataStorage.visibleInstances = {\n          defaultRenderId: renderId,\n          selfDefaultRenderId: this._renderId\n        };\n      }\n\n      if (!this._instanceDataStorage.visibleInstances[renderId]) {\n        if (this._instanceDataStorage.previousRenderId !== undefined && this._instanceDataStorage.isFrozen) {\n          this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;\n        }\n\n        this._instanceDataStorage.previousRenderId = renderId;\n        this._instanceDataStorage.visibleInstances[renderId] = new Array();\n      }\n\n      this._instanceDataStorage.visibleInstances[renderId].push(instance);\n\n      return this;\n    }\n  }, {\n    key: \"_afterComputeWorldMatrix\",\n    value: function _afterComputeWorldMatrix() {\n      _get(_getPrototypeOf(Mesh.prototype), \"_afterComputeWorldMatrix\", this).call(this);\n\n      if (!this.hasThinInstances) {\n        return;\n      }\n\n      if (!this.doNotSyncBoundingInfo) {\n        this.thinInstanceRefreshBoundingInfo(false);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_postActivate\",\n    value: function _postActivate() {\n      if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {\n        this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);\n\n        this.edgesRenderer.customInstances.push(this.getWorldMatrix());\n      }\n    }\n    /**\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\n     * This means the mesh underlying bounding box and sphere are recomputed.\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\n     * @param applyMorph  defines whether to apply the morph target before computing the bounding info\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"refreshBoundingInfo\",\n    value: function refreshBoundingInfo() {\n      var applySkeleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var applyMorph = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {\n        return this;\n      }\n\n      var bias = this.geometry ? this.geometry.boundingBias : null;\n\n      this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);\n\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_createGlobalSubMesh\",\n    value: function _createGlobalSubMesh(force) {\n      var totalVertices = this.getTotalVertices();\n\n      if (!totalVertices || !this.getIndices()) {\n        return null;\n      } // Check if we need to recreate the submeshes\n\n\n      if (this.subMeshes && this.subMeshes.length > 0) {\n        var ib = this.getIndices();\n\n        if (!ib) {\n          return null;\n        }\n\n        var totalIndices = ib.length;\n        var needToRecreate = false;\n\n        if (force) {\n          needToRecreate = true;\n        } else {\n          var _iterator7 = _createForOfIteratorHelper(this.subMeshes),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var submesh = _step7.value;\n\n              if (submesh.indexStart + submesh.indexCount > totalIndices) {\n                needToRecreate = true;\n                break;\n              }\n\n              if (submesh.verticesStart + submesh.verticesCount > totalVertices) {\n                needToRecreate = true;\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n\n        if (!needToRecreate) {\n          return this.subMeshes[0];\n        }\n      }\n\n      this.releaseSubMeshes();\n      return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);\n    }\n    /**\n     * This function will subdivide the mesh into multiple submeshes\n     * @param count defines the expected number of submeshes\n     */\n\n  }, {\n    key: \"subdivide\",\n    value: function subdivide(count) {\n      if (count < 1) {\n        return;\n      }\n\n      var totalIndices = this.getTotalIndices();\n      var subdivisionSize = totalIndices / count | 0;\n      var offset = 0; // Ensure that subdivisionSize is a multiple of 3\n\n      while (subdivisionSize % 3 !== 0) {\n        subdivisionSize++;\n      }\n\n      this.releaseSubMeshes();\n\n      for (var index = 0; index < count; index++) {\n        if (offset >= totalIndices) {\n          break;\n        }\n\n        SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);\n        offset += subdivisionSize;\n      }\n\n      this.synchronizeInstances();\n    }\n    /**\n     * Copy a FloatArray into a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     * @param stride defines the data stride size (can be null)\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"setVerticesData\",\n    value: function setVerticesData(kind, data) {\n      var updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var stride = arguments.length > 3 ? arguments[3] : undefined;\n\n      if (!this._geometry) {\n        var vertexData = new VertexData();\n        vertexData.set(data, kind);\n        var scene = this.getScene();\n        new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n      } else {\n        this._geometry.setVerticesData(kind, data, updatable, stride);\n      }\n\n      return this;\n    }\n    /**\n     * Delete a vertex buffer associated with this mesh\n     * @param kind defines which buffer to delete (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     */\n\n  }, {\n    key: \"removeVerticesData\",\n    value: function removeVerticesData(kind) {\n      if (!this._geometry) {\n        return;\n      }\n\n      this._geometry.removeVerticesData(kind);\n    }\n    /**\n     * Flags an associated vertex buffer as updatable\n     * @param kind defines which buffer to use (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param updatable defines if the updated vertex buffer must be flagged as updatable\n     */\n\n  }, {\n    key: \"markVerticesDataAsUpdatable\",\n    value: function markVerticesDataAsUpdatable(kind) {\n      var updatable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var vb = this.getVertexBuffer(kind);\n\n      if (!vb || vb.isUpdatable() === updatable) {\n        return;\n      }\n\n      this.setVerticesData(kind, this.getVerticesData(kind), updatable);\n    }\n    /**\n     * Sets the mesh global Vertex Buffer\n     * @param buffer defines the buffer to use\n     * @param disposeExistingBuffer disposes the existing buffer, if any (default: true)\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"setVerticesBuffer\",\n    value: function setVerticesBuffer(buffer) {\n      var disposeExistingBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this._geometry) {\n        this._geometry = Geometry.CreateGeometryForMesh(this);\n      }\n\n      this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);\n\n      return this;\n    }\n    /**\n     * Update a specific associated vertex buffer\n     * @param kind defines which buffer to write to (positions, indices, normals, etc). Possible `kind` values :\n     * - VertexBuffer.PositionKind\n     * - VertexBuffer.UVKind\n     * - VertexBuffer.UV2Kind\n     * - VertexBuffer.UV3Kind\n     * - VertexBuffer.UV4Kind\n     * - VertexBuffer.UV5Kind\n     * - VertexBuffer.UV6Kind\n     * - VertexBuffer.ColorKind\n     * - VertexBuffer.MatricesIndicesKind\n     * - VertexBuffer.MatricesIndicesExtraKind\n     * - VertexBuffer.MatricesWeightsKind\n     * - VertexBuffer.MatricesWeightsExtraKind\n     * @param data defines the data source\n     * @param updateExtends defines if extends info of the mesh must be updated (can be null). This is mostly useful for \"position\" kind\n     * @param makeItUnique defines if the geometry associated with the mesh must be cloned to make the change only for this mesh (and not all meshes associated with the same geometry)\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"updateVerticesData\",\n    value: function updateVerticesData(kind, data, updateExtends, makeItUnique) {\n      if (!this._geometry) {\n        return this;\n      }\n\n      if (!makeItUnique) {\n        this._geometry.updateVerticesData(kind, data, updateExtends);\n      } else {\n        this.makeGeometryUnique();\n        this.updateVerticesData(kind, data, updateExtends, false);\n      }\n\n      return this;\n    }\n    /**\n     * This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.\n     * @see https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions\n     * @param positionFunction is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything\n     * @param computeNormals is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"updateMeshPositions\",\n    value: function updateMeshPositions(positionFunction) {\n      var computeNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var positions = this.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!positions) {\n        return this;\n      }\n\n      positionFunction(positions);\n      this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);\n\n      if (computeNormals) {\n        var indices = this.getIndices();\n        var normals = this.getVerticesData(VertexBuffer.NormalKind);\n\n        if (!normals) {\n          return this;\n        }\n\n        VertexData.ComputeNormals(positions, indices, normals);\n        this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);\n      }\n\n      return this;\n    }\n    /**\n     * Creates a un-shared specific occurence of the geometry for the mesh.\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"makeGeometryUnique\",\n    value: function makeGeometryUnique() {\n      if (!this._geometry) {\n        return this;\n      }\n\n      if (this._geometry.meshes.length === 1) {\n        return this;\n      }\n\n      var oldGeometry = this._geometry;\n\n      var geometry = this._geometry.copy(Geometry.RandomId());\n\n      oldGeometry.releaseForMesh(this, true);\n      geometry.applyToMesh(this);\n      return this;\n    }\n    /**\n     * Set the index buffer of this mesh\n     * @param indices defines the source data\n     * @param totalVertices defines the total number of vertices referenced by this index data (can be null)\n     * @param updatable defines if the updated index buffer must be flagged as updatable (default is false)\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"setIndices\",\n    value: function setIndices(indices) {\n      var totalVertices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var updatable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!this._geometry) {\n        var vertexData = new VertexData();\n        vertexData.indices = indices;\n        var scene = this.getScene();\n        new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);\n      } else {\n        this._geometry.setIndices(indices, totalVertices, updatable);\n      }\n\n      return this;\n    }\n    /**\n     * Update the current index buffer\n     * @param indices defines the source data\n     * @param offset defines the offset in the index buffer where to store the new data (can be null)\n     * @param gpuMemoryOnly defines a boolean indicating that only the GPU memory must be updated leaving the CPU version of the indices unchanged (false by default)\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"updateIndices\",\n    value: function updateIndices(indices, offset) {\n      var gpuMemoryOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (!this._geometry) {\n        return this;\n      }\n\n      this._geometry.updateIndices(indices, offset, gpuMemoryOnly);\n\n      return this;\n    }\n    /**\n     * Invert the geometry to move from a right handed system to a left handed one.\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"toLeftHanded\",\n    value: function toLeftHanded() {\n      if (!this._geometry) {\n        return this;\n      }\n\n      this._geometry.toLeftHanded();\n\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_bind\",\n    value: function _bind(subMesh, effect, fillMode) {\n      if (!this._geometry) {\n        return this;\n      }\n\n      var engine = this.getScene().getEngine(); // Morph targets\n\n      if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {\n        this.morphTargetManager._bind(effect);\n      } // Wireframe\n\n\n      var indexToBind;\n\n      if (this._unIndexed) {\n        indexToBind = null;\n      } else {\n        switch (fillMode) {\n          case Material.PointFillMode:\n            indexToBind = null;\n            break;\n\n          case Material.WireFrameFillMode:\n            indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);\n            break;\n\n          default:\n          case Material.TriangleFillMode:\n            indexToBind = this._geometry.getIndexBuffer();\n            break;\n        }\n      } // VBOs\n\n\n      if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\n        this._geometry._bind(effect, indexToBind);\n      } else {\n        this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\n      }\n\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(subMesh, fillMode, instancesCount) {\n      if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n        return this;\n      }\n\n      if (this._internalMeshDataInfo._onBeforeDrawObservable) {\n        this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);\n      }\n\n      var scene = this.getScene();\n      var engine = scene.getEngine();\n\n      if (this._unIndexed || fillMode == Material.PointFillMode) {\n        // or triangles as points\n        engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);\n      } else if (fillMode == Material.WireFrameFillMode) {\n        // Triangles as wireframe\n        engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);\n      } else {\n        engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);\n      }\n\n      return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just before the rendering process\n     * @param func defines the function to call before rendering this mesh\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"registerBeforeRender\",\n    value: function registerBeforeRender(func) {\n      this.onBeforeRenderObservable.add(func);\n      return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called before the rendering\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"unregisterBeforeRender\",\n    value: function unregisterBeforeRender(func) {\n      this.onBeforeRenderObservable.removeCallback(func);\n      return this;\n    }\n    /**\n     * Registers for this mesh a javascript function called just after the rendering is complete\n     * @param func defines the function to call after rendering this mesh\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"registerAfterRender\",\n    value: function registerAfterRender(func) {\n      this.onAfterRenderObservable.add(func);\n      return this;\n    }\n    /**\n     * Disposes a previously registered javascript function called after the rendering.\n     * @param func defines the function to remove\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"unregisterAfterRender\",\n    value: function unregisterAfterRender(func) {\n      this.onAfterRenderObservable.removeCallback(func);\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getInstancesRenderList\",\n    value: function _getInstancesRenderList(subMeshId) {\n      var isReplacementMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this._instanceDataStorage.isFrozen) {\n        if (isReplacementMode) {\n          this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;\n          this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;\n          return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;\n        }\n\n        if (this._instanceDataStorage.previousBatch) {\n          return this._instanceDataStorage.previousBatch;\n        }\n      }\n\n      var scene = this.getScene();\n\n      var isInIntermediateRendering = scene._isInIntermediateRendering();\n\n      var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;\n      var batchCache = this._instanceDataStorage.batchCache;\n      batchCache.mustReturn = false;\n      batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;\n      batchCache.visibleInstances[subMeshId] = null;\n\n      if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {\n        var visibleInstances = this._instanceDataStorage.visibleInstances;\n        var currentRenderId = scene.getRenderId();\n        var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;\n        batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];\n\n        if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {\n          batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];\n        }\n      }\n\n      batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== undefined;\n      this._instanceDataStorage.previousBatch = batchCache;\n      return batchCache;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_renderWithInstances\",\n    value: function _renderWithInstances(subMesh, fillMode, batch, effect, engine) {\n      var visibleInstances = batch.visibleInstances[subMesh._id];\n\n      if (!visibleInstances) {\n        return this;\n      }\n\n      var instanceStorage = this._instanceDataStorage;\n      var currentInstancesBufferSize = instanceStorage.instancesBufferSize;\n      var instancesBuffer = instanceStorage.instancesBuffer;\n      var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;\n      var matricesCount = visibleInstances.length + 1;\n      var bufferSize = matricesCount * 16 * 4;\n\n      while (instanceStorage.instancesBufferSize < bufferSize) {\n        instanceStorage.instancesBufferSize *= 2;\n      }\n\n      if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n        instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n      }\n\n      if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {\n        instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);\n      }\n\n      var offset = 0;\n      var instancesCount = 0;\n      var renderSelf = batch.renderSelf[subMesh._id];\n      var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;\n\n      if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {\n        var world = this.getWorldMatrix();\n\n        if (renderSelf) {\n          if (this._scene.needsPreviousWorldMatrices) {\n            if (!instanceStorage.masterMeshPreviousWorldMatrix) {\n              instanceStorage.masterMeshPreviousWorldMatrix = world.clone();\n              instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n            } else {\n              instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);\n            }\n          }\n\n          world.copyToArray(instanceStorage.instancesData, offset);\n          offset += 16;\n          instancesCount++;\n        }\n\n        if (visibleInstances) {\n          var _subMesh$getMaterial2;\n\n          if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && (_subMesh$getMaterial2 = subMesh.getMaterial()) !== null && _subMesh$getMaterial2 !== void 0 && _subMesh$getMaterial2.needAlphaBlendingForMesh(subMesh.getRenderingMesh())) {\n            var cameraPosition = this._scene.activeCamera.globalPosition;\n\n            for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {\n              var instanceMesh = visibleInstances[instanceIndex];\n              instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);\n            }\n\n            visibleInstances.sort(function (m1, m2) {\n              return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;\n            });\n          }\n\n          for (var _instanceIndex = 0; _instanceIndex < visibleInstances.length; _instanceIndex++) {\n            var instance = visibleInstances[_instanceIndex];\n            var matrix = instance.getWorldMatrix();\n            matrix.copyToArray(instanceStorage.instancesData, offset);\n\n            if (this._scene.needsPreviousWorldMatrices) {\n              if (!instance._previousWorldMatrix) {\n                instance._previousWorldMatrix = matrix.clone();\n\n                instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n              } else {\n                instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);\n\n                instance._previousWorldMatrix.copyFrom(matrix);\n              }\n            }\n\n            offset += 16;\n            instancesCount++;\n          }\n        }\n      } else {\n        instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;\n      }\n\n      if (needUpdateBuffer) {\n        if (instancesBuffer) {\n          instancesBuffer.dispose();\n        }\n\n        if (instancesPreviousBuffer) {\n          instancesPreviousBuffer.dispose();\n        }\n\n        instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);\n        instanceStorage.instancesBuffer = instancesBuffer;\n\n        if (!this._userInstancedBuffersStorage) {\n          this._userInstancedBuffersStorage = {\n            data: {},\n            vertexBuffers: {},\n            strides: {},\n            sizes: {},\n            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : undefined\n          };\n        }\n\n        this._userInstancedBuffersStorage.vertexBuffers[\"world0\"] = instancesBuffer.createVertexBuffer(\"world0\", 0, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world1\"] = instancesBuffer.createVertexBuffer(\"world1\", 4, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world2\"] = instancesBuffer.createVertexBuffer(\"world2\", 8, 4);\n        this._userInstancedBuffersStorage.vertexBuffers[\"world3\"] = instancesBuffer.createVertexBuffer(\"world3\", 12, 4);\n\n        if (this._scene.needsPreviousWorldMatrices) {\n          instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);\n          instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld0\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld0\", 0, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld1\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld1\", 4, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld2\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld2\", 8, 4);\n          this._userInstancedBuffersStorage.vertexBuffers[\"previousWorld3\"] = instancesPreviousBuffer.createVertexBuffer(\"previousWorld3\", 12, 4);\n        }\n\n        this._invalidateInstanceVertexArrayObject();\n      } else {\n        if (!this._instanceDataStorage.isFrozen) {\n          instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n\n          if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {\n            instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);\n          }\n        }\n      }\n\n      this._processInstancedBuffers(visibleInstances, renderSelf); // Stats\n\n\n      this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false); // Draw\n\n\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = true;\n      }\n\n      this._bind(subMesh, effect, fillMode);\n\n      this._draw(subMesh, fillMode, instancesCount); // Write current matrices as previous matrices in case of manual update\n      // Default behaviour when previous matrices are not specified explicitly\n      // Will break if instances number/order changes\n\n\n      if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate) {\n        instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);\n      }\n\n      engine.unbindInstanceAttributes();\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_renderWithThinInstances\",\n    value: function _renderWithThinInstances(subMesh, fillMode, effect, engine) {\n      var _this$_thinInstanceDa2, _this$_thinInstanceDa3;\n\n      // Stats\n      var instancesCount = (_this$_thinInstanceDa2 = (_this$_thinInstanceDa3 = this._thinInstanceDataStorage) === null || _this$_thinInstanceDa3 === void 0 ? void 0 : _this$_thinInstanceDa3.instancesCount) !== null && _this$_thinInstanceDa2 !== void 0 ? _this$_thinInstanceDa2 : 0;\n\n      this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false); // Draw\n\n\n      if (engine._currentDrawContext) {\n        engine._currentDrawContext.useInstancing = true;\n      }\n\n      this._bind(subMesh, effect, fillMode);\n\n      this._draw(subMesh, fillMode, instancesCount); // Write current matrices as previous matrices\n      // Default behaviour when previous matrices are not specified explicitly\n      // Will break if instances number/order changes\n\n\n      if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {\n        if (!this._thinInstanceDataStorage.previousMatrixBuffer) {\n          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.matrixData, false);\n        } else {\n          this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);\n        }\n      }\n\n      engine.unbindInstanceAttributes();\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"_processInstancedBuffers\",\n    value: function _processInstancedBuffers(visibleInstances, renderSelf) {// Do nothing\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_processRendering\",\n    value: function _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {\n      var scene = this.getScene();\n      var engine = scene.getEngine();\n\n      if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {\n        this._renderWithThinInstances(subMesh, fillMode, effect, engine);\n\n        return this;\n      }\n\n      if (hardwareInstancedRendering) {\n        this._renderWithInstances(subMesh, fillMode, batch, effect, engine);\n      } else {\n        if (engine._currentDrawContext) {\n          engine._currentDrawContext.useInstancing = false;\n        }\n\n        var instanceCount = 0;\n\n        if (batch.renderSelf[subMesh._id]) {\n          // Draw\n          if (onBeforeDraw) {\n            onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);\n          }\n\n          instanceCount++;\n\n          this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);\n        }\n\n        var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];\n\n        if (visibleInstancesForSubMesh) {\n          var visibleInstanceCount = visibleInstancesForSubMesh.length;\n          instanceCount += visibleInstanceCount; // Stats\n\n          for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {\n            var instance = visibleInstancesForSubMesh[instanceIndex]; // World\n\n            var world = instance.getWorldMatrix();\n\n            if (onBeforeDraw) {\n              onBeforeDraw(true, world, effectiveMaterial);\n            } // Draw\n\n\n            this._draw(subMesh, fillMode);\n          }\n        } // Stats\n\n\n        scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);\n      }\n\n      return this;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_rebuild\",\n    value: function _rebuild() {\n      var dispose = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this._instanceDataStorage.instancesBuffer) {\n        // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n        if (dispose) {\n          this._instanceDataStorage.instancesBuffer.dispose();\n        }\n\n        this._instanceDataStorage.instancesBuffer = null;\n      }\n\n      if (this._userInstancedBuffersStorage) {\n        for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {\n          var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];\n\n          if (buffer) {\n            // Dispose instance buffer to be recreated in _renderWithInstances when rendered\n            if (dispose) {\n              buffer.dispose();\n            }\n\n            this._userInstancedBuffersStorage.vertexBuffers[kind] = null;\n          }\n        }\n\n        if (this._userInstancedBuffersStorage.vertexArrayObjects) {\n          this._userInstancedBuffersStorage.vertexArrayObjects = {};\n        }\n      }\n\n      this._internalMeshDataInfo._effectiveMaterial = null;\n\n      _get(_getPrototypeOf(Mesh.prototype), \"_rebuild\", this).call(this, dispose);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_freeze\",\n    value: function _freeze() {\n      if (!this.subMeshes) {\n        return;\n      } // Prepare batches\n\n\n      for (var index = 0; index < this.subMeshes.length; index++) {\n        this._getInstancesRenderList(index);\n      }\n\n      this._internalMeshDataInfo._effectiveMaterial = null;\n      this._instanceDataStorage.isFrozen = true;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_unFreeze\",\n    value: function _unFreeze() {\n      this._instanceDataStorage.isFrozen = false;\n      this._instanceDataStorage.previousBatch = null;\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n      var _subMesh$effect, _material$getEffect, _drawWrapper$effect, _drawWrapper;\n\n      var scene = this.getScene();\n\n      if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {\n        this._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n      } else {\n        this._internalAbstractMeshDataInfo._isActive = false;\n      }\n\n      if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {\n        return this;\n      } // Managing instances\n\n\n      var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);\n\n      if (batch.mustReturn) {\n        return this;\n      } // Checking geometry state\n\n\n      if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {\n        return this;\n      }\n\n      var engine = scene.getEngine();\n      var oldCameraMaxZ = 0;\n      var oldCamera = null;\n\n      if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {\n        oldCameraMaxZ = scene.activeCamera.maxZ;\n        oldCamera = scene.activeCamera;\n        scene.activeCamera.maxZ = 0;\n        scene.updateTransformMatrix(true);\n      }\n\n      if (this._internalMeshDataInfo._onBeforeRenderObservable) {\n        this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);\n      }\n\n      var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;\n      var instanceDataStorage = this._instanceDataStorage;\n      var material = subMesh.getMaterial();\n\n      if (!material) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n\n        return this;\n      } // Material\n\n\n      if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {\n        if (material._storeEffectOnSubMeshes) {\n          if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {\n            if (oldCamera) {\n              oldCamera.maxZ = oldCameraMaxZ;\n              scene.updateTransformMatrix(true);\n            }\n\n            return this;\n          }\n        } else if (!material.isReady(this, hardwareInstancedRendering)) {\n          if (oldCamera) {\n            oldCamera.maxZ = oldCameraMaxZ;\n            scene.updateTransformMatrix(true);\n          }\n\n          return this;\n        }\n\n        this._internalMeshDataInfo._effectiveMaterial = material;\n      } else if (material._storeEffectOnSubMeshes && !((_subMesh$effect = subMesh.effect) !== null && _subMesh$effect !== void 0 && _subMesh$effect._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_material$getEffect = material.getEffect()) !== null && _material$getEffect !== void 0 && _material$getEffect._wasPreviouslyReady)) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n\n        return this;\n      } // Alpha mode\n\n\n      if (enableAlphaMode) {\n        engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);\n      }\n\n      var drawWrapper;\n\n      if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {\n        drawWrapper = subMesh._drawWrapper;\n      } else {\n        drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();\n      }\n\n      var effect = (_drawWrapper$effect = (_drawWrapper = drawWrapper) === null || _drawWrapper === void 0 ? void 0 : _drawWrapper.effect) !== null && _drawWrapper$effect !== void 0 ? _drawWrapper$effect : null;\n\n      var _iterator8 = _createForOfIteratorHelper(scene._beforeRenderingMeshStage),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var step = _step8.value;\n          step.action(this, subMesh, batch, effect);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      if (!drawWrapper || !effect) {\n        if (oldCamera) {\n          oldCamera.maxZ = oldCameraMaxZ;\n          scene.updateTransformMatrix(true);\n        }\n\n        return this;\n      }\n\n      var effectiveMesh = effectiveMeshReplacement || this;\n      var sideOrientation;\n\n      if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {\n        var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n\n        sideOrientation = this.overrideMaterialSideOrientation;\n\n        if (sideOrientation == null) {\n          sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;\n        }\n\n        if (mainDeterminant < 0) {\n          sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        }\n\n        instanceDataStorage.sideOrientation = sideOrientation;\n      } else {\n        sideOrientation = instanceDataStorage.sideOrientation;\n      }\n\n      var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);\n\n      if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {\n        engine.setDepthWrite(true);\n      } // Bind\n\n\n      var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;\n\n      if (this._internalMeshDataInfo._onBeforeBindObservable) {\n        this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);\n      }\n\n      if (!hardwareInstancedRendering) {\n        // Binding will be done later because we need to add more info to the VB\n        this._bind(subMesh, effect, fillMode);\n      }\n\n      var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;\n      var world = effectiveMesh.getWorldMatrix();\n\n      if (effectiveMaterial._storeEffectOnSubMeshes) {\n        effectiveMaterial.bindForSubMesh(world, this, subMesh);\n      } else {\n        effectiveMaterial.bind(world, this);\n      }\n\n      if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {\n        engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n\n        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);\n\n        engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);\n\n        if (this._internalMeshDataInfo._onBetweenPassObservable) {\n          this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);\n        }\n      } // Draw\n\n\n      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial); // Unbind\n\n\n      this._internalMeshDataInfo._effectiveMaterial.unbind();\n\n      var _iterator9 = _createForOfIteratorHelper(scene._afterRenderingMeshStage),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var _step10 = _step9.value;\n\n          _step10.action(this, subMesh, batch, effect);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n\n      if (this._internalMeshDataInfo._onAfterRenderObservable) {\n        this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);\n      }\n\n      if (oldCamera) {\n        oldCamera.maxZ = oldCameraMaxZ;\n        scene.updateTransformMatrix(true);\n      }\n\n      if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {\n        this._freeze();\n      }\n\n      return this;\n    }\n    /**\n     *   Renormalize the mesh and patch it up if there are no weights\n     *   Similar to normalization by adding the weights compute the reciprocal and multiply all elements, this wil ensure that everything adds to 1.\n     *   However in the case of zero weights then we set just a single influence to 1.\n     *   We check in the function for extra's present and if so we use the normalizeSkinWeightsWithExtras rather than the FourWeights version.\n     */\n\n  }, {\n    key: \"cleanMatrixWeights\",\n    value: function cleanMatrixWeights() {\n      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {\n          this._normalizeSkinWeightsAndExtra();\n        } else {\n          this._normalizeSkinFourWeights();\n        }\n      }\n    } // faster 4 weight version.\n\n  }, {\n    key: \"_normalizeSkinFourWeights\",\n    value: function _normalizeSkinFourWeights() {\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      var numWeights = matricesWeights.length;\n\n      for (var a = 0; a < numWeights; a += 4) {\n        // accumulate weights\n        var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3]; // check for invalid weight and just set it to 1.\n\n        if (t === 0) {\n          matricesWeights[a] = 1;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          matricesWeights[a] *= recip;\n          matricesWeights[a + 1] *= recip;\n          matricesWeights[a + 2] *= recip;\n          matricesWeights[a + 3] *= recip;\n        }\n      }\n\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n    } // handle special case of extra verts.  (in theory gltf can handle 12 influences)\n\n  }, {\n    key: \"_normalizeSkinWeightsAndExtra\",\n    value: function _normalizeSkinWeightsAndExtra() {\n      var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n      var numWeights = matricesWeights.length;\n\n      for (var a = 0; a < numWeights; a += 4) {\n        // accumulate weights\n        var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];\n        t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3]; // check for invalid weight and just set it to 1.\n\n        if (t === 0) {\n          matricesWeights[a] = 1;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          matricesWeights[a] *= recip;\n          matricesWeights[a + 1] *= recip;\n          matricesWeights[a + 2] *= recip;\n          matricesWeights[a + 3] *= recip; // same goes for extras\n\n          matricesWeightsExtra[a] *= recip;\n          matricesWeightsExtra[a + 1] *= recip;\n          matricesWeightsExtra[a + 2] *= recip;\n          matricesWeightsExtra[a + 3] *= recip;\n        }\n      }\n\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);\n      this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);\n    }\n    /**\n     * ValidateSkinning is used to determine that a mesh has valid skinning data along with skin metrics, if missing weights,\n     * or not normalized it is returned as invalid mesh the string can be used for console logs, or on screen messages to let\n     * the user know there was an issue with importing the mesh\n     * @returns a validation object with skinned, valid and report string\n     */\n\n  }, {\n    key: \"validateSkinning\",\n    value: function validateSkinning() {\n      var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);\n      var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n\n      if (matricesWeights === null || this.skeleton == null) {\n        return {\n          skinned: false,\n          valid: true,\n          report: \"not skinned\"\n        };\n      }\n\n      var numWeights = matricesWeights.length;\n      var numberNotSorted = 0;\n      var missingWeights = 0;\n      var maxUsedWeights = 0;\n      var numberNotNormalized = 0;\n      var numInfluences = matricesWeightsExtra === null ? 4 : 8;\n      var usedWeightCounts = new Array();\n\n      for (var a = 0; a <= numInfluences; a++) {\n        usedWeightCounts[a] = 0;\n      }\n\n      var toleranceEpsilon = 0.001;\n\n      for (var _a = 0; _a < numWeights; _a += 4) {\n        var lastWeight = matricesWeights[_a];\n        var t = lastWeight;\n        var usedWeights = t === 0 ? 0 : 1;\n\n        for (var b = 1; b < numInfluences; b++) {\n          var d = b < 4 ? matricesWeights[_a + b] : matricesWeightsExtra[_a + b - 4];\n\n          if (d > lastWeight) {\n            numberNotSorted++;\n          }\n\n          if (d !== 0) {\n            usedWeights++;\n          }\n\n          t += d;\n          lastWeight = d;\n        } // count the buffer weights usage\n\n\n        usedWeightCounts[usedWeights]++; // max influences\n\n        if (usedWeights > maxUsedWeights) {\n          maxUsedWeights = usedWeights;\n        } // check for invalid weight and just set it to 1.\n\n\n        if (t === 0) {\n          missingWeights++;\n        } else {\n          // renormalize so everything adds to 1 use reciprocal\n          var recip = 1 / t;\n          var tolerance = 0;\n\n          for (var _b = 0; _b < numInfluences; _b++) {\n            if (_b < 4) {\n              tolerance += Math.abs(matricesWeights[_a + _b] - matricesWeights[_a + _b] * recip);\n            } else {\n              tolerance += Math.abs(matricesWeightsExtra[_a + _b - 4] - matricesWeightsExtra[_a + _b - 4] * recip);\n            }\n          } // arbitrary epsilon value for dictating not normalized\n\n\n          if (tolerance > toleranceEpsilon) {\n            numberNotNormalized++;\n          }\n        }\n      } // validate bone indices are in range of the skeleton\n\n\n      var numBones = this.skeleton.bones.length;\n      var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);\n      var numBadBoneIndices = 0;\n\n      for (var _a2 = 0; _a2 < numWeights; _a2 += 4) {\n        for (var _b2 = 0; _b2 < numInfluences; _b2++) {\n          var index = _b2 < 4 ? matricesIndices[_a2 + _b2] : matricesIndicesExtra[_a2 + _b2 - 4];\n\n          if (index >= numBones || index < 0) {\n            numBadBoneIndices++;\n          }\n        }\n      } // log mesh stats\n\n\n      var output = \"Number of Weights = \" + numWeights / 4 + \"\\nMaximum influences = \" + maxUsedWeights + \"\\nMissing Weights = \" + missingWeights + \"\\nNot Sorted = \" + numberNotSorted + \"\\nNot Normalized = \" + numberNotNormalized + \"\\nWeightCounts = [\" + usedWeightCounts + \"]\" + \"\\nNumber of bones = \" + numBones + \"\\nBad Bone Indices = \" + numBadBoneIndices;\n      return {\n        skinned: true,\n        valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0,\n        report: output\n      };\n    }\n    /** @internal */\n\n  }, {\n    key: \"_checkDelayState\",\n    value: function _checkDelayState() {\n      var scene = this.getScene();\n\n      if (this._geometry) {\n        this._geometry.load(scene);\n      } else if (this.delayLoadState === 4) {\n        this.delayLoadState = 2;\n\n        this._queueLoad(scene);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_queueLoad\",\n    value: function _queueLoad(scene) {\n      var _this2 = this;\n\n      scene.addPendingData(this);\n      var getBinaryData = this.delayLoadingFile.indexOf(\".babylonbinarymeshdata\") !== -1;\n      Tools.LoadFile(this.delayLoadingFile, function (data) {\n        if (data instanceof ArrayBuffer) {\n          _this2._delayLoadingFunction(data, _this2);\n        } else {\n          _this2._delayLoadingFunction(JSON.parse(data), _this2);\n        }\n\n        _this2.instances.forEach(function (instance) {\n          instance.refreshBoundingInfo();\n\n          instance._syncSubMeshes();\n        });\n\n        _this2.delayLoadState = 1;\n        scene.removePendingData(_this2);\n      }, function () {}, scene.offlineProvider, getBinaryData);\n      return this;\n    }\n    /**\n     * Returns `true` if the mesh is within the frustum defined by the passed array of planes.\n     * A mesh is in the frustum if its bounding box intersects the frustum\n     * @param frustumPlanes defines the frustum to test\n     * @returns true if the mesh is in the frustum planes\n     */\n\n  }, {\n    key: \"isInFrustum\",\n    value: function isInFrustum(frustumPlanes) {\n      if (this.delayLoadState === 2) {\n        return false;\n      }\n\n      if (!_get(_getPrototypeOf(Mesh.prototype), \"isInFrustum\", this).call(this, frustumPlanes)) {\n        return false;\n      }\n\n      this._checkDelayState();\n\n      return true;\n    }\n    /**\n     * Sets the mesh material by the material or multiMaterial `id` property\n     * @param id is a string identifying the material or the multiMaterial\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"setMaterialById\",\n    value: function setMaterialById(id) {\n      var materials = this.getScene().materials;\n      var index;\n\n      for (index = materials.length - 1; index > -1; index--) {\n        if (materials[index].id === id) {\n          this.material = materials[index];\n          return this;\n        }\n      } // Multi\n\n\n      var multiMaterials = this.getScene().multiMaterials;\n\n      for (index = multiMaterials.length - 1; index > -1; index--) {\n        if (multiMaterials[index].id === id) {\n          this.material = multiMaterials[index];\n          return this;\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Returns as a new array populated with the mesh material and/or skeleton, if any.\n     * @returns an array of IAnimatable\n     */\n\n  }, {\n    key: \"getAnimatables\",\n    value: function getAnimatables() {\n      var results = new Array();\n\n      if (this.material) {\n        results.push(this.material);\n      }\n\n      if (this.skeleton) {\n        results.push(this.skeleton);\n      }\n\n      return results;\n    }\n    /**\n     * Modifies the mesh geometry according to the passed transformation matrix.\n     * This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.\n     * The mesh normals are modified using the same transformation.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @param transform defines the transform matrix to use\n     * @see https://doc.babylonjs.com/resources/baking_transformations\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"bakeTransformIntoVertices\",\n    value: function bakeTransformIntoVertices(transform) {\n      // Position\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n        return this;\n      }\n\n      var submeshes = this.subMeshes.splice(0);\n\n      this._resetPointsArrayCache();\n\n      var data = this.getVerticesData(VertexBuffer.PositionKind);\n      var temp = new Array();\n      var index;\n\n      for (index = 0; index < data.length; index += 3) {\n        Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform).toArray(temp, index);\n      }\n\n      this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable()); // Normals\n\n      if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {\n        data = this.getVerticesData(VertexBuffer.NormalKind);\n        temp = [];\n\n        for (index = 0; index < data.length; index += 3) {\n          Vector3.TransformNormal(Vector3.FromArray(data, index), transform).normalize().toArray(temp, index);\n        }\n\n        this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());\n      } // flip faces?\n\n\n      if (transform.determinant() < 0) {\n        this.flipFaces();\n      } // Restore submeshes\n\n\n      this.releaseSubMeshes();\n      this.subMeshes = submeshes;\n      return this;\n    }\n    /**\n     * Modifies the mesh geometry according to its own current World Matrix.\n     * The mesh World Matrix is then reset.\n     * This method returns nothing but really modifies the mesh even if it's originally not set as updatable.\n     * Note that, under the hood, this method sets a new VertexBuffer each call.\n     * @see https://doc.babylonjs.com/resources/baking_transformations\n     * @param bakeIndependenlyOfChildren indicates whether to preserve all child nodes' World Matrix during baking\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"bakeCurrentTransformIntoVertices\",\n    value: function bakeCurrentTransformIntoVertices() {\n      var bakeIndependenlyOfChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.bakeTransformIntoVertices(this.computeWorldMatrix(true));\n      this.resetLocalMatrix(bakeIndependenlyOfChildren);\n      return this;\n    } // Cache\n\n    /** @internal */\n\n  }, {\n    key: \"_positions\",\n    get: function get() {\n      if (this._internalAbstractMeshDataInfo._positions) {\n        return this._internalAbstractMeshDataInfo._positions;\n      }\n\n      if (this._geometry) {\n        return this._geometry._positions;\n      }\n\n      return null;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_resetPointsArrayCache\",\n    value: function _resetPointsArrayCache() {\n      if (this._geometry) {\n        this._geometry._resetPointsArrayCache();\n      }\n\n      return this;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_generatePointsArray\",\n    value: function _generatePointsArray() {\n      if (this._geometry) {\n        return this._geometry._generatePointsArray();\n      }\n\n      return false;\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * This method must not get confused with createInstance()\n     * @param name is a string, the name given to the new mesh\n     * @param newParent can be any Node object (default `null`)\n     * @param doNotCloneChildren allows/denies the recursive cloning of the original mesh children if any (default `false`)\n     * @param clonePhysicsImpostor allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any (default `true`)\n     * @returns a new mesh\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n      var newParent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var doNotCloneChildren = arguments.length > 2 ? arguments[2] : undefined;\n      var clonePhysicsImpostor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      return new Mesh(name, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose(doNotRecurse) {\n      var disposeMaterialAndTextures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.morphTargetManager = null;\n\n      if (this._geometry) {\n        this._geometry.releaseForMesh(this, true);\n      }\n\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      if (internalDataInfo._onBeforeDrawObservable) {\n        internalDataInfo._onBeforeDrawObservable.clear();\n      }\n\n      if (internalDataInfo._onBeforeBindObservable) {\n        internalDataInfo._onBeforeBindObservable.clear();\n      }\n\n      if (internalDataInfo._onBeforeRenderObservable) {\n        internalDataInfo._onBeforeRenderObservable.clear();\n      }\n\n      if (internalDataInfo._onAfterRenderObservable) {\n        internalDataInfo._onAfterRenderObservable.clear();\n      }\n\n      if (internalDataInfo._onBetweenPassObservable) {\n        internalDataInfo._onBetweenPassObservable.clear();\n      } // Sources\n\n\n      if (this._scene.useClonedMeshMap) {\n        if (internalDataInfo.meshMap) {\n          for (var uniqueId in internalDataInfo.meshMap) {\n            var mesh = internalDataInfo.meshMap[uniqueId];\n\n            if (mesh) {\n              mesh._internalMeshDataInfo._source = null;\n              internalDataInfo.meshMap[uniqueId] = undefined;\n            }\n          }\n        }\n\n        if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {\n          internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = undefined;\n        }\n      } else {\n        var meshes = this.getScene().meshes;\n\n        var _iterator10 = _createForOfIteratorHelper(meshes),\n            _step11;\n\n        try {\n          for (_iterator10.s(); !(_step11 = _iterator10.n()).done;) {\n            var abstractMesh = _step11.value;\n            var _mesh = abstractMesh;\n\n            if (_mesh._internalMeshDataInfo && _mesh._internalMeshDataInfo._source && _mesh._internalMeshDataInfo._source === this) {\n              _mesh._internalMeshDataInfo._source = null;\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n      }\n\n      internalDataInfo._source = null; // Instances\n\n      this._disposeInstanceSpecificData(); // Thin instances\n\n\n      this._disposeThinInstanceSpecificData();\n\n      if (this._internalMeshDataInfo._checkReadinessObserver) {\n        this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);\n      }\n\n      _get(_getPrototypeOf(Mesh.prototype), \"dispose\", this).call(this, doNotRecurse, disposeMaterialAndTextures);\n    }\n    /** @internal */\n\n  }, {\n    key: \"_disposeInstanceSpecificData\",\n    value: function _disposeInstanceSpecificData() {// Do nothing\n    }\n    /** @internal */\n\n  }, {\n    key: \"_disposeThinInstanceSpecificData\",\n    value: function _disposeThinInstanceSpecificData() {// Do nothing\n    }\n    /** @internal */\n\n  }, {\n    key: \"_invalidateInstanceVertexArrayObject\",\n    value: function _invalidateInstanceVertexArrayObject() {// Do nothing\n    }\n    /**\n     * Modifies the mesh geometry according to a displacement map.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param url is a string, the URL from the image file is to be downloaded.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param onSuccess is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n\n  }, {\n    key: \"applyDisplacementMap\",\n    value: function applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale) {\n      var _this3 = this;\n\n      var forceUpdate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      var scene = this.getScene();\n\n      var onload = function onload(img) {\n        // Getting height map data\n        var heightMapWidth = img.width;\n        var heightMapHeight = img.height;\n\n        var canvas = _this3.getEngine().createCanvas(heightMapWidth, heightMapHeight);\n\n        var context = canvas.getContext(\"2d\");\n        context.drawImage(img, 0, 0); // Create VertexData from map data\n        //Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\n\n        var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;\n\n        _this3.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate); //execute success callback, if set\n\n\n        if (onSuccess) {\n          onSuccess(_this3);\n        }\n      };\n\n      Tools.LoadImage(url, onload, function () {}, scene.offlineProvider);\n      return this;\n    }\n    /**\n     * Modifies the mesh geometry according to a displacementMap buffer.\n     * A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.\n     * The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.\n     * @param buffer is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.\n     * @param heightMapWidth is the width of the buffer image.\n     * @param heightMapHeight is the height of the buffer image.\n     * @param minHeight is the lower limit of the displacement.\n     * @param maxHeight is the upper limit of the displacement.\n     * @param uvOffset is an optional vector2 used to offset UV.\n     * @param uvScale is an optional vector2 used to scale UV.\n     * @param forceUpdate defines whether or not to force an update of the generated buffers. This is useful to apply on a deserialized model for instance.\n     * @returns the Mesh.\n     */\n\n  }, {\n    key: \"applyDisplacementMapFromBuffer\",\n    value: function applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale) {\n      var forceUpdate = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {\n        Logger.Warn(\"Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing\");\n        return this;\n      }\n\n      var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);\n      var normals = this.getVerticesData(VertexBuffer.NormalKind);\n      var uvs = this.getVerticesData(VertexBuffer.UVKind);\n      var position = Vector3.Zero();\n      var normal = Vector3.Zero();\n      var uv = Vector2.Zero();\n      uvOffset = uvOffset || Vector2.Zero();\n      uvScale = uvScale || new Vector2(1, 1);\n\n      for (var index = 0; index < positions.length; index += 3) {\n        Vector3.FromArrayToRef(positions, index, position);\n        Vector3.FromArrayToRef(normals, index, normal);\n        Vector2.FromArrayToRef(uvs, index / 3 * 2, uv); // Compute height\n\n        var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;\n        var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;\n        var pos = (u + v * heightMapWidth) * 4;\n        var r = buffer[pos] / 255.0;\n        var g = buffer[pos + 1] / 255.0;\n        var b = buffer[pos + 2] / 255.0;\n        var gradient = r * 0.3 + g * 0.59 + b * 0.11;\n        normal.normalize();\n        normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);\n        position = position.add(normal);\n        position.toArray(positions, index);\n      }\n\n      VertexData.ComputeNormals(positions, this.getIndices(), normals);\n\n      if (forceUpdate) {\n        this.setVerticesData(VertexBuffer.PositionKind, positions);\n        this.setVerticesData(VertexBuffer.NormalKind, normals);\n        this.setVerticesData(VertexBuffer.UVKind, uvs);\n      } else {\n        this.updateVerticesData(VertexBuffer.PositionKind, positions);\n        this.updateVerticesData(VertexBuffer.NormalKind, normals);\n      }\n\n      return this;\n    }\n    /**\n     * Modify the mesh to get a flat shading rendering.\n     * This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.\n     * Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n\n  }, {\n    key: \"convertToFlatShadedMesh\",\n    value: function convertToFlatShadedMesh() {\n      var kinds = this.getVerticesDataKinds();\n      var vbs = {};\n      var data = {};\n      var newdata = {};\n      var updatableNormals = false;\n      var kindIndex;\n      var kind;\n\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        var vertexBuffer = this.getVertexBuffer(kind); // Check data consistency\n\n        var vertexData = vertexBuffer.getData();\n\n        if (vertexData instanceof Array || vertexData instanceof Float32Array) {\n          if (vertexData.length === 0) {\n            continue;\n          }\n        }\n\n        if (kind === VertexBuffer.NormalKind) {\n          updatableNormals = vertexBuffer.isUpdatable();\n          kinds.splice(kindIndex, 1);\n          kindIndex--;\n          continue;\n        }\n\n        vbs[kind] = vertexBuffer;\n        data[kind] = this.getVerticesData(kind);\n        newdata[kind] = [];\n      } // Save previous submeshes\n\n\n      var previousSubmeshes = this.subMeshes.slice(0);\n      var indices = this.getIndices();\n      var totalIndices = this.getTotalIndices(); // Generating unique vertices per face\n\n      var index;\n\n      for (index = 0; index < totalIndices; index++) {\n        var vertexIndex = indices[index];\n\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n          kind = kinds[kindIndex];\n\n          if (!vbs[kind]) {\n            continue;\n          }\n\n          var stride = vbs[kind].getStrideSize();\n\n          for (var offset = 0; offset < stride; offset++) {\n            newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n          }\n        }\n      } // Updating faces & normal\n\n\n      var normals = [];\n      var positions = newdata[VertexBuffer.PositionKind];\n      var useRightHandedSystem = this.getScene().useRightHandedSystem;\n      var flipNormalGeneration;\n\n      if (useRightHandedSystem) {\n        flipNormalGeneration = this.overrideMaterialSideOrientation === 1;\n      } else {\n        flipNormalGeneration = this.overrideMaterialSideOrientation === 0;\n      }\n\n      for (index = 0; index < totalIndices; index += 3) {\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n        indices[index + 2] = index + 2;\n        var p1 = Vector3.FromArray(positions, index * 3);\n        var p2 = Vector3.FromArray(positions, (index + 1) * 3);\n        var p3 = Vector3.FromArray(positions, (index + 2) * 3);\n        var p1p2 = p1.subtract(p2);\n        var p3p2 = p3.subtract(p2);\n        var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));\n\n        if (flipNormalGeneration) {\n          normal.scaleInPlace(-1);\n        } // Store same normals for every vertex\n\n\n        for (var localIndex = 0; localIndex < 3; localIndex++) {\n          normals.push(normal.x);\n          normals.push(normal.y);\n          normals.push(normal.z);\n        }\n      }\n\n      this.setIndices(indices);\n      this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals); // Updating vertex buffers\n\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n\n        if (!newdata[kind]) {\n          continue;\n        }\n\n        this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());\n      } // Updating submeshes\n\n\n      this.releaseSubMeshes();\n\n      for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n        var previousOne = previousSubmeshes[submeshIndex];\n        SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n      }\n\n      this.synchronizeInstances();\n      return this;\n    }\n    /**\n     * This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.\n     * In other words, more vertices, no more indices and a single bigger VBO.\n     * The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.\n     * @returns current mesh\n     */\n\n  }, {\n    key: \"convertToUnIndexedMesh\",\n    value: function convertToUnIndexedMesh() {\n      var kinds = this.getVerticesDataKinds();\n      var vbs = {};\n      var data = {};\n      var newdata = {};\n      var kindIndex;\n      var kind;\n\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        var vertexBuffer = this.getVertexBuffer(kind);\n        vbs[kind] = vertexBuffer;\n        data[kind] = vbs[kind].getData();\n        newdata[kind] = [];\n      } // Save previous submeshes\n\n\n      var previousSubmeshes = this.subMeshes.slice(0);\n      var indices = this.getIndices();\n      var totalIndices = this.getTotalIndices(); // Generating unique vertices per face\n\n      var index;\n\n      for (index = 0; index < totalIndices; index++) {\n        var vertexIndex = indices[index];\n\n        for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n          kind = kinds[kindIndex];\n          var stride = vbs[kind].getStrideSize();\n\n          for (var offset = 0; offset < stride; offset++) {\n            newdata[kind].push(data[kind][vertexIndex * stride + offset]);\n          }\n        }\n      } // Updating indices\n\n\n      for (index = 0; index < totalIndices; index += 3) {\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n        indices[index + 2] = index + 2;\n      }\n\n      this.setIndices(indices); // Updating vertex buffers\n\n      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {\n        kind = kinds[kindIndex];\n        this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable(), vbs[kind].getStrideSize());\n      } // Updating submeshes\n\n\n      this.releaseSubMeshes();\n\n      for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {\n        var previousOne = previousSubmeshes[submeshIndex];\n        SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);\n      }\n\n      this._unIndexed = true;\n      this.synchronizeInstances();\n      return this;\n    }\n    /**\n     * Inverses facet orientations.\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param flipNormals will also inverts the normals\n     * @returns current mesh\n     */\n\n  }, {\n    key: \"flipFaces\",\n    value: function flipFaces() {\n      var flipNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var i;\n\n      if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {\n        for (i = 0; i < vertex_data.normals.length; i++) {\n          vertex_data.normals[i] *= -1;\n        }\n      }\n\n      if (vertex_data.indices) {\n        var temp;\n\n        for (i = 0; i < vertex_data.indices.length; i += 3) {\n          // reassign indices\n          temp = vertex_data.indices[i + 1];\n          vertex_data.indices[i + 1] = vertex_data.indices[i + 2];\n          vertex_data.indices[i + 2] = temp;\n        }\n      }\n\n      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      return this;\n    }\n    /**\n     * Increase the number of facets and hence vertices in a mesh\n     * Vertex normals are interpolated from existing vertex normals\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     * @param numberPerEdge the number of new vertices to add to each edge of a facet, optional default 1\n     */\n\n  }, {\n    key: \"increaseVertices\",\n    value: function increaseVertices() {\n      var numberPerEdge = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;\n      var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;\n      var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;\n      var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;\n\n      if (!currentIndices || !positions) {\n        Logger.Warn(\"Couldn't increase number of vertices : VertexData must contain at least indices and positions\");\n      } else {\n        vertex_data.indices = currentIndices;\n        vertex_data.positions = positions;\n\n        if (uvs) {\n          vertex_data.uvs = uvs;\n        }\n\n        if (normals) {\n          vertex_data.normals = normals;\n        }\n\n        var segments = numberPerEdge + 1; //segments per current facet edge, become sides of new facets\n\n        var tempIndices = new Array();\n\n        for (var i = 0; i < segments + 1; i++) {\n          tempIndices[i] = new Array();\n        }\n\n        var a; //vertex index of one end of a side\n\n        var b; //vertex index of other end of the side\n\n        var deltaPosition = new Vector3(0, 0, 0);\n        var deltaNormal = new Vector3(0, 0, 0);\n        var deltaUV = new Vector2(0, 0);\n        var indices = new Array();\n        var vertexIndex = new Array();\n        var side = new Array();\n        var len;\n        var positionPtr = positions.length;\n        var uvPtr;\n\n        if (uvs) {\n          uvPtr = uvs.length;\n        }\n\n        var normalsPtr;\n\n        if (normals) {\n          normalsPtr = normals.length;\n        }\n\n        for (var _i = 0; _i < currentIndices.length; _i += 3) {\n          vertexIndex[0] = currentIndices[_i];\n          vertexIndex[1] = currentIndices[_i + 1];\n          vertexIndex[2] = currentIndices[_i + 2];\n\n          for (var j = 0; j < 3; j++) {\n            a = vertexIndex[j];\n            b = vertexIndex[(j + 1) % 3];\n\n            if (side[a] === undefined && side[b] === undefined) {\n              side[a] = new Array();\n              side[b] = new Array();\n            } else {\n              if (side[a] === undefined) {\n                side[a] = new Array();\n              }\n\n              if (side[b] === undefined) {\n                side[b] = new Array();\n              }\n            }\n\n            if (side[a][b] === undefined && side[b][a] === undefined) {\n              side[a][b] = [];\n              deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;\n              deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;\n              deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;\n\n              if (normals) {\n                deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;\n                deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;\n                deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;\n              }\n\n              if (uvs) {\n                deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;\n                deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;\n              }\n\n              side[a][b].push(a);\n\n              for (var k = 1; k < segments; k++) {\n                side[a][b].push(positions.length / 3);\n                positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;\n                positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;\n                positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;\n\n                if (normals) {\n                  normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;\n                  normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;\n                  normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;\n                }\n\n                if (uvs) {\n                  uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;\n                  uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;\n                }\n              }\n\n              side[a][b].push(b);\n              side[b][a] = new Array();\n              len = side[a][b].length;\n\n              for (var idx = 0; idx < len; idx++) {\n                side[b][a][idx] = side[a][b][len - 1 - idx];\n              }\n            }\n          } //Calculate positions, normals and uvs of new internal vertices\n\n\n          tempIndices[0][0] = currentIndices[_i];\n          tempIndices[1][0] = side[currentIndices[_i]][currentIndices[_i + 1]][1];\n          tempIndices[1][1] = side[currentIndices[_i]][currentIndices[_i + 2]][1];\n\n          for (var _k = 2; _k < segments; _k++) {\n            tempIndices[_k][0] = side[currentIndices[_i]][currentIndices[_i + 1]][_k];\n            tempIndices[_k][_k] = side[currentIndices[_i]][currentIndices[_i + 2]][_k];\n            deltaPosition.x = (positions[3 * tempIndices[_k][_k]] - positions[3 * tempIndices[_k][0]]) / _k;\n            deltaPosition.y = (positions[3 * tempIndices[_k][_k] + 1] - positions[3 * tempIndices[_k][0] + 1]) / _k;\n            deltaPosition.z = (positions[3 * tempIndices[_k][_k] + 2] - positions[3 * tempIndices[_k][0] + 2]) / _k;\n\n            if (normals) {\n              deltaNormal.x = (normals[3 * tempIndices[_k][_k]] - normals[3 * tempIndices[_k][0]]) / _k;\n              deltaNormal.y = (normals[3 * tempIndices[_k][_k] + 1] - normals[3 * tempIndices[_k][0] + 1]) / _k;\n              deltaNormal.z = (normals[3 * tempIndices[_k][_k] + 2] - normals[3 * tempIndices[_k][0] + 2]) / _k;\n            }\n\n            if (uvs) {\n              deltaUV.x = (uvs[2 * tempIndices[_k][_k]] - uvs[2 * tempIndices[_k][0]]) / _k;\n              deltaUV.y = (uvs[2 * tempIndices[_k][_k] + 1] - uvs[2 * tempIndices[_k][0] + 1]) / _k;\n            }\n\n            for (var _j = 1; _j < _k; _j++) {\n              tempIndices[_k][_j] = positions.length / 3;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0]] + _j * deltaPosition.x;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0] + 1] + _j * deltaPosition.y;\n              positions[positionPtr++] = positions[3 * tempIndices[_k][0] + 2] + _j * deltaPosition.z;\n\n              if (normals) {\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0]] + _j * deltaNormal.x;\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0] + 1] + _j * deltaNormal.y;\n                normals[normalsPtr++] = normals[3 * tempIndices[_k][0] + 2] + _j * deltaNormal.z;\n              }\n\n              if (uvs) {\n                uvs[uvPtr++] = uvs[2 * tempIndices[_k][0]] + _j * deltaUV.x;\n                uvs[uvPtr++] = uvs[2 * tempIndices[_k][0] + 1] + _j * deltaUV.y;\n              }\n            }\n          }\n\n          tempIndices[segments] = side[currentIndices[_i + 1]][currentIndices[_i + 2]]; // reform indices\n\n          indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);\n\n          for (var _k2 = 1; _k2 < segments; _k2++) {\n            var _j2 = void 0;\n\n            for (_j2 = 0; _j2 < _k2; _j2++) {\n              indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2], tempIndices[_k2 + 1][_j2 + 1]);\n              indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2 + 1], tempIndices[_k2][_j2 + 1]);\n            }\n\n            indices.push(tempIndices[_k2][_j2], tempIndices[_k2 + 1][_j2], tempIndices[_k2 + 1][_j2 + 1]);\n          }\n        }\n\n        vertex_data.indices = indices;\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      }\n    }\n    /**\n     * Force adjacent facets to share vertices and remove any facets that have all vertices in a line\n     * This will undo any application of covertToFlatShadedMesh\n     * Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.\n     */\n\n  }, {\n    key: \"forceSharedVertices\",\n    value: function forceSharedVertices() {\n      var vertex_data = VertexData.ExtractFromMesh(this);\n      var currentUVs = vertex_data.uvs;\n      var currentIndices = vertex_data.indices;\n      var currentPositions = vertex_data.positions;\n      var currentColors = vertex_data.colors;\n\n      if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {\n        Logger.Warn(\"VertexData contains empty entries\");\n      } else {\n        var positions = new Array();\n        var indices = new Array();\n        var uvs = new Array();\n        var colors = new Array();\n        var pstring = new Array(); //lists facet vertex positions (a,b,c) as string \"a|b|c\"\n\n        var indexPtr = 0; // pointer to next available index value\n\n        var uniquePositions = {}; // unique vertex positions\n\n        var ptr; // pointer to element in uniquePositions\n\n        var facet;\n\n        for (var i = 0; i < currentIndices.length; i += 3) {\n          facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]]; //facet vertex indices\n\n          pstring = new Array();\n\n          for (var j = 0; j < 3; j++) {\n            pstring[j] = \"\";\n\n            for (var k = 0; k < 3; k++) {\n              //small values make 0\n              if (Math.abs(currentPositions[3 * facet[j] + k]) < 0.00000001) {\n                currentPositions[3 * facet[j] + k] = 0;\n              }\n\n              pstring[j] += currentPositions[3 * facet[j] + k] + \"|\";\n            }\n          } //check facet vertices to see that none are repeated\n          // do not process any facet that has a repeated vertex, ie is a line\n\n\n          if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {\n            //for each facet position check if already listed in uniquePositions\n            // if not listed add to uniquePositions and set index pointer\n            // if listed use its index in uniquePositions and new index pointer\n            for (var _j3 = 0; _j3 < 3; _j3++) {\n              ptr = uniquePositions[pstring[_j3]];\n\n              if (ptr === undefined) {\n                uniquePositions[pstring[_j3]] = indexPtr;\n                ptr = indexPtr++; //not listed so add individual x, y, z coordinates to positions\n\n                for (var _k3 = 0; _k3 < 3; _k3++) {\n                  positions.push(currentPositions[3 * facet[_j3] + _k3]);\n                }\n\n                if (currentColors !== null && currentColors !== void 0) {\n                  for (var _k4 = 0; _k4 < 4; _k4++) {\n                    colors.push(currentColors[4 * facet[_j3] + _k4]);\n                  }\n                }\n\n                if (currentUVs !== null && currentUVs !== void 0) {\n                  for (var _k5 = 0; _k5 < 2; _k5++) {\n                    uvs.push(currentUVs[2 * facet[_j3] + _k5]);\n                  }\n                }\n              } // add new index pointer to indices array\n\n\n              indices.push(ptr);\n            }\n          }\n        }\n\n        var normals = new Array();\n        VertexData.ComputeNormals(positions, indices, normals); //create new vertex data object and update\n\n        vertex_data.positions = positions;\n        vertex_data.indices = indices;\n        vertex_data.normals = normals;\n\n        if (currentUVs !== null && currentUVs !== void 0) {\n          vertex_data.uvs = uvs;\n        }\n\n        if (currentColors !== null && currentColors !== void 0) {\n          vertex_data.colors = colors;\n        }\n\n        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));\n      }\n    } // Instances\n\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/naming-convention\n\n  }, {\n    key: \"createInstance\",\n    value:\n    /**\n     * Creates a new InstancedMesh object from the mesh model.\n     * @see https://doc.babylonjs.com/how_to/how_to_use_instances\n     * @param name defines the name of the new instance\n     * @returns a new InstancedMesh\n     */\n    function createInstance(name) {\n      return Mesh._instancedMeshFactory(name, this);\n    }\n    /**\n     * Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.\n     * After this call, all the mesh instances have the same submeshes than the current mesh.\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"synchronizeInstances\",\n    value: function synchronizeInstances() {\n      for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {\n        var instance = this.instances[instanceIndex];\n\n        instance._syncSubMeshes();\n      }\n\n      return this;\n    }\n    /**\n     * Optimization of the mesh's indices, in case a mesh has duplicated vertices.\n     * The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.\n     * This should be used together with the simplification to avoid disappearing triangles.\n     * @param successCallback an optional success callback to be called after the optimization finished.\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"optimizeIndices\",\n    value: function optimizeIndices(successCallback) {\n      var _this4 = this;\n\n      var indices = this.getIndices();\n      var positions = this.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!positions || !indices) {\n        return this;\n      }\n\n      var vectorPositions = new Array();\n\n      for (var pos = 0; pos < positions.length; pos = pos + 3) {\n        vectorPositions.push(Vector3.FromArray(positions, pos));\n      }\n\n      var dupes = new Array();\n      AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function (iteration) {\n        var realPos = vectorPositions.length - 1 - iteration;\n        var testedPosition = vectorPositions[realPos];\n\n        for (var j = 0; j < realPos; ++j) {\n          var againstPosition = vectorPositions[j];\n\n          if (testedPosition.equals(againstPosition)) {\n            dupes[realPos] = j;\n            break;\n          }\n        }\n      }, function () {\n        for (var i = 0; i < indices.length; ++i) {\n          indices[i] = dupes[indices[i]] || indices[i];\n        } //indices are now reordered\n\n\n        var originalSubMeshes = _this4.subMeshes.slice(0);\n\n        _this4.setIndices(indices);\n\n        _this4.subMeshes = originalSubMeshes;\n\n        if (successCallback) {\n          successCallback(_this4);\n        }\n      });\n      return this;\n    }\n    /**\n     * Serialize current mesh\n     * @param serializationObject defines the object which will receive the serialization data\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(serializationObject) {\n      serializationObject.name = this.name;\n      serializationObject.id = this.id;\n      serializationObject.uniqueId = this.uniqueId;\n      serializationObject.type = this.getClassName();\n\n      if (Tags && Tags.HasTags(this)) {\n        serializationObject.tags = Tags.GetTags(this);\n      }\n\n      serializationObject.position = this.position.asArray();\n\n      if (this.rotationQuaternion) {\n        serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();\n      } else if (this.rotation) {\n        serializationObject.rotation = this.rotation.asArray();\n      }\n\n      serializationObject.scaling = this.scaling.asArray();\n\n      if (this._postMultiplyPivotMatrix) {\n        serializationObject.pivotMatrix = this.getPivotMatrix().asArray();\n      } else {\n        serializationObject.localMatrix = this.getPivotMatrix().asArray();\n      }\n\n      serializationObject.isEnabled = this.isEnabled(false);\n      serializationObject.isVisible = this.isVisible;\n      serializationObject.infiniteDistance = this.infiniteDistance;\n      serializationObject.pickable = this.isPickable;\n      serializationObject.receiveShadows = this.receiveShadows;\n      serializationObject.billboardMode = this.billboardMode;\n      serializationObject.visibility = this.visibility;\n      serializationObject.checkCollisions = this.checkCollisions;\n      serializationObject.isBlocker = this.isBlocker;\n      serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation; // Parent\n\n      if (this.parent) {\n        this.parent._serializeAsParent(serializationObject);\n      } // Geometry\n\n\n      serializationObject.isUnIndexed = this.isUnIndexed;\n      var geometry = this._geometry;\n\n      if (geometry && this.subMeshes) {\n        serializationObject.geometryUniqueId = geometry.uniqueId;\n        serializationObject.geometryId = geometry.id; // SubMeshes\n\n        serializationObject.subMeshes = [];\n\n        for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {\n          var subMesh = this.subMeshes[subIndex];\n          serializationObject.subMeshes.push({\n            materialIndex: subMesh.materialIndex,\n            verticesStart: subMesh.verticesStart,\n            verticesCount: subMesh.verticesCount,\n            indexStart: subMesh.indexStart,\n            indexCount: subMesh.indexCount\n          });\n        }\n      } // Material\n\n\n      if (this.material) {\n        if (!this.material.doNotSerialize) {\n          serializationObject.materialUniqueId = this.material.uniqueId;\n          serializationObject.materialId = this.material.id; // back compat\n        }\n      } else {\n        this.material = null;\n        serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;\n        serializationObject.materialId = this._scene.defaultMaterial.id; // back compat\n      } // Morph targets\n\n\n      if (this.morphTargetManager) {\n        serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;\n      } // Skeleton\n\n\n      if (this.skeleton) {\n        serializationObject.skeletonId = this.skeleton.id;\n        serializationObject.numBoneInfluencers = this.numBoneInfluencers;\n      } // Physics\n      //TODO implement correct serialization for physics impostors.\n\n\n      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n        var impostor = this.getPhysicsImpostor();\n\n        if (impostor) {\n          serializationObject.physicsMass = impostor.getParam(\"mass\");\n          serializationObject.physicsFriction = impostor.getParam(\"friction\");\n          serializationObject.physicsRestitution = impostor.getParam(\"mass\");\n          serializationObject.physicsImpostor = impostor.type;\n        }\n      } // Metadata\n\n\n      if (this.metadata) {\n        serializationObject.metadata = this.metadata;\n      } // Instances\n\n\n      serializationObject.instances = [];\n\n      for (var index = 0; index < this.instances.length; index++) {\n        var instance = this.instances[index];\n\n        if (instance.doNotSerialize) {\n          continue;\n        }\n\n        var serializationInstance = {\n          name: instance.name,\n          id: instance.id,\n          isEnabled: instance.isEnabled(false),\n          isVisible: instance.isVisible,\n          isPickable: instance.isPickable,\n          checkCollisions: instance.checkCollisions,\n          position: instance.position.asArray(),\n          scaling: instance.scaling.asArray()\n        };\n\n        if (instance.parent) {\n          instance.parent._serializeAsParent(serializationInstance);\n        }\n\n        if (instance.rotationQuaternion) {\n          serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();\n        } else if (instance.rotation) {\n          serializationInstance.rotation = instance.rotation.asArray();\n        } // Physics\n        //TODO implement correct serialization for physics impostors.\n\n\n        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {\n          var _impostor = instance.getPhysicsImpostor();\n\n          if (_impostor) {\n            serializationInstance.physicsMass = _impostor.getParam(\"mass\");\n            serializationInstance.physicsFriction = _impostor.getParam(\"friction\");\n            serializationInstance.physicsRestitution = _impostor.getParam(\"mass\");\n            serializationInstance.physicsImpostor = _impostor.type;\n          }\n        } // Metadata\n\n\n        if (instance.metadata) {\n          serializationInstance.metadata = instance.metadata;\n        }\n\n        serializationObject.instances.push(serializationInstance); // Animations\n\n        SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);\n        serializationInstance.ranges = instance.serializeAnimationRanges();\n      } // Thin instances\n\n\n      if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {\n        serializationObject.thinInstances = {\n          instancesCount: this._thinInstanceDataStorage.instancesCount,\n          matrixData: Array.from(this._thinInstanceDataStorage.matrixData),\n          matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,\n          enablePicking: this.thinInstanceEnablePicking\n        };\n\n        if (this._userThinInstanceBuffersStorage) {\n          var userThinInstance = {\n            data: {},\n            sizes: {},\n            strides: {}\n          };\n\n          for (var kind in this._userThinInstanceBuffersStorage.data) {\n            userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);\n            userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];\n            userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];\n          }\n\n          serializationObject.thinInstances.userThinInstance = userThinInstance;\n        }\n      } // Animations\n\n\n      SerializationHelper.AppendSerializedAnimations(this, serializationObject);\n      serializationObject.ranges = this.serializeAnimationRanges(); // Layer mask\n\n      serializationObject.layerMask = this.layerMask; // Alpha\n\n      serializationObject.alphaIndex = this.alphaIndex;\n      serializationObject.hasVertexAlpha = this.hasVertexAlpha; // Overlay\n\n      serializationObject.overlayAlpha = this.overlayAlpha;\n      serializationObject.overlayColor = this.overlayColor.asArray();\n      serializationObject.renderOverlay = this.renderOverlay; // Fog\n\n      serializationObject.applyFog = this.applyFog; // Action Manager\n\n      if (this.actionManager) {\n        serializationObject.actions = this.actionManager.serialize(this.name);\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_syncGeometryWithMorphTargetManager\",\n    value: function _syncGeometryWithMorphTargetManager() {\n      if (!this.geometry) {\n        return;\n      }\n\n      this._markSubMeshesAsAttributesDirty();\n\n      var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;\n\n      if (morphTargetManager && morphTargetManager.vertexCount) {\n        if (morphTargetManager.vertexCount !== this.getTotalVertices()) {\n          Logger.Error(\"Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.\");\n          this.morphTargetManager = null;\n          return;\n        }\n\n        if (morphTargetManager.isUsingTextureForTargets) {\n          return;\n        }\n\n        for (var index = 0; index < morphTargetManager.numInfluencers; index++) {\n          var morphTarget = morphTargetManager.getActiveTarget(index);\n          var positions = morphTarget.getPositions();\n\n          if (!positions) {\n            Logger.Error(\"Invalid morph target. Target must have positions.\");\n            return;\n          }\n\n          this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);\n          var normals = morphTarget.getNormals();\n\n          if (normals) {\n            this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);\n          }\n\n          var tangents = morphTarget.getTangents();\n\n          if (tangents) {\n            this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);\n          }\n\n          var uvs = morphTarget.getUVs();\n\n          if (uvs) {\n            this.geometry.setVerticesData(VertexBuffer.UVKind + \"_\" + index, uvs, false, 2);\n          }\n        }\n      } else {\n        var _index2 = 0; // Positions\n\n        while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + _index2)) {\n          this.geometry.removeVerticesData(VertexBuffer.PositionKind + _index2);\n\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.NormalKind + _index2);\n          }\n\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.TangentKind + _index2);\n          }\n\n          if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + _index2)) {\n            this.geometry.removeVerticesData(VertexBuffer.UVKind + \"_\" + _index2);\n          }\n\n          _index2++;\n        }\n      }\n    }\n    /**\n     * Returns a new Mesh object parsed from the source provided.\n     * @param parsedMesh is the source\n     * @param scene defines the hosting scene\n     * @param rootUrl is the root URL to prefix the `delayLoadingFile` property with\n     * @returns a new Mesh\n     */\n\n  }, {\n    key: \"setPositionsForCPUSkinning\",\n    value: // Skeletons\n\n    /**\n     * Prepare internal position array for software CPU skinning\n     * @returns original positions used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh\n     */\n    function setPositionsForCPUSkinning() {\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      if (!internalDataInfo._sourcePositions) {\n        var source = this.getVerticesData(VertexBuffer.PositionKind);\n\n        if (!source) {\n          return internalDataInfo._sourcePositions;\n        }\n\n        internalDataInfo._sourcePositions = new Float32Array(source);\n\n        if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {\n          this.setVerticesData(VertexBuffer.PositionKind, source, true);\n        }\n      }\n\n      return internalDataInfo._sourcePositions;\n    }\n    /**\n     * Prepare internal normal array for software CPU skinning\n     * @returns original normals used for CPU skinning. Useful for integrating Morphing with skeletons in same mesh.\n     */\n\n  }, {\n    key: \"setNormalsForCPUSkinning\",\n    value: function setNormalsForCPUSkinning() {\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      if (!internalDataInfo._sourceNormals) {\n        var source = this.getVerticesData(VertexBuffer.NormalKind);\n\n        if (!source) {\n          return internalDataInfo._sourceNormals;\n        }\n\n        internalDataInfo._sourceNormals = new Float32Array(source);\n\n        if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {\n          this.setVerticesData(VertexBuffer.NormalKind, source, true);\n        }\n      }\n\n      return internalDataInfo._sourceNormals;\n    }\n    /**\n     * Updates the vertex buffer by applying transformation from the bones\n     * @param skeleton defines the skeleton to apply to current mesh\n     * @returns the current mesh\n     */\n\n  }, {\n    key: \"applySkeleton\",\n    value: function applySkeleton(skeleton) {\n      if (!this.geometry) {\n        return this;\n      }\n\n      if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {\n        return this;\n      }\n\n      this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();\n\n      if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {\n        return this;\n      }\n\n      if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {\n        return this;\n      }\n\n      if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {\n        return this;\n      }\n\n      var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);\n      var internalDataInfo = this._internalMeshDataInfo;\n\n      if (!internalDataInfo._sourcePositions) {\n        var submeshes = this.subMeshes.slice();\n        this.setPositionsForCPUSkinning();\n        this.subMeshes = submeshes;\n      }\n\n      if (hasNormals && !internalDataInfo._sourceNormals) {\n        this.setNormalsForCPUSkinning();\n      } // positionsData checks for not being Float32Array will only pass at most once\n\n\n      var positionsData = this.getVerticesData(VertexBuffer.PositionKind);\n\n      if (!positionsData) {\n        return this;\n      }\n\n      if (!(positionsData instanceof Float32Array)) {\n        positionsData = new Float32Array(positionsData);\n      } // normalsData checks for not being Float32Array will only pass at most once\n\n\n      var normalsData = this.getVerticesData(VertexBuffer.NormalKind);\n\n      if (hasNormals) {\n        if (!normalsData) {\n          return this;\n        }\n\n        if (!(normalsData instanceof Float32Array)) {\n          normalsData = new Float32Array(normalsData);\n        }\n      }\n\n      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);\n      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);\n\n      if (!matricesWeightsData || !matricesIndicesData) {\n        return this;\n      }\n\n      var needExtras = this.numBoneInfluencers > 4;\n      var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;\n      var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;\n      var skeletonMatrices = skeleton.getTransformMatrices(this);\n      var tempVector3 = Vector3.Zero();\n      var finalMatrix = new Matrix();\n      var tempMatrix = new Matrix();\n      var matWeightIdx = 0;\n      var inf;\n\n      for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {\n        var weight = void 0;\n\n        for (inf = 0; inf < 4; inf++) {\n          weight = matricesWeightsData[matWeightIdx + inf];\n\n          if (weight > 0) {\n            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);\n            finalMatrix.addToSelf(tempMatrix);\n          }\n        }\n\n        if (needExtras) {\n          for (inf = 0; inf < 4; inf++) {\n            weight = matricesWeightsExtraData[matWeightIdx + inf];\n\n            if (weight > 0) {\n              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);\n              finalMatrix.addToSelf(tempMatrix);\n            }\n          }\n        }\n\n        Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);\n        tempVector3.toArray(positionsData, index);\n\n        if (hasNormals) {\n          Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);\n          tempVector3.toArray(normalsData, index);\n        }\n\n        finalMatrix.reset();\n      }\n\n      this.updateVerticesData(VertexBuffer.PositionKind, positionsData);\n\n      if (hasNormals) {\n        this.updateVerticesData(VertexBuffer.NormalKind, normalsData);\n      }\n\n      return this;\n    } // Tools\n\n    /**\n     * Returns an object containing a min and max Vector3 which are the minimum and maximum vectors of each mesh bounding box from the passed array, in the world coordinates\n     * @param meshes defines the list of meshes to scan\n     * @returns an object `{min:` Vector3`, max:` Vector3`}`\n     */\n\n  }, {\n    key: \"addInstance\",\n    value:\n    /**\n     * @internal\n     */\n    function addInstance(instance) {\n      instance._indexInSourceMeshInstanceArray = this.instances.length;\n      this.instances.push(instance);\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"removeInstance\",\n    value: function removeInstance(instance) {\n      // Remove from mesh\n      var index = instance._indexInSourceMeshInstanceArray;\n\n      if (index != -1) {\n        if (index !== this.instances.length - 1) {\n          var last = this.instances[this.instances.length - 1];\n          this.instances[index] = last;\n          last._indexInSourceMeshInstanceArray = index;\n        }\n\n        instance._indexInSourceMeshInstanceArray = -1;\n        this.instances.pop();\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_shouldConvertRHS\",\n    value: function _shouldConvertRHS() {\n      return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;\n    }\n  }], [{\n    key: \"_GetDefaultSideOrientation\",\n    value: function _GetDefaultSideOrientation(orientation) {\n      return orientation || Mesh.FRONTSIDE; // works as Mesh.FRONTSIDE is 0\n    }\n  }, {\n    key: \"_instancedMeshFactory\",\n    value: function _instancedMeshFactory(name, mesh) {\n      throw _WarnImport(\"InstancedMesh\");\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"_PhysicsImpostorParser\",\n    value: function _PhysicsImpostorParser(scene, physicObject, jsonObject) {\n      throw _WarnImport(\"PhysicsImpostor\");\n    }\n  }, {\n    key: \"Parse\",\n    value: function Parse(parsedMesh, scene, rootUrl) {\n      var mesh;\n\n      if (parsedMesh.type && parsedMesh.type === \"LinesMesh\") {\n        mesh = Mesh._LinesMeshParser(parsedMesh, scene);\n      } else if (parsedMesh.type && parsedMesh.type === \"GroundMesh\") {\n        mesh = Mesh._GroundMeshParser(parsedMesh, scene);\n      } else if (parsedMesh.type && parsedMesh.type === \"GoldbergMesh\") {\n        mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);\n      } else {\n        mesh = new Mesh(parsedMesh.name, scene);\n      }\n\n      mesh.id = parsedMesh.id;\n      mesh._waitingParsedUniqueId = parsedMesh.uniqueId;\n\n      if (Tags) {\n        Tags.AddTagsTo(mesh, parsedMesh.tags);\n      }\n\n      mesh.position = Vector3.FromArray(parsedMesh.position);\n\n      if (parsedMesh.metadata !== undefined) {\n        mesh.metadata = parsedMesh.metadata;\n      }\n\n      if (parsedMesh.rotationQuaternion) {\n        mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);\n      } else if (parsedMesh.rotation) {\n        mesh.rotation = Vector3.FromArray(parsedMesh.rotation);\n      }\n\n      mesh.scaling = Vector3.FromArray(parsedMesh.scaling);\n\n      if (parsedMesh.localMatrix) {\n        mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));\n      } else if (parsedMesh.pivotMatrix) {\n        mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));\n      }\n\n      mesh.setEnabled(parsedMesh.isEnabled);\n      mesh.isVisible = parsedMesh.isVisible;\n      mesh.infiniteDistance = parsedMesh.infiniteDistance;\n      mesh.showBoundingBox = parsedMesh.showBoundingBox;\n      mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;\n\n      if (parsedMesh.applyFog !== undefined) {\n        mesh.applyFog = parsedMesh.applyFog;\n      }\n\n      if (parsedMesh.pickable !== undefined) {\n        mesh.isPickable = parsedMesh.pickable;\n      }\n\n      if (parsedMesh.alphaIndex !== undefined) {\n        mesh.alphaIndex = parsedMesh.alphaIndex;\n      }\n\n      mesh.receiveShadows = parsedMesh.receiveShadows;\n      mesh.billboardMode = parsedMesh.billboardMode;\n\n      if (parsedMesh.visibility !== undefined) {\n        mesh.visibility = parsedMesh.visibility;\n      }\n\n      mesh.checkCollisions = parsedMesh.checkCollisions;\n      mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;\n\n      if (parsedMesh.isBlocker !== undefined) {\n        mesh.isBlocker = parsedMesh.isBlocker;\n      }\n\n      mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading; // freezeWorldMatrix\n\n      if (parsedMesh.freezeWorldMatrix) {\n        mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;\n      } // Parent\n\n\n      if (parsedMesh.parentId !== undefined) {\n        mesh._waitingParentId = parsedMesh.parentId;\n      }\n\n      if (parsedMesh.parentInstanceIndex !== undefined) {\n        mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;\n      } // Actions\n\n\n      if (parsedMesh.actions !== undefined) {\n        mesh._waitingData.actions = parsedMesh.actions;\n      } // Overlay\n\n\n      if (parsedMesh.overlayAlpha !== undefined) {\n        mesh.overlayAlpha = parsedMesh.overlayAlpha;\n      }\n\n      if (parsedMesh.overlayColor !== undefined) {\n        mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);\n      }\n\n      if (parsedMesh.renderOverlay !== undefined) {\n        mesh.renderOverlay = parsedMesh.renderOverlay;\n      } // Geometry\n\n\n      mesh.isUnIndexed = !!parsedMesh.isUnIndexed;\n      mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;\n\n      if (parsedMesh.delayLoadingFile) {\n        mesh.delayLoadState = 4;\n        mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;\n        mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));\n\n        if (parsedMesh._binaryInfo) {\n          mesh._binaryInfo = parsedMesh._binaryInfo;\n        }\n\n        mesh._delayInfo = [];\n\n        if (parsedMesh.hasUVs) {\n          mesh._delayInfo.push(VertexBuffer.UVKind);\n        }\n\n        if (parsedMesh.hasUVs2) {\n          mesh._delayInfo.push(VertexBuffer.UV2Kind);\n        }\n\n        if (parsedMesh.hasUVs3) {\n          mesh._delayInfo.push(VertexBuffer.UV3Kind);\n        }\n\n        if (parsedMesh.hasUVs4) {\n          mesh._delayInfo.push(VertexBuffer.UV4Kind);\n        }\n\n        if (parsedMesh.hasUVs5) {\n          mesh._delayInfo.push(VertexBuffer.UV5Kind);\n        }\n\n        if (parsedMesh.hasUVs6) {\n          mesh._delayInfo.push(VertexBuffer.UV6Kind);\n        }\n\n        if (parsedMesh.hasColors) {\n          mesh._delayInfo.push(VertexBuffer.ColorKind);\n        }\n\n        if (parsedMesh.hasMatricesIndices) {\n          mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);\n        }\n\n        if (parsedMesh.hasMatricesWeights) {\n          mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);\n        }\n\n        mesh._delayLoadingFunction = Geometry._ImportGeometry;\n\n        if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {\n          mesh._checkDelayState();\n        }\n      } else {\n        Geometry._ImportGeometry(parsedMesh, mesh);\n      } // Material\n\n\n      if (parsedMesh.materialUniqueId) {\n        mesh._waitingMaterialId = parsedMesh.materialUniqueId;\n      } else if (parsedMesh.materialId) {\n        mesh._waitingMaterialId = parsedMesh.materialId;\n      } // Morph targets\n\n\n      if (parsedMesh.morphTargetManagerId > -1) {\n        mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);\n      } // Skeleton\n\n\n      if (parsedMesh.skeletonId !== undefined && parsedMesh.skeletonId !== null) {\n        mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);\n\n        if (parsedMesh.numBoneInfluencers) {\n          mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;\n        }\n      } // Animations\n\n\n      if (parsedMesh.animations) {\n        for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {\n          var parsedAnimation = parsedMesh.animations[animationIndex];\n          var internalClass = GetClass(\"BABYLON.Animation\");\n\n          if (internalClass) {\n            mesh.animations.push(internalClass.Parse(parsedAnimation));\n          }\n        }\n\n        Node.ParseAnimationRanges(mesh, parsedMesh, scene);\n      }\n\n      if (parsedMesh.autoAnimate) {\n        scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1.0);\n      } // Layer Mask\n\n\n      if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {\n        mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));\n      } else {\n        mesh.layerMask = 0x0fffffff;\n      } // Physics\n\n\n      if (parsedMesh.physicsImpostor) {\n        Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);\n      } // Levels\n\n\n      if (parsedMesh.lodMeshIds) {\n        mesh._waitingData.lods = {\n          ids: parsedMesh.lodMeshIds,\n          distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,\n          coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null\n        };\n      } // Instances\n\n\n      if (parsedMesh.instances) {\n        for (var index = 0; index < parsedMesh.instances.length; index++) {\n          var parsedInstance = parsedMesh.instances[index];\n          var instance = mesh.createInstance(parsedInstance.name);\n\n          if (parsedInstance.id) {\n            instance.id = parsedInstance.id;\n          }\n\n          if (Tags) {\n            if (parsedInstance.tags) {\n              Tags.AddTagsTo(instance, parsedInstance.tags);\n            } else {\n              Tags.AddTagsTo(instance, parsedMesh.tags);\n            }\n          }\n\n          instance.position = Vector3.FromArray(parsedInstance.position);\n\n          if (parsedInstance.metadata !== undefined) {\n            instance.metadata = parsedInstance.metadata;\n          }\n\n          if (parsedInstance.parentId !== undefined) {\n            instance._waitingParentId = parsedInstance.parentId;\n          }\n\n          if (parsedInstance.parentInstanceIndex !== undefined) {\n            instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;\n          }\n\n          if (parsedInstance.isEnabled !== undefined && parsedInstance.isEnabled !== null) {\n            instance.setEnabled(parsedInstance.isEnabled);\n          }\n\n          if (parsedInstance.isVisible !== undefined && parsedInstance.isVisible !== null) {\n            instance.isVisible = parsedInstance.isVisible;\n          }\n\n          if (parsedInstance.isPickable !== undefined && parsedInstance.isPickable !== null) {\n            instance.isPickable = parsedInstance.isPickable;\n          }\n\n          if (parsedInstance.rotationQuaternion) {\n            instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);\n          } else if (parsedInstance.rotation) {\n            instance.rotation = Vector3.FromArray(parsedInstance.rotation);\n          }\n\n          instance.scaling = Vector3.FromArray(parsedInstance.scaling);\n\n          if (parsedInstance.checkCollisions != undefined && parsedInstance.checkCollisions != null) {\n            instance.checkCollisions = parsedInstance.checkCollisions;\n          }\n\n          if (parsedInstance.pickable != undefined && parsedInstance.pickable != null) {\n            instance.isPickable = parsedInstance.pickable;\n          }\n\n          if (parsedInstance.showBoundingBox != undefined && parsedInstance.showBoundingBox != null) {\n            instance.showBoundingBox = parsedInstance.showBoundingBox;\n          }\n\n          if (parsedInstance.showSubMeshesBoundingBox != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n            instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;\n          }\n\n          if (parsedInstance.alphaIndex != undefined && parsedInstance.showSubMeshesBoundingBox != null) {\n            instance.alphaIndex = parsedInstance.alphaIndex;\n          } // Physics\n\n\n          if (parsedInstance.physicsImpostor) {\n            Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);\n          } // Animation\n\n\n          if (parsedInstance.animations) {\n            for (var _animationIndex = 0; _animationIndex < parsedInstance.animations.length; _animationIndex++) {\n              var _parsedAnimation = parsedInstance.animations[_animationIndex];\n\n              var _internalClass = GetClass(\"BABYLON.Animation\");\n\n              if (_internalClass) {\n                instance.animations.push(_internalClass.Parse(_parsedAnimation));\n              }\n            }\n\n            Node.ParseAnimationRanges(instance, parsedInstance, scene);\n\n            if (parsedInstance.autoAnimate) {\n              scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1.0);\n            }\n          }\n        }\n      } // Thin instances\n\n\n      if (parsedMesh.thinInstances) {\n        var thinInstances = parsedMesh.thinInstances;\n        mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;\n\n        if (thinInstances.matrixData) {\n          mesh.thinInstanceSetBuffer(\"matrix\", new Float32Array(thinInstances.matrixData), 16, false);\n          mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n          mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;\n        } else {\n          mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;\n        }\n\n        if (parsedMesh.thinInstances.userThinInstance) {\n          var userThinInstance = parsedMesh.thinInstances.userThinInstance;\n\n          for (var kind in userThinInstance.data) {\n            mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);\n            mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];\n          }\n        }\n      }\n\n      return mesh;\n    }\n  }, {\n    key: \"MinMax\",\n    value: function MinMax(meshes) {\n      var minVector = null;\n      var maxVector = null;\n      meshes.forEach(function (mesh) {\n        var boundingInfo = mesh.getBoundingInfo();\n        var boundingBox = boundingInfo.boundingBox;\n\n        if (!minVector || !maxVector) {\n          minVector = boundingBox.minimumWorld;\n          maxVector = boundingBox.maximumWorld;\n        } else {\n          minVector.minimizeInPlace(boundingBox.minimumWorld);\n          maxVector.maximizeInPlace(boundingBox.maximumWorld);\n        }\n      });\n\n      if (!minVector || !maxVector) {\n        return {\n          min: Vector3.Zero(),\n          max: Vector3.Zero()\n        };\n      }\n\n      return {\n        min: minVector,\n        max: maxVector\n      };\n    }\n    /**\n     * Returns the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array\n     * @param meshesOrMinMaxVector could be an array of meshes or a `{min:` Vector3`, max:` Vector3`}` object\n     * @returns a vector3\n     */\n\n  }, {\n    key: \"Center\",\n    value: function Center(meshesOrMinMaxVector) {\n      var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;\n      return Vector3.Center(minMaxVector.min, minMaxVector.max);\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n\n  }, {\n    key: \"MergeMeshes\",\n    value: function MergeMeshes(meshes) {\n      var disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n      var meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n      var subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n      var multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n      return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));\n    }\n    /**\n     * Merge the array of meshes into a single mesh for performance reasons.\n     * @param meshes array of meshes with the vertices to merge. Entries cannot be empty meshes.\n     * @param disposeSource when true (default), dispose of the vertices from the source meshes.\n     * @param allow32BitsIndices when the sum of the vertices > 64k, this must be set to true.\n     * @param meshSubclass (optional) can be set to a Mesh where the merged vertices will be inserted.\n     * @param subdivideWithSubMeshes when true (false default), subdivide mesh into subMeshes.\n     * @param multiMultiMaterials when true (false default), subdivide mesh into subMeshes with multiple materials, ignores subdivideWithSubMeshes.\n     * @returns a new mesh\n     */\n\n  }, {\n    key: \"MergeMeshesAsync\",\n    value: function MergeMeshesAsync(meshes) {\n      var disposeSource = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var allow32BitsIndices = arguments.length > 2 ? arguments[2] : undefined;\n      var meshSubclass = arguments.length > 3 ? arguments[3] : undefined;\n      var subdivideWithSubMeshes = arguments.length > 4 ? arguments[4] : undefined;\n      var multiMultiMaterials = arguments.length > 5 ? arguments[5] : undefined;\n      return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());\n    }\n  }, {\n    key: \"_MergeMeshesCoroutine\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function _MergeMeshesCoroutine(meshes) {\n      var disposeSource,\n          allow32BitsIndices,\n          meshSubclass,\n          subdivideWithSubMeshes,\n          multiMultiMaterials,\n          isAsync,\n          index,\n          totalVertices,\n          materialArray,\n          materialIndexArray,\n          indiceArray,\n          currentOverrideMaterialSideOrientation,\n          mesh,\n          material,\n          matIndex,\n          subIndex,\n          _subIndex,\n          _subIndex2,\n          source,\n          getVertexDataFromMesh,\n          _getVertexDataFromMes,\n          _getVertexDataFromMes2,\n          sourceVertexData,\n          sourceTransform,\n          meshVertexDatas,\n          i,\n          mergeCoroutine,\n          mergeCoroutineStep,\n          vertexData,\n          applyToCoroutine,\n          applyToCoroutineStep,\n          offset,\n          _iterator11,\n          _step12,\n          subMesh,\n          newMultiMaterial,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _MergeMeshesCoroutine$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              disposeSource = _args.length > 1 && _args[1] !== undefined ? _args[1] : true;\n              allow32BitsIndices = _args.length > 2 ? _args[2] : undefined;\n              meshSubclass = _args.length > 3 ? _args[3] : undefined;\n              subdivideWithSubMeshes = _args.length > 4 ? _args[4] : undefined;\n              multiMultiMaterials = _args.length > 5 ? _args[5] : undefined;\n              isAsync = _args.length > 6 ? _args[6] : undefined;\n              // Remove any null/undefined entries from the mesh array\n              meshes = meshes.filter(Boolean);\n\n              if (!(meshes.length === 0)) {\n                _context.next = 9;\n                break;\n              }\n\n              return _context.abrupt(\"return\", null);\n\n            case 9:\n              if (allow32BitsIndices) {\n                _context.next = 20;\n                break;\n              }\n\n              totalVertices = 0; // Counting vertices\n\n              index = 0;\n\n            case 12:\n              if (!(index < meshes.length)) {\n                _context.next = 20;\n                break;\n              }\n\n              totalVertices += meshes[index].getTotalVertices();\n\n              if (!(totalVertices >= 65536)) {\n                _context.next = 17;\n                break;\n              }\n\n              Logger.Warn(\"Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices\");\n              return _context.abrupt(\"return\", null);\n\n            case 17:\n              index++;\n              _context.next = 12;\n              break;\n\n            case 20:\n              if (multiMultiMaterials) {\n                subdivideWithSubMeshes = false;\n              }\n\n              materialArray = new Array();\n              materialIndexArray = new Array(); // Merge\n\n              indiceArray = new Array();\n              currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;\n              index = 0;\n\n            case 26:\n              if (!(index < meshes.length)) {\n                _context.next = 39;\n                break;\n              }\n\n              mesh = meshes[index];\n\n              if (!mesh.isAnInstance) {\n                _context.next = 31;\n                break;\n              }\n\n              Logger.Warn(\"Cannot merge instance meshes.\");\n              return _context.abrupt(\"return\", null);\n\n            case 31:\n              if (!(currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation)) {\n                _context.next = 34;\n                break;\n              }\n\n              Logger.Warn(\"Cannot merge meshes with different overrideMaterialSideOrientation values.\");\n              return _context.abrupt(\"return\", null);\n\n            case 34:\n              if (subdivideWithSubMeshes) {\n                indiceArray.push(mesh.getTotalIndices());\n              }\n\n              if (multiMultiMaterials) {\n                if (mesh.material) {\n                  material = mesh.material;\n\n                  if (material instanceof MultiMaterial) {\n                    for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {\n                      if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {\n                        materialArray.push(material.subMaterials[matIndex]);\n                      }\n                    }\n\n                    for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {\n                      materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));\n                      indiceArray.push(mesh.subMeshes[subIndex].indexCount);\n                    }\n                  } else {\n                    if (materialArray.indexOf(material) < 0) {\n                      materialArray.push(material);\n                    }\n\n                    for (_subIndex = 0; _subIndex < mesh.subMeshes.length; _subIndex++) {\n                      materialIndexArray.push(materialArray.indexOf(material));\n                      indiceArray.push(mesh.subMeshes[_subIndex].indexCount);\n                    }\n                  }\n                } else {\n                  for (_subIndex2 = 0; _subIndex2 < mesh.subMeshes.length; _subIndex2++) {\n                    materialIndexArray.push(0);\n                    indiceArray.push(mesh.subMeshes[_subIndex2].indexCount);\n                  }\n                }\n              }\n\n            case 36:\n              index++;\n              _context.next = 26;\n              break;\n\n            case 39:\n              source = meshes[0];\n\n              getVertexDataFromMesh = function getVertexDataFromMesh(mesh) {\n                var wm = mesh.computeWorldMatrix(true);\n                var vertexData = VertexData.ExtractFromMesh(mesh, false, false);\n                return [vertexData, wm];\n              };\n\n              _getVertexDataFromMes = getVertexDataFromMesh(source), _getVertexDataFromMes2 = _slicedToArray(_getVertexDataFromMes, 2), sourceVertexData = _getVertexDataFromMes2[0], sourceTransform = _getVertexDataFromMes2[1];\n\n              if (!isAsync) {\n                _context.next = 45;\n                break;\n              }\n\n              _context.next = 45;\n              return;\n\n            case 45:\n              meshVertexDatas = new Array(meshes.length - 1);\n              i = 1;\n\n            case 47:\n              if (!(i < meshes.length)) {\n                _context.next = 55;\n                break;\n              }\n\n              meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);\n\n              if (!isAsync) {\n                _context.next = 52;\n                break;\n              }\n\n              _context.next = 52;\n              return;\n\n            case 52:\n              i++;\n              _context.next = 47;\n              break;\n\n            case 55:\n              mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);\n              mergeCoroutineStep = mergeCoroutine.next();\n\n            case 57:\n              if (mergeCoroutineStep.done) {\n                _context.next = 64;\n                break;\n              }\n\n              if (!isAsync) {\n                _context.next = 61;\n                break;\n              }\n\n              _context.next = 61;\n              return;\n\n            case 61:\n              mergeCoroutineStep = mergeCoroutine.next();\n              _context.next = 57;\n              break;\n\n            case 64:\n              vertexData = mergeCoroutineStep.value;\n\n              if (!meshSubclass) {\n                meshSubclass = new Mesh(source.name + \"_merged\", source.getScene());\n              }\n\n              applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, undefined, isAsync);\n              applyToCoroutineStep = applyToCoroutine.next();\n\n            case 68:\n              if (applyToCoroutineStep.done) {\n                _context.next = 75;\n                break;\n              }\n\n              if (!isAsync) {\n                _context.next = 72;\n                break;\n              }\n\n              _context.next = 72;\n              return;\n\n            case 72:\n              applyToCoroutineStep = applyToCoroutine.next();\n              _context.next = 68;\n              break;\n\n            case 75:\n              // Setting properties\n              meshSubclass.checkCollisions = source.checkCollisions;\n              meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation; // Cleaning\n\n              if (disposeSource) {\n                for (index = 0; index < meshes.length; index++) {\n                  meshes[index].dispose();\n                }\n              } // Subdivide\n\n\n              if (subdivideWithSubMeshes || multiMultiMaterials) {\n                //-- removal of global submesh\n                meshSubclass.releaseSubMeshes();\n                index = 0;\n                offset = 0; //-- apply subdivision according to index table\n\n                while (index < indiceArray.length) {\n                  SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, undefined, false);\n                  offset += indiceArray[index];\n                  index++;\n                }\n\n                _iterator11 = _createForOfIteratorHelper(meshSubclass.subMeshes);\n\n                try {\n                  for (_iterator11.s(); !(_step12 = _iterator11.n()).done;) {\n                    subMesh = _step12.value;\n                    subMesh.refreshBoundingInfo();\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n\n                meshSubclass.computeWorldMatrix(true);\n              }\n\n              if (multiMultiMaterials) {\n                newMultiMaterial = new MultiMaterial(source.name + \"_merged\", source.getScene());\n                newMultiMaterial.subMaterials = materialArray;\n\n                for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {\n                  meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];\n                }\n\n                meshSubclass.material = newMultiMaterial;\n              } else {\n                meshSubclass.material = source.material;\n              }\n\n              return _context.abrupt(\"return\", meshSubclass);\n\n            case 81:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _MergeMeshesCoroutine);\n    })\n  }]);\n\n  return Mesh;\n}(AbstractMesh); // Consts\n\n/**\n * Mesh side orientation : usually the external or front surface\n */\n\nMesh.FRONTSIDE = VertexData.FRONTSIDE;\n/**\n * Mesh side orientation : usually the internal or back surface\n */\n\nMesh.BACKSIDE = VertexData.BACKSIDE;\n/**\n * Mesh side orientation : both internal and external or front and back surfaces\n */\n\nMesh.DOUBLESIDE = VertexData.DOUBLESIDE;\n/**\n * Mesh side orientation : by default, `FRONTSIDE`\n */\n\nMesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;\n/**\n * Mesh cap setting : no cap\n */\n\nMesh.NO_CAP = 0;\n/**\n * Mesh cap setting : one cap at the beginning of the mesh\n */\n\nMesh.CAP_START = 1;\n/**\n * Mesh cap setting : one cap at the end of the mesh\n */\n\nMesh.CAP_END = 2;\n/**\n * Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh\n */\n\nMesh.CAP_ALL = 3;\n/**\n * Mesh pattern setting : no flip or rotate\n */\n\nMesh.NO_FLIP = 0;\n/**\n * Mesh pattern setting : flip (reflect in y axis) alternate tiles on each row or column\n */\n\nMesh.FLIP_TILE = 1;\n/**\n * Mesh pattern setting : rotate (180degs) alternate tiles on each row or column\n */\n\nMesh.ROTATE_TILE = 2;\n/**\n * Mesh pattern setting : flip (reflect in y axis) all tiles on alternate rows\n */\n\nMesh.FLIP_ROW = 3;\n/**\n * Mesh pattern setting : rotate (180degs) all tiles on alternate rows\n */\n\nMesh.ROTATE_ROW = 4;\n/**\n * Mesh pattern setting : flip and rotate alternate tiles on each row or column\n */\n\nMesh.FLIP_N_ROTATE_TILE = 5;\n/**\n * Mesh pattern setting : rotate pattern and rotate\n */\n\nMesh.FLIP_N_ROTATE_ROW = 6;\n/**\n * Mesh tile positioning : part tiles same on left/right or top/bottom\n */\n\nMesh.CENTER = 0;\n/**\n * Mesh tile positioning : part tiles on left\n */\n\nMesh.LEFT = 1;\n/**\n * Mesh tile positioning : part tiles on right\n */\n\nMesh.RIGHT = 2;\n/**\n * Mesh tile positioning : part tiles on top\n */\n\nMesh.TOP = 3;\n/**\n * Mesh tile positioning : part tiles on bottom\n */\n\nMesh.BOTTOM = 4;\n/**\n * Indicates that the instanced meshes should be sorted from back to front before rendering if their material is transparent\n */\n\nMesh.INSTANCEDMESH_SORT_TRANSPARENT = false; // Statics\n\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nMesh._GroundMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"GroundMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nMesh._GoldbergMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"GoldbergMesh\");\n};\n/**\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nMesh._LinesMeshParser = function (parsedMesh, scene) {\n  throw _WarnImport(\"LinesMesh\");\n};\n\nRegisterClass(\"BABYLON.Mesh\", Mesh);\n/**\n * @internal\n */\n\nMesh.prototype.setMaterialByID = function (id) {\n  return this.setMaterialById(id);\n};\n\nMesh.CreateDisc = Mesh.CreateDisc || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateBox = Mesh.CreateBox || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateSphere = Mesh.CreateSphere || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateCylinder = Mesh.CreateCylinder || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateTorusKnot = Mesh.CreateTorusKnot || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateTorus = Mesh.CreateTorus || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreatePlane = Mesh.CreatePlane || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateGround = Mesh.CreateGround || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateTiledGround = Mesh.CreateTiledGround || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateTube = Mesh.CreateTube || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreatePolyhedron = Mesh.CreatePolyhedron || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateIcoSphere = Mesh.CreateIcoSphere || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateDecal = Mesh.CreateDecal || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.CreateCapsule = Mesh.CreateCapsule || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};\n\nMesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || function () {\n  throw new Error(\"Import MeshBuilder to populate this function\");\n};"],"names":["_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_isNativeReflectConstruct","result","Super","NewTarget","this","arguments","apply","_InstanceDataStorage","visibleInstances","batchCache","_InstancesBatch","batchCacheReplacementModeInFrozenMode","instancesBufferSize","mustReturn","renderSelf","hardwareInstancedRendering","_ThinInstanceDataStorage","instancesCount","matrixBuffer","previousMatrixBuffer","matrixBufferSize","matrixData","boundingVectors","worldMatrices","_InternalMeshDataInfo","_areNormalsFrozen","_source","meshMap","_preActivateId","_LODLevels","_useLODScreenCoverage","_effectiveMaterial","_forcedInstanceCount","Mesh","_AbstractMesh","_super","_this","scene","undefined","parent","source","doNotCloneChildren","clonePhysicsImpostor","_internalMeshDataInfo","delayLoadState","instances","_creationDataStorage","_geometry","_instanceDataStorage","_thinInstanceDataStorage","_shouldGenerateFlatShading","_originalBuilderSideOrientation","DEFAULTSIDE","overrideMaterialSideOrientation","ignoreCameraMaxZ","getScene","_onBeforeDraw","isInstance","world","effectiveMaterial","_uniformBuffer","transferToEffect","bindOnlyWorldMatrix","applyToMesh","useClonedMeshMap","uniqueId","_ranges","ranges","_name","hasOwnProperty","createAnimationRange","to","metadata","clone","setEnabled","isEnabled","setPivotMatrix","getPivotMatrix","id","material","directDescendants","getDescendants","index","child","morphTargetManager","getPhysicsEngine","physicsEngine","impostor","getImpostorForPhysicsObject","physicsImpostor","_index","particleSystems","system","emitter","skeleton","refreshBoundingInfo","computeWorldMatrix","getEngine","getCaps","instancedArrays","_onMeshReadyObserverAdded","observer","unregisterOnNextCall","isReady","onMeshReadyObservable","notifyObservers","_checkReadinessObserver","_scene","onBeforeRenderObservable","add","remove","onClonedObservable","key","get","set","_internalAbstractMeshDataInfo","_computeBonesUsingShaders","_sourcePositions","setVerticesData","_sourceNormals","_markSubMeshesAsAttributesDirty","_onBeforeRenderObservable","_onBeforeBindObservable","_onAfterRenderObservable","_onBetweenPassObservable","_onBeforeDrawObservable","callback","_onBeforeDrawObserver","onBeforeDrawObservable","_this$_thinInstanceDa","count","_unIndexed","instancesData","instancesPreviousData","manualUpdate","previousManualUpdate","newParent","options","onNewNodeCreated","instance","getTotalVertices","doNotInstantiate","createInstance","position","scaling","rotationQuaternion","rotation","_step","_iterator","getChildTransformNodes","getClassName","instantiateHierarchy","newSourcedMesh","fullDetails","ret","_waitingParentId","animations","ib","getIndices","vb","getVerticesData","_step2","_iterator2","_unBindEffect","sortingOrderFactor","sort","a","b","distanceOrScreenCoverage","mesh","_masterMesh","level","push","_sortLODLevels","distance","internalDataInfo","splice","camera","boundingSphere","bSphere","getBoundingInfo","distanceToCamera","centerWorld","subtract","globalPosition","compareValue","compareSign","screenArea","meshArea","radiusWorld","minZ","Math","PI","onLODLevelSelection","_checkDelayState","_preActivate","_updateSubMeshesBoundingInfo","worldMatrixFromCache","kind","copyWhenShared","forceCopy","_this$_userInstancedB","_this$_userInstancedB2","data","_userInstancedBuffersStorage","vertexBuffers","getFloatData","meshes","_this$_userInstancedB3","_this$_userInstancedB4","getVertexBuffer","_this$_userInstancedB5","isVerticesDataPresent","_delayInfo","indexOf","_this$_userInstancedB6","_this$_userInstancedB7","isUpdatable","isVertexBufferUpdatable","forEach","kinds","getVerticesDataKinds","getTotalIndices","completeCheck","forceInstanceSupport","subMeshes","engine","hasThinInstances","mat","defaultMaterial","_storeEffectOnSubMeshes","_step3","_iterator3","subMesh","getMaterial","isReadyForSubMesh","_step4","currentRenderPassId","_iterator4","lightSources","_generator$getShadowM","_generator$getShadowM2","_generator$getShadowM3","_generator$getShadowM4","light","generator","getShadowGenerator","getShadowMap","renderList","renderPassId","_step6","_iterator6","_subMesh$getMaterial$","_subMesh$getMaterial","_subMesh","needAlphaBlendingForMesh","_step5","_iterator5","lod","overridenInstanceCount","sceneRenderId","getRenderId","renderId","intermediateDefaultRenderId","defaultRenderId","selfDefaultRenderId","_renderId","previousRenderId","isFrozen","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","edgesShareWithInstances","edgesRenderer","_renderingGroup","_edgesRenderers","pushNoDuplicate","customInstances","getWorldMatrix","applySkeleton","applyMorph","hasBoundingInfo","isLocked","bias","geometry","boundingBias","_refreshBoundingInfo","_getPositionData","force","totalVertices","totalIndices","needToRecreate","_step7","_iterator7","submesh","indexStart","indexCount","verticesStart","verticesCount","releaseSubMeshes","subdivisionSize","offset","synchronizeInstances","updatable","stride","vertexData","removeVerticesData","buffer","disposeExistingBuffer","setVerticesBuffer","updateExtends","makeItUnique","makeGeometryUnique","updateVerticesData","positionFunction","computeNormals","positions","indices","normals","oldGeometry","copy","releaseForMesh","setIndices","gpuMemoryOnly","updateIndices","toLeftHanded","effect","fillMode","indexToBind","isUsingTextureForTargets","_bind","_getLinesIndexBuffer","getIndexBuffer","vertexArrayObjects","getVertexBuffers","drawArraysType","forcedInstanceCount","drawElementsType","_linesIndexCount","func","removeCallback","onAfterRenderObservable","subMeshId","isReplacementMode","previousBatch","isInIntermediateRendering","_isInIntermediateRendering","onlyForInstances","_onlyForInstancesIntermediate","_onlyForInstances","isVisible","currentRenderId","batch","_id","instanceStorage","currentInstancesBufferSize","instancesBuffer","instancesPreviousBuffer","bufferSize","Float32Array","needsPreviousWorldMatrices","needUpdateBuffer","masterMeshPreviousWorldMatrix","copyToArray","copyFrom","_subMesh$getMaterial2","INSTANCEDMESH_SORT_TRANSPARENT","activeCamera","getRenderingMesh","cameraPosition","instanceIndex","instanceMesh","_distanceToCamera","m1","m2","_instanceIndex","matrix","_previousWorldMatrix","dispose","strides","sizes","vertexArrayObject","createVertexBuffer","_invalidateInstanceVertexArrayObject","updateDirectly","_processInstancedBuffers","_activeIndices","addCount","_currentDrawContext","useInstancing","_draw","unbindInstanceAttributes","_this$_thinInstanceDa2","_this$_thinInstanceDa3","previousMatrixData","_thinInstanceCreateMatrixBuffer","renderingMesh","onBeforeDraw","_renderWithThinInstances","_renderWithInstances","instanceCount","visibleInstancesForSubMesh","visibleInstanceCount","_getInstancesRenderList","enableAlphaMode","effectiveMeshReplacement","_subMesh$effect","_material$getEffect","_drawWrapper$effect","_drawWrapper","_isActiveIntermediate","_isActive","_checkOcclusionQuery","_occlusionDataStorage","forceRenderingWhenOccluded","oldCameraMaxZ","oldCamera","maxZ","updateTransformMatrix","drawWrapper","instanceDataStorage","_wasPreviouslyReady","getEffect","setAlphaMode","alphaMode","_step8","_getDrawWrapper","_iterator8","_beforeRenderingMeshStage","action","sideOrientation","effectiveMesh","backFaceCulling","mainDeterminant","_getWorldMatrixDeterminant","reverse","_preBind","forceDepthWrite","setDepthWrite","forcePointsCloud","forceWireframe","bindForSubMesh","bind","separateCullingPass","setState","zOffset","cullBackFaces","stencil","zOffsetUnits","_processRendering","unbind","_step9","_iterator9","_afterRenderingMeshStage","performancePriority","_freeze","_normalizeSkinWeightsAndExtra","_normalizeSkinFourWeights","matricesWeights","numWeights","t","recip","matricesWeightsExtra","skinned","valid","report","numberNotSorted","missingWeights","maxUsedWeights","numberNotNormalized","numInfluences","usedWeightCounts","_a","lastWeight","usedWeights","d","tolerance","_b","abs","numBones","bones","matricesIndices","matricesIndicesExtra","numBadBoneIndices","_a2","_b2","load","_queueLoad","_this2","addPendingData","getBinaryData","delayLoadingFile","ArrayBuffer","_delayLoadingFunction","JSON","parse","_syncSubMeshes","removePendingData","offlineProvider","frustumPlanes","materials","multiMaterials","results","transform","submeshes","_resetPointsArrayCache","temp","toArray","normalize","determinant","flipFaces","bakeIndependenlyOfChildren","bakeTransformIntoVertices","resetLocalMatrix","_positions","_generatePointsArray","doNotRecurse","disposeMaterialAndTextures","clear","_step11","_iterator10","abstractMesh","_mesh","_disposeInstanceSpecificData","_disposeThinInstanceSpecificData","url","minHeight","maxHeight","onSuccess","uvOffset","uvScale","_this3","forceUpdate","onload","img","heightMapWidth","width","heightMapHeight","height","context","createCanvas","getContext","drawImage","getImageData","applyDisplacementMapFromBuffer","uvs","normal","uv","u","x","v","y","pos","r","g","gradient","scaleInPlace","kindIndex","vbs","newdata","updatableNormals","vertexBuffer","getData","previousSubmeshes","vertexIndex","getStrideSize","flipNormalGeneration","useRightHandedSystem","p1","p2","p3","p1p2","p3p2","localIndex","z","submeshIndex","previousOne","materialIndex","flipNormals","vertex_data","numberPerEdge","currentIndices","segments","tempIndices","uvPtr","normalsPtr","deltaPosition","deltaNormal","deltaUV","side","positionPtr","_i","j","k","idx","_k","_j","_k2","_j2","currentUVs","currentPositions","currentColors","colors","ptr","facet","pstring","indexPtr","uniquePositions","_j3","_k3","_k4","_k5","_instancedMeshFactory","successCallback","_this4","vectorPositions","dupes","iteration","realPos","testedPosition","againstPosition","equals","originalSubMeshes","serializationObject","type","tags","asArray","_postMultiplyPivotMatrix","pivotMatrix","localMatrix","infiniteDistance","pickable","isPickable","receiveShadows","billboardMode","visibility","checkCollisions","isBlocker","_serializeAsParent","isUnIndexed","geometryUniqueId","geometryId","subIndex","doNotSerialize","materialUniqueId","materialId","morphTargetManagerId","skeletonId","numBoneInfluencers","_getComponent","getPhysicsImpostor","physicsMass","getParam","physicsFriction","physicsRestitution","serializationInstance","_impostor","serializeAnimationRanges","thinInstances","enablePicking","thinInstanceEnablePicking","_userThinInstanceBuffersStorage","userThinInstance","layerMask","alphaIndex","hasVertexAlpha","overlayAlpha","overlayColor","renderOverlay","applyFog","actionManager","actions","serialize","_morphTargetManager","vertexCount","numInfluencers","morphTarget","getActiveTarget","getPositions","getNormals","tangents","getTangents","getUVs","_index2","_softwareSkinningFrameId","getFrameId","hasNormals","setPositionsForCPUSkinning","setNormalsForCPUSkinning","positionsData","normalsData","matricesIndicesData","matricesWeightsData","inf","needExtras","matricesIndicesExtraData","matricesWeightsExtraData","skeletonMatrices","getTransformMatrices","tempVector3","finalMatrix","tempMatrix","matWeightIdx","weight","floor","addToSelf","reset","_indexInSourceMeshInstanceArray","last","pop","orientation","FRONTSIDE","physicObject","jsonObject","parsedMesh","rootUrl","_LinesMeshParser","_GroundMeshParser","_GoldbergMeshParser","_waitingParsedUniqueId","setPreTransformMatrix","showBoundingBox","showSubMeshesBoundingBox","useFlatShading","freezeWorldMatrix","_waitingData","parentId","parentInstanceIndex","_waitingParentInstanceIndex","buildBoundingInfo","boundingBoxMinimum","boundingBoxMaximum","_binaryInfo","hasUVs","hasUVs2","hasUVs3","hasUVs4","hasUVs5","hasUVs6","hasColors","hasMatricesIndices","hasMatricesWeights","_waitingMaterialId","getMorphTargetManagerById","getLastSkeletonById","animationIndex","parsedAnimation","internalClass","Parse","N","autoAnimate","beginAnimation","autoAnimateFrom","autoAnimateTo","autoAnimateLoop","autoAnimateSpeed","isNaN","parseInt","_PhysicsImpostorParser","lodMeshIds","lods","ids","distances","lodDistances","coverages","lodCoverages","parsedInstance","_animationIndex","_parsedAnimation","_internalClass","thinInstanceSetBuffer","minVector","maxVector","boundingBox","minimizeInPlace","minimumWorld","maximizeInPlace","maximumWorld","min","max","meshesOrMinMaxVector","minMaxVector","MinMax","disposeSource","allow32BitsIndices","meshSubclass","subdivideWithSubMeshes","multiMultiMaterials","_MergeMeshesCoroutine","isAsync","materialArray","materialIndexArray","indiceArray","currentOverrideMaterialSideOrientation","matIndex","_subIndex","_subIndex2","getVertexDataFromMesh","_getVertexDataFromMes","_getVertexDataFromMes2","sourceVertexData","sourceTransform","meshVertexDatas","mergeCoroutine","mergeCoroutineStep","applyToCoroutine","applyToCoroutineStep","_iterator11","_step12","newMultiMaterial","_args","_context","prev","filter","abrupt","isAnInstance","subMaterials","wm","_mergeCoroutine","_applyToCoroutine","stop","BACKSIDE","DOUBLESIDE","NO_CAP","CAP_START","CAP_END","CAP_ALL","NO_FLIP","FLIP_TILE","ROTATE_TILE","FLIP_ROW","ROTATE_ROW","FLIP_N_ROTATE_TILE","FLIP_N_ROTATE_ROW","CENTER","LEFT","RIGHT","TOP","BOTTOM","setMaterialByID","setMaterialById","CreateDisc","Error","CreateBox","CreateSphere","CreateCylinder","CreateTorusKnot","CreateTorus","CreatePlane","CreateGround","CreateTiledGround","CreateGroundFromHeightMap","CreateTube","CreatePolyhedron","CreateIcoSphere","CreateDecal","CreateCapsule","ExtendToGoldberg"],"sourceRoot":""}