{"version":3,"file":"c2b82a6e-7d1576be617d493bb759.js","mappings":"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","sources":["webpack://bonsai-web/./node_modules/@babylonjs/core/scene.js"],"sourcesContent":["import _defineProperty from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _classCallCheck from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/Users/sara/Proyectos/bonsai/bonsai-web/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { Tools } from \"./Misc/tools.js\";\nimport { PrecisionDate } from \"./Misc/precisionDate.js\";\nimport { Observable } from \"./Misc/observable.js\";\nimport { SmartArrayNoDuplicate, SmartArray } from \"./Misc/smartArray.js\";\nimport { StringDictionary } from \"./Misc/stringDictionary.js\";\nimport { Tags } from \"./Misc/tags.js\";\nimport { Vector3, Matrix, TmpVectors } from \"./Maths/math.vector.js\";\nimport { AbstractScene } from \"./abstractScene.js\";\nimport { ImageProcessingConfiguration } from \"./Materials/imageProcessingConfiguration.js\";\nimport { UniformBuffer } from \"./Materials/uniformBuffer.js\";\nimport { PickingInfo } from \"./Collisions/pickingInfo.js\";\nimport { ActionEvent } from \"./Actions/actionEvent.js\";\nimport { PostProcessManager } from \"./PostProcesses/postProcessManager.js\";\nimport { RenderingManager } from \"./Rendering/renderingManager.js\";\nimport { Stage } from \"./sceneComponent.js\";\nimport { IsWindowObjectExist } from \"./Misc/domManagement.js\";\nimport { EngineStore } from \"./Engines/engineStore.js\";\nimport { _WarnImport } from \"./Misc/devTools.js\";\nimport { InputManager } from \"./Inputs/scene.inputManager.js\";\nimport { PerfCounter } from \"./Misc/perfCounter.js\";\nimport { Color4, Color3 } from \"./Maths/math.color.js\";\nimport { Frustum } from \"./Maths/math.frustum.js\";\nimport { UniqueIdGenerator } from \"./Misc/uniqueIdGenerator.js\";\nimport { ReadFile, RequestFile, LoadFile } from \"./Misc/fileTools.js\";\nimport { LightConstants } from \"./Lights/lightConstants.js\";\nimport { ComputePressureObserverWrapper } from \"./Misc/computePressure.js\";\nimport { _ObserveArray } from \"./Misc/arrayTools.js\";\n/**\n * Define how the scene should favor performance over ease of use\n */\n\nexport var ScenePerformancePriority;\n\n(function (ScenePerformancePriority) {\n  /** Default mode. No change. Performance will be treated as less important than backward compatibility */\n  ScenePerformancePriority[ScenePerformancePriority[\"BackwardCompatible\"] = 0] = \"BackwardCompatible\";\n  /** Some performance options will be turned on trying to strike a balance between perf and ease of use */\n\n  ScenePerformancePriority[ScenePerformancePriority[\"Intermediate\"] = 1] = \"Intermediate\";\n  /** Performance will be top priority */\n\n  ScenePerformancePriority[ScenePerformancePriority[\"Aggressive\"] = 2] = \"Aggressive\";\n})(ScenePerformancePriority || (ScenePerformancePriority = {}));\n/**\n * Represents a scene to be rendered by the engine.\n * @see https://doc.babylonjs.com/features/scene\n */\n\n\nexport var Scene = /*#__PURE__*/function (_AbstractScene) {\n  _inherits(Scene, _AbstractScene);\n\n  var _super = _createSuper(Scene);\n\n  /**\n   * Creates a new Scene\n   * @param engine defines the engine to use to render this scene\n   * @param options defines the scene options\n   */\n  function Scene(engine, options) {\n    var _this;\n\n    _classCallCheck(this, Scene);\n\n    _this = _super.call(this); // Members\n\n    /** @internal */\n\n    _this._inputManager = new InputManager(_assertThisInitialized(_this));\n    /** Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position */\n\n    _this.cameraToUseForPointers = null;\n    /** @internal */\n\n    _this._isScene = true;\n    /** @internal */\n\n    _this._blockEntityCollection = false;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame\n     */\n\n    _this.autoClear = true;\n    /**\n     * Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame\n     */\n\n    _this.autoClearDepthAndStencil = true;\n    /**\n     * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))\n     */\n\n    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1.0);\n    /**\n     * Defines the color used to simulate the ambient color (Default is (0, 0, 0))\n     */\n\n    _this.ambientColor = new Color3(0, 0, 0);\n    /**\n     * Intensity of the environment in all pbr material.\n     * This dims or reinforces the IBL lighting overall (reflection and diffuse).\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n\n    _this.environmentIntensity = 1;\n    _this._performancePriority = ScenePerformancePriority.BackwardCompatible;\n    _this._forceWireframe = false;\n    _this._skipFrustumClipping = false;\n    _this._forcePointsCloud = false;\n    /**\n     * Gets or sets a boolean indicating if animations are enabled\n     */\n\n    _this.animationsEnabled = true;\n    _this._animationPropertiesOverride = null;\n    /**\n     * Gets or sets a boolean indicating if a constant deltatime has to be used\n     * This is mostly useful for testing purposes when you do not want the animations to scale with the framerate\n     */\n\n    _this.useConstantAnimationDeltaTime = false;\n    /**\n     * Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated\n     * Please note that it requires to run a ray cast through the scene on every frame\n     */\n\n    _this.constantlyUpdateMeshUnderPointer = false;\n    /**\n     * Defines the HTML cursor to use when hovering over interactive elements\n     */\n\n    _this.hoverCursor = \"pointer\";\n    /**\n     * Defines the HTML default cursor to use (empty by default)\n     */\n\n    _this.defaultCursor = \"\";\n    /**\n     * Defines whether cursors are handled by the scene.\n     */\n\n    _this.doNotHandleCursors = false;\n    /**\n     * This is used to call preventDefault() on pointer down\n     * in order to block unwanted artifacts like system double clicks\n     */\n\n    _this.preventDefaultOnPointerDown = true;\n    /**\n     * This is used to call preventDefault() on pointer up\n     * in order to block unwanted artifacts like system double clicks\n     */\n\n    _this.preventDefaultOnPointerUp = true; // Metadata\n\n    /**\n     * Gets or sets user defined metadata\n     */\n\n    _this.metadata = null;\n    /**\n     * For internal use only. Please do not use.\n     */\n\n    _this.reservedDataStore = null;\n    /**\n     * Use this array to add regular expressions used to disable offline support for specific urls\n     */\n\n    _this.disableOfflineSupportExceptionRules = new Array();\n    /**\n     * An event triggered when the scene is disposed.\n     */\n\n    _this.onDisposeObservable = new Observable();\n    _this._onDisposeObserver = null;\n    /**\n     * An event triggered before rendering the scene (right after animations and physics)\n     */\n\n    _this.onBeforeRenderObservable = new Observable();\n    _this._onBeforeRenderObserver = null;\n    /**\n     * An event triggered after rendering the scene\n     */\n\n    _this.onAfterRenderObservable = new Observable();\n    /**\n     * An event triggered after rendering the scene for an active camera (When scene.render is called this will be called after each camera)\n     * This is triggered for each \"sub\" camera in a Camera Rig unlike onAfterCameraRenderObservable\n     */\n\n    _this.onAfterRenderCameraObservable = new Observable();\n    _this._onAfterRenderObserver = null;\n    /**\n     * An event triggered before animating the scene\n     */\n\n    _this.onBeforeAnimationsObservable = new Observable();\n    /**\n     * An event triggered after animations processing\n     */\n\n    _this.onAfterAnimationsObservable = new Observable();\n    /**\n     * An event triggered before draw calls are ready to be sent\n     */\n\n    _this.onBeforeDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered after draw calls have been sent\n     */\n\n    _this.onAfterDrawPhaseObservable = new Observable();\n    /**\n     * An event triggered when the scene is ready\n     */\n\n    _this.onReadyObservable = new Observable();\n    /**\n     * An event triggered before rendering a camera\n     */\n\n    _this.onBeforeCameraRenderObservable = new Observable();\n    _this._onBeforeCameraRenderObserver = null;\n    /**\n     * An event triggered after rendering a camera\n     * This is triggered for the full rig Camera only unlike onAfterRenderCameraObservable\n     */\n\n    _this.onAfterCameraRenderObservable = new Observable();\n    _this._onAfterCameraRenderObserver = null;\n    /**\n     * An event triggered when active meshes evaluation is about to start\n     */\n\n    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when active meshes evaluation is done\n     */\n\n    _this.onAfterActiveMeshesEvaluationObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is about to start\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n\n    _this.onBeforeParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when particles rendering is done\n     * Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)\n     */\n\n    _this.onAfterParticlesRenderingObservable = new Observable();\n    /**\n     * An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed\n     */\n\n    _this.onDataLoadedObservable = new Observable();\n    /**\n     * An event triggered when a camera is created\n     */\n\n    _this.onNewCameraAddedObservable = new Observable();\n    /**\n     * An event triggered when a camera is removed\n     */\n\n    _this.onCameraRemovedObservable = new Observable();\n    /**\n     * An event triggered when a light is created\n     */\n\n    _this.onNewLightAddedObservable = new Observable();\n    /**\n     * An event triggered when a light is removed\n     */\n\n    _this.onLightRemovedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is created\n     */\n\n    _this.onNewGeometryAddedObservable = new Observable();\n    /**\n     * An event triggered when a geometry is removed\n     */\n\n    _this.onGeometryRemovedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is created\n     */\n\n    _this.onNewTransformNodeAddedObservable = new Observable();\n    /**\n     * An event triggered when a transform node is removed\n     */\n\n    _this.onTransformNodeRemovedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is created\n     */\n\n    _this.onNewMeshAddedObservable = new Observable();\n    /**\n     * An event triggered when a mesh is removed\n     */\n\n    _this.onMeshRemovedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is created\n     */\n\n    _this.onNewSkeletonAddedObservable = new Observable();\n    /**\n     * An event triggered when a skeleton is removed\n     */\n\n    _this.onSkeletonRemovedObservable = new Observable();\n    /**\n     * An event triggered when a material is created\n     */\n\n    _this.onNewMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is created\n     */\n\n    _this.onNewMultiMaterialAddedObservable = new Observable();\n    /**\n     * An event triggered when a material is removed\n     */\n\n    _this.onMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a multi material is removed\n     */\n\n    _this.onMultiMaterialRemovedObservable = new Observable();\n    /**\n     * An event triggered when a texture is created\n     */\n\n    _this.onNewTextureAddedObservable = new Observable();\n    /**\n     * An event triggered when a texture is removed\n     */\n\n    _this.onTextureRemovedObservable = new Observable();\n    /**\n     * An event triggered when render targets are about to be rendered\n     * Can happen multiple times per frame.\n     */\n\n    _this.onBeforeRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered when render targets were rendered.\n     * Can happen multiple times per frame.\n     */\n\n    _this.onAfterRenderTargetsRenderObservable = new Observable();\n    /**\n     * An event triggered before calculating deterministic simulation step\n     */\n\n    _this.onBeforeStepObservable = new Observable();\n    /**\n     * An event triggered after calculating deterministic simulation step\n     */\n\n    _this.onAfterStepObservable = new Observable();\n    /**\n     * An event triggered when the activeCamera property is updated\n     */\n\n    _this.onActiveCameraChanged = new Observable();\n    /**\n     * An event triggered when the activeCameras property is updated\n     */\n\n    _this.onActiveCamerasChanged = new Observable();\n    /**\n     * This Observable will be triggered before rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n\n    _this.onBeforeRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will be triggered after rendering each renderingGroup of each rendered camera.\n     * The RenderingGroupInfo class contains all the information about the context in which the observable is called\n     * If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)\n     */\n\n    _this.onAfterRenderingGroupObservable = new Observable();\n    /**\n     * This Observable will when a mesh has been imported into the scene.\n     */\n\n    _this.onMeshImportedObservable = new Observable();\n    /**\n     * This Observable will when an animation file has been imported into the scene.\n     */\n\n    _this.onAnimationFileImportedObservable = new Observable(); // Animations\n\n    /** @internal */\n\n    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.\n     */\n\n    _this.skipPointerMovePicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.\n     */\n\n    _this.skipPointerDownPicking = false;\n    /**\n     * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.\n     */\n\n    _this.skipPointerUpPicking = false;\n    /**\n     * This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).\n     * You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true\n     */\n\n    _this.onPrePointerObservable = new Observable();\n    /**\n     * Observable event triggered each time an input event is received from the rendering canvas\n     */\n\n    _this.onPointerObservable = new Observable(); // Keyboard\n\n    /**\n     * This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()\n     * You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true\n     */\n\n    _this.onPreKeyboardObservable = new Observable();\n    /**\n     * Observable event triggered each time an keyboard event is received from the hosting window\n     */\n\n    _this.onKeyboardObservable = new Observable(); // Coordinates system\n\n    _this._useRightHandedSystem = false; // Deterministic lockstep\n\n    _this._timeAccumulator = 0;\n    _this._currentStepId = 0;\n    _this._currentInternalStep = 0; // Fog\n\n    _this._fogEnabled = true;\n    _this._fogMode = Scene.FOGMODE_NONE;\n    /**\n     * Gets or sets the fog color to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is Color3(0.2, 0.2, 0.3))\n     */\n\n    _this.fogColor = new Color3(0.2, 0.2, 0.3);\n    /**\n     * Gets or sets the fog density to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0.1)\n     */\n\n    _this.fogDensity = 0.1;\n    /**\n     * Gets or sets the fog start distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 0)\n     */\n\n    _this.fogStart = 0;\n    /**\n     * Gets or sets the fog end distance to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is 1000)\n     */\n\n    _this.fogEnd = 1000.0;\n    /**\n     * Flag indicating if we need to store previous matrices when rendering\n     */\n\n    _this.needsPreviousWorldMatrices = false; // Lights\n\n    _this._shadowsEnabled = true;\n    _this._lightsEnabled = true;\n    _this._unObserveActiveCameras = null; // Textures\n\n    _this._texturesEnabled = true; // Physics\n\n    /**\n     * Gets or sets a boolean indicating if physic engines are enabled on this scene\n     */\n\n    _this.physicsEnabled = true; // Particles\n\n    /**\n     * Gets or sets a boolean indicating if particles are enabled on this scene\n     */\n\n    _this.particlesEnabled = true; // Sprites\n\n    /**\n     * Gets or sets a boolean indicating if sprites are enabled on this scene\n     */\n\n    _this.spritesEnabled = true; // Skeletons\n\n    _this._skeletonsEnabled = true; // Lens flares\n\n    /**\n     * Gets or sets a boolean indicating if lens flares are enabled on this scene\n     */\n\n    _this.lensFlaresEnabled = true; // Collisions\n\n    /**\n     * Gets or sets a boolean indicating if collisions are enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.collisionsEnabled = true;\n    /**\n     * Defines the gravity applied to this scene (used only for collisions)\n     * @see https://doc.babylonjs.com/babylon101/cameras,_mesh_collisions_and_gravity\n     */\n\n    _this.gravity = new Vector3(0, -9.807, 0); // Postprocesses\n\n    /**\n     * Gets or sets a boolean indicating if postprocesses are enabled on this scene\n     */\n\n    _this.postProcessesEnabled = true; // Customs render targets\n\n    /**\n     * Gets or sets a boolean indicating if render targets are enabled on this scene\n     */\n\n    _this.renderTargetsEnabled = true;\n    /**\n     * Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes\n     * We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com\n     */\n\n    _this.dumpNextRenderTargets = false;\n    /**\n     * The list of user defined render targets added to the scene\n     */\n\n    _this.customRenderTargets = new Array();\n    /**\n     * Gets the list of meshes imported to the scene through SceneLoader\n     */\n\n    _this.importedMeshesFiles = new Array(); // Probes\n\n    /**\n     * Gets or sets a boolean indicating if probes are enabled on this scene\n     */\n\n    _this.probesEnabled = true;\n    _this._meshesForIntersections = new SmartArrayNoDuplicate(256); // Procedural textures\n\n    /**\n     * Gets or sets a boolean indicating if procedural textures are enabled on this scene\n     */\n\n    _this.proceduralTexturesEnabled = true; // Performance counters\n\n    _this._totalVertices = new PerfCounter();\n    /** @internal */\n\n    _this._activeIndices = new PerfCounter();\n    /** @internal */\n\n    _this._activeParticles = new PerfCounter();\n    /** @internal */\n\n    _this._activeBones = new PerfCounter();\n    /** @internal */\n\n    _this._animationTime = 0;\n    /**\n     * Gets or sets a general scale for animation speed\n     * @see https://www.babylonjs-playground.com/#IBU2W7#3\n     */\n\n    _this.animationTimeScale = 1;\n    _this._renderId = 0;\n    _this._frameId = 0;\n    _this._executeWhenReadyTimeoutId = null;\n    _this._intermediateRendering = false;\n    _this._defaultFrameBufferCleared = false;\n    _this._viewUpdateFlag = -1;\n    _this._projectionUpdateFlag = -1;\n    /** @internal */\n\n    _this._toBeDisposed = new Array(256);\n    _this._activeRequests = new Array();\n    /** @internal */\n\n    _this._pendingData = new Array();\n    _this._isDisposed = false;\n    /**\n     * Gets or sets a boolean indicating that all submeshes of active meshes must be rendered\n     * Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)\n     */\n\n    _this.dispatchAllSubMeshesOfActiveMeshes = false;\n    _this._activeMeshes = new SmartArray(256);\n    _this._processedMaterials = new SmartArray(256);\n    _this._renderTargets = new SmartArrayNoDuplicate(256);\n    _this._materialsRenderTargets = new SmartArrayNoDuplicate(256);\n    /** @internal */\n\n    _this._activeParticleSystems = new SmartArray(256);\n    _this._activeSkeletons = new SmartArrayNoDuplicate(32);\n    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);\n    /** @internal */\n\n    _this._activeAnimatables = new Array();\n    _this._transformMatrix = Matrix.Zero();\n    /**\n     * Gets or sets a boolean indicating if lights must be sorted by priority (off by default)\n     * This is useful if there are more lights that the maximum simulteanous authorized\n     */\n\n    _this.requireLightSorting = false;\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n\n    _this._components = [];\n    /**\n     * @internal\n     * Backing store of defined scene components.\n     */\n\n    _this._serializableComponents = [];\n    /**\n     * List of components to register on the next registration step.\n     */\n\n    _this._transientComponents = [];\n    /**\n     * @internal\n     * Defines the actions happening before camera updates.\n     */\n\n    _this._beforeCameraUpdateStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n\n    _this._beforeClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before clear the canvas.\n     */\n\n    _this._beforeRenderTargetClearStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions when collecting render targets for the frame.\n     */\n\n    _this._gatherRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening for one camera in the frame.\n     */\n\n    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per mesh ready checks.\n     */\n\n    _this._isReadyForMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening before evaluate active mesh checks.\n     */\n\n    _this._beforeEvaluateActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the evaluate sub mesh checks.\n     */\n\n    _this._evaluateSubMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the active mesh stage.\n     */\n\n    _this._preActiveMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening during the per camera render target step.\n     */\n\n    _this._cameraDrawRenderTargetStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before the active camera is drawing.\n     */\n\n    _this._beforeCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a render target is drawing.\n     */\n\n    _this._beforeRenderTargetDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a rendering group is drawing.\n     */\n\n    _this._beforeRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just before a mesh is drawing.\n     */\n\n    _this._beforeRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a mesh has been drawn.\n     */\n\n    _this._afterRenderingMeshStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a rendering group has been drawn.\n     */\n\n    _this._afterRenderingGroupDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after the active camera has been drawn.\n     */\n\n    _this._afterCameraDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after a render target has been drawn.\n     */\n\n    _this._afterRenderTargetDrawStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening just after rendering all cameras and computing intersections.\n     */\n\n    _this._afterRenderStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer move event happens.\n     */\n\n    _this._pointerMoveStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer down event happens.\n     */\n\n    _this._pointerDownStage = Stage.Create();\n    /**\n     * @internal\n     * Defines the actions happening when a pointer up event happens.\n     */\n\n    _this._pointerUpStage = Stage.Create();\n    /**\n     * an optional map from Geometry Id to Geometry index in the 'geometries' array\n     */\n\n    _this._geometriesByUniqueId = null;\n    _this._defaultMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._defaultSubMeshCandidates = {\n      data: [],\n      length: 0\n    };\n    _this._preventFreeActiveMeshesAndRenderingGroups = false;\n    /** @internal */\n\n    _this._activeMeshesFrozen = false;\n    _this._activeMeshesFrozenButKeepClipping = false;\n    _this._skipEvaluateActiveMeshesCompletely = false;\n    /** @internal */\n\n    _this._allowPostProcessClearColor = true;\n    /**\n     * User updatable function that will return a deterministic frame time when engine is in deterministic lock step mode\n     */\n\n    _this.getDeterministicFrameTime = function () {\n      return _this._engine.getTimeStep();\n    };\n\n    _this._blockMaterialDirtyMechanism = false;\n    /**\n     * Internal perfCollector instance used for sharing between inspector and playground.\n     * Marked as protected to allow sharing between prototype extensions, but disallow access at toplevel.\n     */\n\n    _this._perfCollector = null;\n    /**\n     * An event triggered when the cpu usage/speed meets certain thresholds.\n     * Note: Compute pressure is an experimental API.\n     */\n\n    _this.onComputePressureChanged = new Observable();\n    _this.activeCameras = new Array();\n\n    var fullOptions = _objectSpread({\n      useGeometryUniqueIdsMap: true,\n      useMaterialMeshMap: true,\n      useClonedMeshMap: true,\n      virtual: false\n    }, options);\n\n    _this._engine = engine || EngineStore.LastCreatedEngine;\n\n    if (!fullOptions.virtual) {\n      EngineStore._LastCreatedScene = _assertThisInitialized(_this);\n\n      _this._engine.scenes.push(_assertThisInitialized(_this));\n    } else {\n      _this._engine._virtualScenes.push(_assertThisInitialized(_this));\n    }\n\n    _this._uid = null;\n    _this._renderingManager = new RenderingManager(_assertThisInitialized(_this));\n\n    if (PostProcessManager) {\n      _this.postProcessManager = new PostProcessManager(_assertThisInitialized(_this));\n    }\n\n    if (IsWindowObjectExist()) {\n      _this.attachControl();\n    } // Uniform Buffer\n\n\n    _this._createUbo(); // Default Image processing definition\n\n\n    if (ImageProcessingConfiguration) {\n      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n    }\n\n    _this.setDefaultCandidateProviders();\n\n    if (fullOptions.useGeometryUniqueIdsMap) {\n      _this._geometriesByUniqueId = {};\n    }\n\n    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;\n    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;\n\n    if (!options || !options.virtual) {\n      _this._engine.onNewSceneAddedObservable.notifyObservers(_assertThisInitialized(_this));\n    }\n\n    if (ComputePressureObserverWrapper.IsAvailable) {\n      _this._computePressureObserver = new ComputePressureObserverWrapper(function (update) {\n        _this.onComputePressureChanged.notifyObservers(update);\n      }, {\n        // Thresholds divide the interval [0.0 .. 1.0] into ranges.\n        cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],\n        cpuSpeedThresholds: [0.5]\n      });\n\n      _this._computePressureObserver.observe(\"cpu\");\n    }\n\n    return _this;\n  }\n  /**\n   * Factory used to create the default material.\n   * @param scene The scene to create the material for\n   * @returns The default material\n   */\n\n\n  _createClass(Scene, [{\n    key: \"environmentTexture\",\n    get:\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to reference from here than from all the materials.\n     */\n    function get() {\n      return this._environmentTexture;\n    }\n    /**\n     * Texture used in all pbr material as the reflection texture.\n     * As in the majority of the scene they are the same (exception for multi room and so on),\n     * this is easier to set here than in all the materials.\n     */\n    ,\n    set: function set(value) {\n      if (this._environmentTexture === value) {\n        return;\n      }\n\n      this._environmentTexture = value;\n      this.markAllMaterialsAsDirty(1);\n    }\n    /**\n     * Default image processing configuration used either in the rendering\n     * Forward main pass or through the imageProcessingPostProcess if present.\n     * As in the majority of the scene they are the same (exception for multi camera),\n     * this is easier to reference from here than from all the materials and post process.\n     *\n     * No setter as we it is a shared configuration, you can set the values instead.\n     */\n\n  }, {\n    key: \"imageProcessingConfiguration\",\n    get: function get() {\n      return this._imageProcessingConfiguration;\n    }\n    /**\n     * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility\n     */\n\n  }, {\n    key: \"performancePriority\",\n    get: function get() {\n      return this._performancePriority;\n    },\n    set: function set(value) {\n      if (value === this._performancePriority) {\n        return;\n      }\n\n      this._performancePriority = value;\n\n      switch (value) {\n        case ScenePerformancePriority.Aggressive:\n          this.skipFrustumClipping = true;\n        // eslint-disable-next-line no-fallthrough\n\n        case ScenePerformancePriority.Intermediate:\n          this.skipPointerMovePicking = true;\n          this.autoClear = false;\n          break;\n      }\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in wireframe\n     */\n\n  }, {\n    key: \"forceWireframe\",\n    get: function get() {\n      return this._forceWireframe;\n    }\n    /**\n     * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection\n     */\n    ,\n    set: function set(value) {\n      if (this._forceWireframe === value) {\n        return;\n      }\n\n      this._forceWireframe = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"skipFrustumClipping\",\n    get: function get() {\n      return this._skipFrustumClipping;\n    }\n    /**\n     * Gets or sets a boolean indicating if all rendering must be done in point cloud\n     */\n    ,\n    set: function set(value) {\n      if (this._skipFrustumClipping === value) {\n        return;\n      }\n\n      this._skipFrustumClipping = value;\n    }\n  }, {\n    key: \"forcePointsCloud\",\n    get: function get() {\n      return this._forcePointsCloud;\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    ,\n    set: function set(value) {\n      if (this._forcePointsCloud === value) {\n        return;\n      }\n\n      this._forcePointsCloud = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"animationPropertiesOverride\",\n    get: function get() {\n      return this._animationPropertiesOverride;\n    },\n    set: function set(value) {\n      this._animationPropertiesOverride = value;\n    }\n    /** Sets a function to be executed when this scene is disposed. */\n\n  }, {\n    key: \"onDispose\",\n    set: function set(callback) {\n      if (this._onDisposeObserver) {\n        this.onDisposeObservable.remove(this._onDisposeObserver);\n      }\n\n      this._onDisposeObserver = this.onDisposeObservable.add(callback);\n    }\n    /** Sets a function to be executed before rendering this scene */\n\n  }, {\n    key: \"beforeRender\",\n    set: function set(callback) {\n      if (this._onBeforeRenderObserver) {\n        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);\n      }\n\n      if (callback) {\n        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);\n      }\n    }\n    /** Sets a function to be executed after rendering this scene */\n\n  }, {\n    key: \"afterRender\",\n    set: function set(callback) {\n      if (this._onAfterRenderObserver) {\n        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);\n      }\n\n      if (callback) {\n        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);\n      }\n    }\n    /** Sets a function to be executed before rendering a camera*/\n\n  }, {\n    key: \"beforeCameraRender\",\n    set: function set(callback) {\n      if (this._onBeforeCameraRenderObserver) {\n        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);\n      }\n\n      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);\n    }\n    /** Sets a function to be executed after rendering a camera*/\n\n  }, {\n    key: \"afterCameraRender\",\n    set: function set(callback) {\n      if (this._onAfterCameraRenderObserver) {\n        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);\n      }\n\n      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);\n    }\n    /**\n     * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)\n     */\n\n  }, {\n    key: \"unTranslatedPointer\",\n    get: function get() {\n      return this._inputManager.unTranslatedPointer;\n    }\n    /**\n     * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels\n     */\n\n  }, {\n    key: \"bindEyePosition\",\n    value:\n    /**\n     * Bind the current view position to an effect.\n     * @param effect The effect to be bound\n     * @param variableName name of the shader variable that will hold the eye position\n     * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4\n     * @returns the computed eye position\n     */\n    function bindEyePosition(effect) {\n      var _this$activeCamera$gl;\n\n      var variableName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"vEyePosition\";\n      var isVector3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_this$activeCamera$gl = this.activeCamera.globalPosition) !== null && _this$activeCamera$gl !== void 0 ? _this$activeCamera$gl : this.activeCamera.devicePosition;\n      var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);\n      TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);\n\n      if (effect) {\n        if (isVector3) {\n          effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);\n        } else {\n          effect.setVector4(variableName, TmpVectors.Vector4[0]);\n        }\n      }\n\n      return TmpVectors.Vector4[0];\n    }\n    /**\n     * Update the scene ubo before it can be used in rendering processing\n     * @returns the scene UniformBuffer\n     */\n\n  }, {\n    key: \"finalizeSceneUbo\",\n    value: function finalizeSceneUbo() {\n      var ubo = this.getSceneUniformBuffer();\n      var eyePosition = this.bindEyePosition(null);\n      ubo.updateFloat4(\"vEyePosition\", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);\n      ubo.update();\n      return ubo;\n    }\n    /**\n     * Gets or sets a boolean indicating if the scene must use right-handed coordinates system\n     */\n\n  }, {\n    key: \"useRightHandedSystem\",\n    get: function get() {\n      return this._useRightHandedSystem;\n    }\n    /**\n     * Sets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @param newStepId defines the step Id\n     */\n    ,\n    set: function set(value) {\n      if (this._useRightHandedSystem === value) {\n        return;\n      }\n\n      this._useRightHandedSystem = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"setStepId\",\n    value: function setStepId(newStepId) {\n      this._currentStepId = newStepId;\n    }\n    /**\n     * Gets the step Id used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @returns the step Id\n     */\n\n  }, {\n    key: \"getStepId\",\n    value: function getStepId() {\n      return this._currentStepId;\n    }\n    /**\n     * Gets the internal step used by deterministic lock step\n     * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n     * @returns the internal step\n     */\n\n  }, {\n    key: \"getInternalStep\",\n    value: function getInternalStep() {\n      return this._currentInternalStep;\n    }\n    /**\n     * Gets or sets a boolean indicating if fog is enabled on this scene\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * (Default is true)\n     */\n\n  }, {\n    key: \"fogEnabled\",\n    get: function get() {\n      return this._fogEnabled;\n    }\n    /**\n     * Gets or sets the fog mode to use\n     * @see https://doc.babylonjs.com/babylon101/environment#fog\n     * | mode | value |\n     * | --- | --- |\n     * | FOGMODE_NONE | 0 |\n     * | FOGMODE_EXP | 1 |\n     * | FOGMODE_EXP2 | 2 |\n     * | FOGMODE_LINEAR | 3 |\n     */\n    ,\n    set: function set(value) {\n      if (this._fogEnabled === value) {\n        return;\n      }\n\n      this._fogEnabled = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"fogMode\",\n    get: function get() {\n      return this._fogMode;\n    }\n    /**\n     * Flag indicating that the frame buffer binding is handled by another component\n     */\n    ,\n    set: function set(value) {\n      if (this._fogMode === value) {\n        return;\n      }\n\n      this._fogMode = value;\n      this.markAllMaterialsAsDirty(16);\n    }\n  }, {\n    key: \"prePass\",\n    get: function get() {\n      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if shadows are enabled on this scene\n     */\n\n  }, {\n    key: \"shadowsEnabled\",\n    get: function get() {\n      return this._shadowsEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if lights are enabled on this scene\n     */\n    ,\n    set: function set(value) {\n      if (this._shadowsEnabled === value) {\n        return;\n      }\n\n      this._shadowsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    }\n  }, {\n    key: \"lightsEnabled\",\n    get: function get() {\n      return this._lightsEnabled;\n    }\n    /** All of the active cameras added to this scene. */\n    ,\n    set: function set(value) {\n      if (this._lightsEnabled === value) {\n        return;\n      }\n\n      this._lightsEnabled = value;\n      this.markAllMaterialsAsDirty(2);\n    }\n  }, {\n    key: \"activeCameras\",\n    get: function get() {\n      return this._activeCameras;\n    },\n    set: function set(cameras) {\n      var _this2 = this;\n\n      if (this._unObserveActiveCameras) {\n        this._unObserveActiveCameras();\n\n        this._unObserveActiveCameras = null;\n      }\n\n      if (cameras) {\n        this._unObserveActiveCameras = _ObserveArray(cameras, function () {\n          _this2.onActiveCamerasChanged.notifyObservers(_this2);\n        });\n      }\n\n      this._activeCameras = cameras;\n    }\n    /** Gets or sets the current active camera */\n\n  }, {\n    key: \"activeCamera\",\n    get: function get() {\n      return this._activeCamera;\n    },\n    set: function set(value) {\n      if (value === this._activeCamera) {\n        return;\n      }\n\n      this._activeCamera = value;\n      this.onActiveCameraChanged.notifyObservers(this);\n    }\n    /** The default material used on meshes when no material is affected */\n\n  }, {\n    key: \"defaultMaterial\",\n    get: function get() {\n      if (!this._defaultMaterial) {\n        this._defaultMaterial = Scene.DefaultMaterialFactory(this);\n      }\n\n      return this._defaultMaterial;\n    }\n    /** The default material used on meshes when no material is affected */\n    ,\n    set: function set(value) {\n      this._defaultMaterial = value;\n    }\n    /**\n     * Gets or sets a boolean indicating if textures are enabled on this scene\n     */\n\n  }, {\n    key: \"texturesEnabled\",\n    get: function get() {\n      return this._texturesEnabled;\n    }\n    /**\n     * Gets or sets a boolean indicating if skeletons are enabled on this scene\n     */\n    ,\n    set: function set(value) {\n      if (this._texturesEnabled === value) {\n        return;\n      }\n\n      this._texturesEnabled = value;\n      this.markAllMaterialsAsDirty(1);\n    }\n  }, {\n    key: \"skeletonsEnabled\",\n    get: function get() {\n      return this._skeletonsEnabled;\n    }\n    /** @internal */\n    ,\n    set: function set(value) {\n      if (this._skeletonsEnabled === value) {\n        return;\n      }\n\n      this._skeletonsEnabled = value;\n      this.markAllMaterialsAsDirty(8);\n    }\n  }, {\n    key: \"collisionCoordinator\",\n    get: function get() {\n      if (!this._collisionCoordinator) {\n        this._collisionCoordinator = Scene.CollisionCoordinatorFactory();\n\n        this._collisionCoordinator.init(this);\n      }\n\n      return this._collisionCoordinator;\n    }\n    /**\n     * Gets the list of frustum planes (built from the active camera)\n     */\n\n  }, {\n    key: \"frustumPlanes\",\n    get: function get() {\n      return this._frustumPlanes;\n    }\n    /**\n     * Registers the transient components if needed.\n     */\n\n  }, {\n    key: \"_registerTransientComponents\",\n    value: function _registerTransientComponents() {\n      // Register components that have been associated lately to the scene.\n      if (this._transientComponents.length > 0) {\n        var _iterator = _createForOfIteratorHelper(this._transientComponents),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var component = _step.value;\n            component.register();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this._transientComponents.length = 0;\n      }\n    }\n    /**\n     * @internal\n     * Add a component to the scene.\n     * Note that the ccomponent could be registered on th next frame if this is called after\n     * the register component stage.\n     * @param component Defines the component to add to the scene\n     */\n\n  }, {\n    key: \"_addComponent\",\n    value: function _addComponent(component) {\n      this._components.push(component);\n\n      this._transientComponents.push(component);\n\n      var serializableComponent = component;\n\n      if (serializableComponent.addFromContainer && serializableComponent.serialize) {\n        this._serializableComponents.push(serializableComponent);\n      }\n    }\n    /**\n     * @internal\n     * Gets a component from the scene.\n     * @param name defines the name of the component to retrieve\n     * @returns the component or null if not present\n     */\n\n  }, {\n    key: \"_getComponent\",\n    value: function _getComponent(name) {\n      var _iterator2 = _createForOfIteratorHelper(this._components),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var component = _step2.value;\n\n          if (component.name === name) {\n            return component;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return null;\n    }\n    /**\n     * Gets a string identifying the name of the class\n     * @returns \"Scene\" string\n     */\n\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return \"Scene\";\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getDefaultMeshCandidates\",\n    value: function _getDefaultMeshCandidates() {\n      this._defaultMeshCandidates.data = this.meshes;\n      this._defaultMeshCandidates.length = this.meshes.length;\n      return this._defaultMeshCandidates;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_getDefaultSubMeshCandidates\",\n    value: function _getDefaultSubMeshCandidates(mesh) {\n      this._defaultSubMeshCandidates.data = mesh.subMeshes;\n      this._defaultSubMeshCandidates.length = mesh.subMeshes.length;\n      return this._defaultSubMeshCandidates;\n    }\n    /**\n     * Sets the default candidate providers for the scene.\n     * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates\n     * and getCollidingSubMeshCandidates to their default function\n     */\n\n  }, {\n    key: \"setDefaultCandidateProviders\",\n    value: function setDefaultCandidateProviders() {\n      this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);\n      this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n      this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n      this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);\n    }\n    /**\n     * Gets the mesh that is currently under the pointer\n     */\n\n  }, {\n    key: \"meshUnderPointer\",\n    get: function get() {\n      return this._inputManager.meshUnderPointer;\n    }\n    /**\n     * Gets or sets the current on-screen X position of the pointer\n     */\n\n  }, {\n    key: \"pointerX\",\n    get: function get() {\n      return this._inputManager.pointerX;\n    },\n    set: function set(value) {\n      this._inputManager.pointerX = value;\n    }\n    /**\n     * Gets or sets the current on-screen Y position of the pointer\n     */\n\n  }, {\n    key: \"pointerY\",\n    get: function get() {\n      return this._inputManager.pointerY;\n    },\n    set: function set(value) {\n      this._inputManager.pointerY = value;\n    }\n    /**\n     * Gets the cached material (ie. the latest rendered one)\n     * @returns the cached material\n     */\n\n  }, {\n    key: \"getCachedMaterial\",\n    value: function getCachedMaterial() {\n      return this._cachedMaterial;\n    }\n    /**\n     * Gets the cached effect (ie. the latest rendered one)\n     * @returns the cached effect\n     */\n\n  }, {\n    key: \"getCachedEffect\",\n    value: function getCachedEffect() {\n      return this._cachedEffect;\n    }\n    /**\n     * Gets the cached visibility state (ie. the latest rendered one)\n     * @returns the cached visibility state\n     */\n\n  }, {\n    key: \"getCachedVisibility\",\n    value: function getCachedVisibility() {\n      return this._cachedVisibility;\n    }\n    /**\n     * Gets a boolean indicating if the current material / effect / visibility must be bind again\n     * @param material defines the current material\n     * @param effect defines the current effect\n     * @param visibility defines the current visibility state\n     * @returns true if one parameter is not cached\n     */\n\n  }, {\n    key: \"isCachedMaterialInvalid\",\n    value: function isCachedMaterialInvalid(material, effect) {\n      var visibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;\n    }\n    /**\n     * Gets the engine associated with the scene\n     * @returns an Engine\n     */\n\n  }, {\n    key: \"getEngine\",\n    value: function getEngine() {\n      return this._engine;\n    }\n    /**\n     * Gets the total number of vertices rendered per frame\n     * @returns the total number of vertices rendered per frame\n     */\n\n  }, {\n    key: \"getTotalVertices\",\n    value: function getTotalVertices() {\n      return this._totalVertices.current;\n    }\n    /**\n     * Gets the performance counter for total vertices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n\n  }, {\n    key: \"totalVerticesPerfCounter\",\n    get: function get() {\n      return this._totalVertices;\n    }\n    /**\n     * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)\n     * @returns the total number of active indices rendered per frame\n     */\n\n  }, {\n    key: \"getActiveIndices\",\n    value: function getActiveIndices() {\n      return this._activeIndices.current;\n    }\n    /**\n     * Gets the performance counter for active indices\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n\n  }, {\n    key: \"totalActiveIndicesPerfCounter\",\n    get: function get() {\n      return this._activeIndices;\n    }\n    /**\n     * Gets the total number of active particles rendered per frame\n     * @returns the total number of active particles rendered per frame\n     */\n\n  }, {\n    key: \"getActiveParticles\",\n    value: function getActiveParticles() {\n      return this._activeParticles.current;\n    }\n    /**\n     * Gets the performance counter for active particles\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n\n  }, {\n    key: \"activeParticlesPerfCounter\",\n    get: function get() {\n      return this._activeParticles;\n    }\n    /**\n     * Gets the total number of active bones rendered per frame\n     * @returns the total number of active bones rendered per frame\n     */\n\n  }, {\n    key: \"getActiveBones\",\n    value: function getActiveBones() {\n      return this._activeBones.current;\n    }\n    /**\n     * Gets the performance counter for active bones\n     * @see https://doc.babylonjs.com/how_to/optimizing_your_scene#instrumentation\n     */\n\n  }, {\n    key: \"activeBonesPerfCounter\",\n    get: function get() {\n      return this._activeBones;\n    }\n    /**\n     * Gets the array of active meshes\n     * @returns an array of AbstractMesh\n     */\n\n  }, {\n    key: \"getActiveMeshes\",\n    value: function getActiveMeshes() {\n      return this._activeMeshes;\n    }\n    /**\n     * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)\n     * @returns a number\n     */\n\n  }, {\n    key: \"getAnimationRatio\",\n    value: function getAnimationRatio() {\n      return this._animationRatio !== undefined ? this._animationRatio : 1;\n    }\n    /**\n     * Gets an unique Id for the current render phase\n     * @returns a number\n     */\n\n  }, {\n    key: \"getRenderId\",\n    value: function getRenderId() {\n      return this._renderId;\n    }\n    /**\n     * Gets an unique Id for the current frame\n     * @returns a number\n     */\n\n  }, {\n    key: \"getFrameId\",\n    value: function getFrameId() {\n      return this._frameId;\n    }\n    /** Call this function if you want to manually increment the render Id*/\n\n  }, {\n    key: \"incrementRenderId\",\n    value: function incrementRenderId() {\n      this._renderId++;\n    }\n  }, {\n    key: \"_createUbo\",\n    value: function _createUbo() {\n      this.setSceneUniformBuffer(this.createSceneUniformBuffer());\n    }\n    /**\n     * Use this method to simulate a pointer move on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"simulatePointerMove\",\n    value: function simulatePointerMove(pickResult, pointerEventInit) {\n      this._inputManager.simulatePointerMove(pickResult, pointerEventInit);\n\n      return this;\n    }\n    /**\n     * Use this method to simulate a pointer down on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"simulatePointerDown\",\n    value: function simulatePointerDown(pickResult, pointerEventInit) {\n      this._inputManager.simulatePointerDown(pickResult, pointerEventInit);\n\n      return this;\n    }\n    /**\n     * Use this method to simulate a pointer up on a mesh\n     * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n     * @param pickResult pickingInfo of the object wished to simulate pointer event on\n     * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n     * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"simulatePointerUp\",\n    value: function simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n      this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);\n\n      return this;\n    }\n    /**\n     * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n     * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)\n     * @returns true if the pointer was captured\n     */\n\n  }, {\n    key: \"isPointerCaptured\",\n    value: function isPointerCaptured() {\n      var pointerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      return this._inputManager.isPointerCaptured(pointerId);\n    }\n    /**\n     * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n     * @param attachUp defines if you want to attach events to pointerup\n     * @param attachDown defines if you want to attach events to pointerdown\n     * @param attachMove defines if you want to attach events to pointermove\n     */\n\n  }, {\n    key: \"attachControl\",\n    value: function attachControl() {\n      var attachUp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var attachDown = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var attachMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      this._inputManager.attachControl(attachUp, attachDown, attachMove);\n    }\n    /** Detaches all event handlers*/\n\n  }, {\n    key: \"detachControl\",\n    value: function detachControl() {\n      this._inputManager.detachControl();\n    }\n    /**\n     * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)\n     * Delay loaded resources are not taking in account\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)\n     * @returns true if all required resources are ready\n     */\n\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this._isDisposed) {\n        return false;\n      }\n\n      var index;\n      var engine = this.getEngine();\n      var isReady = true; // Pending data\n\n      if (this._pendingData.length > 0) {\n        isReady = false;\n      } // Meshes\n\n\n      if (checkRenderTargets) {\n        this._processedMaterials.reset();\n\n        this._materialsRenderTargets.reset();\n      }\n\n      for (index = 0; index < this.meshes.length; index++) {\n        var mesh = this.meshes[index];\n\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {\n          continue;\n        } // Do not stop at the first encountered \"unready\" object as we want to ensure\n        // all materials are starting off their compilation in parallel.\n\n\n        if (!mesh.isReady(true)) {\n          isReady = false;\n          continue;\n        }\n\n        var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === \"InstancedMesh\" || mesh.getClassName() === \"InstancedLinesMesh\" || engine.getCaps().instancedArrays && mesh.instances.length > 0; // Is Ready For Mesh\n\n        var _iterator3 = _createForOfIteratorHelper(this._isReadyForMeshStage),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var step = _step3.value;\n\n            if (!step.action(mesh, hardwareInstancedRendering)) {\n              isReady = false;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        if (!checkRenderTargets) {\n          continue;\n        }\n\n        var mat = mesh.material || this.defaultMaterial;\n\n        if (mat) {\n          if (mat._storeEffectOnSubMeshes) {\n            var _iterator4 = _createForOfIteratorHelper(mesh.subMeshes),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var subMesh = _step4.value;\n                var material = subMesh.getMaterial();\n\n                if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n                  if (this._processedMaterials.indexOf(material) === -1) {\n                    this._processedMaterials.push(material);\n\n                    this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          } else {\n            if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {\n              if (this._processedMaterials.indexOf(mat) === -1) {\n                this._processedMaterials.push(mat);\n\n                this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());\n              }\n            }\n          }\n        }\n      }\n\n      if (!isReady) {\n        return false;\n      } // Effects\n\n\n      if (!engine.areAllEffectsReady()) {\n        return false;\n      } // Render targets\n\n\n      if (checkRenderTargets) {\n        for (index = 0; index < this._materialsRenderTargets.length; ++index) {\n          var rtt = this._materialsRenderTargets.data[index];\n\n          if (!rtt.isReadyForRendering()) {\n            return false;\n          }\n        }\n      } // Geometries\n\n\n      for (index = 0; index < this.geometries.length; index++) {\n        var geometry = this.geometries[index];\n\n        if (geometry.delayLoadState === 2) {\n          return false;\n        }\n      } // Post-processes\n\n\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        var _iterator5 = _createForOfIteratorHelper(this.activeCameras),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var camera = _step5.value;\n\n            if (!camera.isReady(true)) {\n              return false;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else if (this.activeCamera) {\n        if (!this.activeCamera.isReady(true)) {\n          return false;\n        }\n      } // Particles\n\n\n      var _iterator6 = _createForOfIteratorHelper(this.particleSystems),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var particleSystem = _step6.value;\n\n          if (!particleSystem.isReady()) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return true;\n    }\n    /** Resets all cached information relative to material (including effect and visibility) */\n\n  }, {\n    key: \"resetCachedMaterial\",\n    value: function resetCachedMaterial() {\n      this._cachedMaterial = null;\n      this._cachedEffect = null;\n      this._cachedVisibility = null;\n    }\n    /**\n     * Registers a function to be called before every frame render\n     * @param func defines the function to register\n     */\n\n  }, {\n    key: \"registerBeforeRender\",\n    value: function registerBeforeRender(func) {\n      this.onBeforeRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called before every frame render\n     * @param func defines the function to unregister\n     */\n\n  }, {\n    key: \"unregisterBeforeRender\",\n    value: function unregisterBeforeRender(func) {\n      this.onBeforeRenderObservable.removeCallback(func);\n    }\n    /**\n     * Registers a function to be called after every frame render\n     * @param func defines the function to register\n     */\n\n  }, {\n    key: \"registerAfterRender\",\n    value: function registerAfterRender(func) {\n      this.onAfterRenderObservable.add(func);\n    }\n    /**\n     * Unregisters a function called after every frame render\n     * @param func defines the function to unregister\n     */\n\n  }, {\n    key: \"unregisterAfterRender\",\n    value: function unregisterAfterRender(func) {\n      this.onAfterRenderObservable.removeCallback(func);\n    }\n  }, {\n    key: \"_executeOnceBeforeRender\",\n    value: function _executeOnceBeforeRender(func) {\n      var _this3 = this;\n\n      var execFunc = function execFunc() {\n        func();\n        setTimeout(function () {\n          _this3.unregisterBeforeRender(execFunc);\n        });\n      };\n\n      this.registerBeforeRender(execFunc);\n    }\n    /**\n     * The provided function will run before render once and will be disposed afterwards.\n     * A timeout delay can be provided so that the function will be executed in N ms.\n     * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.\n     * @param func The function to be executed.\n     * @param timeout optional delay in ms\n     */\n\n  }, {\n    key: \"executeOnceBeforeRender\",\n    value: function executeOnceBeforeRender(func, timeout) {\n      var _this4 = this;\n\n      if (timeout !== undefined) {\n        setTimeout(function () {\n          _this4._executeOnceBeforeRender(func);\n        }, timeout);\n      } else {\n        this._executeOnceBeforeRender(func);\n      }\n    }\n    /**\n     * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.\n     * @param data defines the object to wait for\n     */\n\n  }, {\n    key: \"addPendingData\",\n    value: function addPendingData(data) {\n      this._pendingData.push(data);\n    }\n    /**\n     * Remove a pending data from the loading list which has previously been added with addPendingData.\n     * @param data defines the object to remove from the pending list\n     */\n\n  }, {\n    key: \"removePendingData\",\n    value: function removePendingData(data) {\n      var wasLoading = this.isLoading;\n\n      var index = this._pendingData.indexOf(data);\n\n      if (index !== -1) {\n        this._pendingData.splice(index, 1);\n      }\n\n      if (wasLoading && !this.isLoading) {\n        this.onDataLoadedObservable.notifyObservers(this);\n      }\n    }\n    /**\n     * Returns the number of items waiting to be loaded\n     * @returns the number of items waiting to be loaded\n     */\n\n  }, {\n    key: \"getWaitingItemsCount\",\n    value: function getWaitingItemsCount() {\n      return this._pendingData.length;\n    }\n    /**\n     * Returns a boolean indicating if the scene is still loading data\n     */\n\n  }, {\n    key: \"isLoading\",\n    get: function get() {\n      return this._pendingData.length > 0;\n    }\n    /**\n     * Registers a function to be executed when the scene is ready\n     * @param {Function} func - the function to be executed\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     */\n\n  }, {\n    key: \"executeWhenReady\",\n    value: function executeWhenReady(func) {\n      var checkRenderTargets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.onReadyObservable.add(func);\n\n      if (this._executeWhenReadyTimeoutId !== null) {\n        return;\n      }\n\n      this._checkIsReady(checkRenderTargets);\n    }\n    /**\n     * Returns a promise that resolves when the scene is ready\n     * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)\n     * @returns A promise that resolves when the scene is ready\n     */\n\n  }, {\n    key: \"whenReadyAsync\",\n    value: function whenReadyAsync() {\n      var _this5 = this;\n\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return new Promise(function (resolve) {\n        _this5.executeWhenReady(function () {\n          resolve();\n        }, checkRenderTargets);\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_checkIsReady\",\n    value: function _checkIsReady() {\n      var _this6 = this;\n\n      var checkRenderTargets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      this._registerTransientComponents();\n\n      if (this.isReady(checkRenderTargets)) {\n        this.onReadyObservable.notifyObservers(this);\n        this.onReadyObservable.clear();\n        this._executeWhenReadyTimeoutId = null;\n        return;\n      }\n\n      if (this._isDisposed) {\n        this.onReadyObservable.clear();\n        this._executeWhenReadyTimeoutId = null;\n        return;\n      }\n\n      this._executeWhenReadyTimeoutId = setTimeout(function () {\n        // Ensure materials effects are checked outside render loops\n        _this6.incrementRenderId();\n\n        _this6._checkIsReady(checkRenderTargets);\n      }, 100);\n    }\n    /**\n     * Gets all animatable attached to the scene\n     */\n\n  }, {\n    key: \"animatables\",\n    get: function get() {\n      return this._activeAnimatables;\n    }\n    /**\n     * Resets the last animation time frame.\n     * Useful to override when animations start running when loading a scene for the first time.\n     */\n\n  }, {\n    key: \"resetLastAnimationTimeFrame\",\n    value: function resetLastAnimationTimeFrame() {\n      this._animationTimeLast = PrecisionDate.Now;\n    } // Matrix\n\n    /**\n     * Gets the current view matrix\n     * @returns a Matrix\n     */\n\n  }, {\n    key: \"getViewMatrix\",\n    value: function getViewMatrix() {\n      return this._viewMatrix;\n    }\n    /**\n     * Gets the current projection matrix\n     * @returns a Matrix\n     */\n\n  }, {\n    key: \"getProjectionMatrix\",\n    value: function getProjectionMatrix() {\n      return this._projectionMatrix;\n    }\n    /**\n     * Gets the current transform matrix\n     * @returns a Matrix made of View * Projection\n     */\n\n  }, {\n    key: \"getTransformMatrix\",\n    value: function getTransformMatrix() {\n      return this._transformMatrix;\n    }\n    /**\n     * Sets the current transform matrix\n     * @param viewL defines the View matrix to use\n     * @param projectionL defines the Projection matrix to use\n     * @param viewR defines the right View matrix to use (if provided)\n     * @param projectionR defines the right Projection matrix to use (if provided)\n     */\n\n  }, {\n    key: \"setTransformMatrix\",\n    value: function setTransformMatrix(viewL, projectionL, viewR, projectionR) {\n      // clear the multiviewSceneUbo if no viewR and projectionR are defined\n      if (!viewR && !projectionR && this._multiviewSceneUbo) {\n        this._multiviewSceneUbo.dispose();\n\n        this._multiviewSceneUbo = null;\n      }\n\n      if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {\n        return;\n      }\n\n      this._viewUpdateFlag = viewL.updateFlag;\n      this._projectionUpdateFlag = projectionL.updateFlag;\n      this._viewMatrix = viewL;\n      this._projectionMatrix = projectionL;\n\n      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix); // Update frustum\n\n\n      if (!this._frustumPlanes) {\n        this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);\n      } else {\n        Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);\n      }\n\n      if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {\n        this._updateMultiviewUbo(viewR, projectionR);\n      } else if (this._sceneUbo.useUbo) {\n        this._sceneUbo.updateMatrix(\"viewProjection\", this._transformMatrix);\n\n        this._sceneUbo.updateMatrix(\"view\", this._viewMatrix);\n\n        this._sceneUbo.updateMatrix(\"projection\", this._projectionMatrix);\n      }\n    }\n    /**\n     * Gets the uniform buffer used to store scene data\n     * @returns a UniformBuffer\n     */\n\n  }, {\n    key: \"getSceneUniformBuffer\",\n    value: function getSceneUniformBuffer() {\n      return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;\n    }\n    /**\n     * Creates a scene UBO\n     * @param name name of the uniform buffer (optional, for debugging purpose only)\n     * @returns a new ubo\n     */\n\n  }, {\n    key: \"createSceneUniformBuffer\",\n    value: function createSceneUniformBuffer(name) {\n      var sceneUbo = new UniformBuffer(this._engine, undefined, false, name !== null && name !== void 0 ? name : \"scene\");\n      sceneUbo.addUniform(\"viewProjection\", 16);\n      sceneUbo.addUniform(\"view\", 16);\n      sceneUbo.addUniform(\"projection\", 16);\n      sceneUbo.addUniform(\"vEyePosition\", 4);\n      return sceneUbo;\n    }\n    /**\n     * Sets the scene ubo\n     * @param ubo the ubo to set for the scene\n     */\n\n  }, {\n    key: \"setSceneUniformBuffer\",\n    value: function setSceneUniformBuffer(ubo) {\n      this._sceneUbo = ubo;\n      this._viewUpdateFlag = -1;\n      this._projectionUpdateFlag = -1;\n    }\n    /**\n     * Gets an unique (relatively to the current scene) Id\n     * @returns an unique number for the scene\n     */\n\n  }, {\n    key: \"getUniqueId\",\n    value: function getUniqueId() {\n      return UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Add a mesh to the list of scene's meshes\n     * @param newMesh defines the mesh to add\n     * @param recursive if all child meshes should also be added to the scene\n     */\n\n  }, {\n    key: \"addMesh\",\n    value: function addMesh(newMesh) {\n      var _this7 = this;\n\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.meshes.push(newMesh);\n\n      newMesh._resyncLightSources();\n\n      if (!newMesh.parent) {\n        newMesh._addToSceneRootNodes();\n      }\n\n      this.onNewMeshAddedObservable.notifyObservers(newMesh);\n\n      if (recursive) {\n        newMesh.getChildMeshes().forEach(function (m) {\n          _this7.addMesh(m);\n        });\n      }\n    }\n    /**\n     * Remove a mesh for the list of scene's meshes\n     * @param toRemove defines the mesh to remove\n     * @param recursive if all child meshes should also be removed from the scene\n     * @returns the index where the mesh was in the mesh list\n     */\n\n  }, {\n    key: \"removeMesh\",\n    value: function removeMesh(toRemove) {\n      var _this8 = this;\n\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var index = this.meshes.indexOf(toRemove);\n\n      if (index !== -1) {\n        // Remove from the scene if mesh found\n        this.meshes[index] = this.meshes[this.meshes.length - 1];\n        this.meshes.pop();\n\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n\n      this._inputManager._invalidateMesh(toRemove);\n\n      this.onMeshRemovedObservable.notifyObservers(toRemove);\n\n      if (recursive) {\n        toRemove.getChildMeshes().forEach(function (m) {\n          _this8.removeMesh(m);\n        });\n      }\n\n      return index;\n    }\n    /**\n     * Add a transform node to the list of scene's transform nodes\n     * @param newTransformNode defines the transform node to add\n     */\n\n  }, {\n    key: \"addTransformNode\",\n    value: function addTransformNode(newTransformNode) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {\n        // Already there?\n        return;\n      }\n\n      newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;\n      this.transformNodes.push(newTransformNode);\n\n      if (!newTransformNode.parent) {\n        newTransformNode._addToSceneRootNodes();\n      }\n\n      this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);\n    }\n    /**\n     * Remove a transform node for the list of scene's transform nodes\n     * @param toRemove defines the transform node to remove\n     * @returns the index where the transform node was in the transform node list\n     */\n\n  }, {\n    key: \"removeTransformNode\",\n    value: function removeTransformNode(toRemove) {\n      var index = toRemove._indexInSceneTransformNodesArray;\n\n      if (index !== -1) {\n        if (index !== this.transformNodes.length - 1) {\n          var lastNode = this.transformNodes[this.transformNodes.length - 1];\n          this.transformNodes[index] = lastNode;\n          lastNode._indexInSceneTransformNodesArray = index;\n        }\n\n        toRemove._indexInSceneTransformNodesArray = -1;\n        this.transformNodes.pop();\n\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n\n      this.onTransformNodeRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a skeleton for the list of scene's skeletons\n     * @param toRemove defines the skeleton to remove\n     * @returns the index where the skeleton was in the skeleton list\n     */\n\n  }, {\n    key: \"removeSkeleton\",\n    value: function removeSkeleton(toRemove) {\n      var index = this.skeletons.indexOf(toRemove);\n\n      if (index !== -1) {\n        // Remove from the scene if found\n        this.skeletons.splice(index, 1);\n        this.onSkeletonRemovedObservable.notifyObservers(toRemove); // Clean active container\n\n        this._executeActiveContainerCleanup(this._activeSkeletons);\n      }\n\n      return index;\n    }\n    /**\n     * Remove a morph target for the list of scene's morph targets\n     * @param toRemove defines the morph target to remove\n     * @returns the index where the morph target was in the morph target list\n     */\n\n  }, {\n    key: \"removeMorphTargetManager\",\n    value: function removeMorphTargetManager(toRemove) {\n      var index = this.morphTargetManagers.indexOf(toRemove);\n\n      if (index !== -1) {\n        // Remove from the scene if found\n        this.morphTargetManagers.splice(index, 1);\n      }\n\n      return index;\n    }\n    /**\n     * Remove a light for the list of scene's lights\n     * @param toRemove defines the light to remove\n     * @returns the index where the light was in the light list\n     */\n\n  }, {\n    key: \"removeLight\",\n    value: function removeLight(toRemove) {\n      var index = this.lights.indexOf(toRemove);\n\n      if (index !== -1) {\n        // Remove from meshes\n        var _iterator7 = _createForOfIteratorHelper(this.meshes),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var mesh = _step7.value;\n\n            mesh._removeLightSource(toRemove, false);\n          } // Remove from the scene if mesh found\n\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        this.lights.splice(index, 1);\n        this.sortLightsByPriority();\n\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      }\n\n      this.onLightRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a camera for the list of scene's cameras\n     * @param toRemove defines the camera to remove\n     * @returns the index where the camera was in the camera list\n     */\n\n  }, {\n    key: \"removeCamera\",\n    value: function removeCamera(toRemove) {\n      var index = this.cameras.indexOf(toRemove);\n\n      if (index !== -1) {\n        // Remove from the scene if mesh found\n        this.cameras.splice(index, 1);\n\n        if (!toRemove.parent) {\n          toRemove._removeFromSceneRootNodes();\n        }\n      } // Remove from activeCameras\n\n\n      if (this.activeCameras) {\n        var index2 = this.activeCameras.indexOf(toRemove);\n\n        if (index2 !== -1) {\n          // Remove from the scene if mesh found\n          this.activeCameras.splice(index2, 1);\n        }\n      } // Reset the activeCamera\n\n\n      if (this.activeCamera === toRemove) {\n        if (this.cameras.length > 0) {\n          this.activeCamera = this.cameras[0];\n        } else {\n          this.activeCamera = null;\n        }\n      }\n\n      this.onCameraRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Remove a particle system for the list of scene's particle systems\n     * @param toRemove defines the particle system to remove\n     * @returns the index where the particle system was in the particle system list\n     */\n\n  }, {\n    key: \"removeParticleSystem\",\n    value: function removeParticleSystem(toRemove) {\n      var index = this.particleSystems.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.particleSystems.splice(index, 1); // Clean active container\n\n        this._executeActiveContainerCleanup(this._activeParticleSystems);\n      }\n\n      return index;\n    }\n    /**\n     * Remove a animation for the list of scene's animations\n     * @param toRemove defines the animation to remove\n     * @returns the index where the animation was in the animation list\n     */\n\n  }, {\n    key: \"removeAnimation\",\n    value: function removeAnimation(toRemove) {\n      var index = this.animations.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.animations.splice(index, 1);\n      }\n\n      return index;\n    }\n    /**\n     * Will stop the animation of the given target\n     * @param target - the target\n     * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)\n     * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     */\n\n  }, {\n    key: \"stopAnimation\",\n    value: function stopAnimation(target, animationName, targetMask) {// Do nothing as code will be provided by animation component\n    }\n    /**\n     * Removes the given animation group from this scene.\n     * @param toRemove The animation group to remove\n     * @returns The index of the removed animation group\n     */\n\n  }, {\n    key: \"removeAnimationGroup\",\n    value: function removeAnimationGroup(toRemove) {\n      var index = this.animationGroups.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.animationGroups.splice(index, 1);\n      }\n\n      return index;\n    }\n    /**\n     * Removes the given multi-material from this scene.\n     * @param toRemove The multi-material to remove\n     * @returns The index of the removed multi-material\n     */\n\n  }, {\n    key: \"removeMultiMaterial\",\n    value: function removeMultiMaterial(toRemove) {\n      var index = this.multiMaterials.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.multiMaterials.splice(index, 1);\n      }\n\n      this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Removes the given material from this scene.\n     * @param toRemove The material to remove\n     * @returns The index of the removed material\n     */\n\n  }, {\n    key: \"removeMaterial\",\n    value: function removeMaterial(toRemove) {\n      var index = toRemove._indexInSceneMaterialArray;\n\n      if (index !== -1 && index < this.materials.length) {\n        if (index !== this.materials.length - 1) {\n          var lastMaterial = this.materials[this.materials.length - 1];\n          this.materials[index] = lastMaterial;\n          lastMaterial._indexInSceneMaterialArray = index;\n        }\n\n        toRemove._indexInSceneMaterialArray = -1;\n        this.materials.pop();\n      }\n\n      this.onMaterialRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Removes the given action manager from this scene.\n     * @deprecated\n     * @param toRemove The action manager to remove\n     * @returns The index of the removed action manager\n     */\n\n  }, {\n    key: \"removeActionManager\",\n    value: function removeActionManager(toRemove) {\n      var index = this.actionManagers.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.actionManagers.splice(index, 1);\n      }\n\n      return index;\n    }\n    /**\n     * Removes the given texture from this scene.\n     * @param toRemove The texture to remove\n     * @returns The index of the removed texture\n     */\n\n  }, {\n    key: \"removeTexture\",\n    value: function removeTexture(toRemove) {\n      var index = this.textures.indexOf(toRemove);\n\n      if (index !== -1) {\n        this.textures.splice(index, 1);\n      }\n\n      this.onTextureRemovedObservable.notifyObservers(toRemove);\n      return index;\n    }\n    /**\n     * Adds the given light to this scene\n     * @param newLight The light to add\n     */\n\n  }, {\n    key: \"addLight\",\n    value: function addLight(newLight) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.lights.push(newLight);\n      this.sortLightsByPriority();\n\n      if (!newLight.parent) {\n        newLight._addToSceneRootNodes();\n      } // Add light to all meshes (To support if the light is removed and then re-added)\n\n\n      var _iterator8 = _createForOfIteratorHelper(this.meshes),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var mesh = _step8.value;\n\n          if (mesh.lightSources.indexOf(newLight) === -1) {\n            mesh.lightSources.push(newLight);\n\n            mesh._resyncLightSources();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      this.onNewLightAddedObservable.notifyObservers(newLight);\n    }\n    /**\n     * Sorts the list list based on light priorities\n     */\n\n  }, {\n    key: \"sortLightsByPriority\",\n    value: function sortLightsByPriority() {\n      if (this.requireLightSorting) {\n        this.lights.sort(LightConstants.CompareLightsPriority);\n      }\n    }\n    /**\n     * Adds the given camera to this scene\n     * @param newCamera The camera to add\n     */\n\n  }, {\n    key: \"addCamera\",\n    value: function addCamera(newCamera) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.cameras.push(newCamera);\n      this.onNewCameraAddedObservable.notifyObservers(newCamera);\n\n      if (!newCamera.parent) {\n        newCamera._addToSceneRootNodes();\n      }\n    }\n    /**\n     * Adds the given skeleton to this scene\n     * @param newSkeleton The skeleton to add\n     */\n\n  }, {\n    key: \"addSkeleton\",\n    value: function addSkeleton(newSkeleton) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.skeletons.push(newSkeleton);\n      this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);\n    }\n    /**\n     * Adds the given particle system to this scene\n     * @param newParticleSystem The particle system to add\n     */\n\n  }, {\n    key: \"addParticleSystem\",\n    value: function addParticleSystem(newParticleSystem) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.particleSystems.push(newParticleSystem);\n    }\n    /**\n     * Adds the given animation to this scene\n     * @param newAnimation The animation to add\n     */\n\n  }, {\n    key: \"addAnimation\",\n    value: function addAnimation(newAnimation) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.animations.push(newAnimation);\n    }\n    /**\n     * Adds the given animation group to this scene.\n     * @param newAnimationGroup The animation group to add\n     */\n\n  }, {\n    key: \"addAnimationGroup\",\n    value: function addAnimationGroup(newAnimationGroup) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.animationGroups.push(newAnimationGroup);\n    }\n    /**\n     * Adds the given multi-material to this scene\n     * @param newMultiMaterial The multi-material to add\n     */\n\n  }, {\n    key: \"addMultiMaterial\",\n    value: function addMultiMaterial(newMultiMaterial) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.multiMaterials.push(newMultiMaterial);\n      this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);\n    }\n    /**\n     * Adds the given material to this scene\n     * @param newMaterial The material to add\n     */\n\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(newMaterial) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {\n        // Already there??\n        return;\n      }\n\n      newMaterial._indexInSceneMaterialArray = this.materials.length;\n      this.materials.push(newMaterial);\n      this.onNewMaterialAddedObservable.notifyObservers(newMaterial);\n    }\n    /**\n     * Adds the given morph target to this scene\n     * @param newMorphTargetManager The morph target to add\n     */\n\n  }, {\n    key: \"addMorphTargetManager\",\n    value: function addMorphTargetManager(newMorphTargetManager) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.morphTargetManagers.push(newMorphTargetManager);\n    }\n    /**\n     * Adds the given geometry to this scene\n     * @param newGeometry The geometry to add\n     */\n\n  }, {\n    key: \"addGeometry\",\n    value: function addGeometry(newGeometry) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      if (this._geometriesByUniqueId) {\n        this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;\n      }\n\n      this.geometries.push(newGeometry);\n    }\n    /**\n     * Adds the given action manager to this scene\n     * @deprecated\n     * @param newActionManager The action manager to add\n     */\n\n  }, {\n    key: \"addActionManager\",\n    value: function addActionManager(newActionManager) {\n      this.actionManagers.push(newActionManager);\n    }\n    /**\n     * Adds the given texture to this scene.\n     * @param newTexture The texture to add\n     */\n\n  }, {\n    key: \"addTexture\",\n    value: function addTexture(newTexture) {\n      if (this._blockEntityCollection) {\n        return;\n      }\n\n      this.textures.push(newTexture);\n      this.onNewTextureAddedObservable.notifyObservers(newTexture);\n    }\n    /**\n     * Switch active camera\n     * @param newCamera defines the new active camera\n     * @param attachControl defines if attachControl must be called for the new active camera (default: true)\n     */\n\n  }, {\n    key: \"switchActiveCamera\",\n    value: function switchActiveCamera(newCamera) {\n      var attachControl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var canvas = this._engine.getInputElement();\n\n      if (!canvas) {\n        return;\n      }\n\n      if (this.activeCamera) {\n        this.activeCamera.detachControl();\n      }\n\n      this.activeCamera = newCamera;\n\n      if (attachControl) {\n        newCamera.attachControl();\n      }\n    }\n    /**\n     * sets the active camera of the scene using its Id\n     * @param id defines the camera's Id\n     * @returns the new active camera or null if none found.\n     */\n\n  }, {\n    key: \"setActiveCameraById\",\n    value: function setActiveCameraById(id) {\n      var camera = this.getCameraById(id);\n\n      if (camera) {\n        this.activeCamera = camera;\n        return camera;\n      }\n\n      return null;\n    }\n    /**\n     * sets the active camera of the scene using its name\n     * @param name defines the camera's name\n     * @returns the new active camera or null if none found.\n     */\n\n  }, {\n    key: \"setActiveCameraByName\",\n    value: function setActiveCameraByName(name) {\n      var camera = this.getCameraByName(name);\n\n      if (camera) {\n        this.activeCamera = camera;\n        return camera;\n      }\n\n      return null;\n    }\n    /**\n     * get an animation group using its name\n     * @param name defines the material's name\n     * @returns the animation group or null if none found.\n     */\n\n  }, {\n    key: \"getAnimationGroupByName\",\n    value: function getAnimationGroupByName(name) {\n      for (var index = 0; index < this.animationGroups.length; index++) {\n        if (this.animationGroups[index].name === name) {\n          return this.animationGroups[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get a material using its unique id\n     * @param uniqueId defines the material's unique id\n     * @returns the material or null if none found.\n     */\n\n  }, {\n    key: \"getMaterialByUniqueID\",\n    value: function getMaterialByUniqueID(uniqueId) {\n      for (var index = 0; index < this.materials.length; index++) {\n        if (this.materials[index].uniqueId === uniqueId) {\n          return this.materials[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * get a material using its id\n     * @param id defines the material's Id\n     * @returns the material or null if none found.\n     */\n\n  }, {\n    key: \"getMaterialById\",\n    value: function getMaterialById(id) {\n      for (var index = 0; index < this.materials.length; index++) {\n        if (this.materials[index].id === id) {\n          return this.materials[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a the last added material using a given id\n     * @param id defines the material's Id\n     * @param allowMultiMaterials determines whether multimaterials should be considered\n     * @returns the last material with the given id or null if none found.\n     */\n\n  }, {\n    key: \"getLastMaterialById\",\n    value: function getLastMaterialById(id) {\n      var allowMultiMaterials = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      for (var index = this.materials.length - 1; index >= 0; index--) {\n        if (this.materials[index].id === id) {\n          return this.materials[index];\n        }\n      }\n\n      if (allowMultiMaterials) {\n        for (var _index = this.multiMaterials.length - 1; _index >= 0; _index--) {\n          if (this.multiMaterials[_index].id === id) {\n            return this.multiMaterials[_index];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a material using its name\n     * @param name defines the material's name\n     * @returns the material or null if none found.\n     */\n\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      for (var index = 0; index < this.materials.length; index++) {\n        if (this.materials[index].name === name) {\n          return this.materials[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get a texture using its unique id\n     * @param uniqueId defines the texture's unique id\n     * @returns the texture or null if none found.\n     */\n\n  }, {\n    key: \"getTextureByUniqueId\",\n    value: function getTextureByUniqueId(uniqueId) {\n      for (var index = 0; index < this.textures.length; index++) {\n        if (this.textures[index].uniqueId === uniqueId) {\n          return this.textures[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a texture using its name\n     * @param name defines the texture's name\n     * @returns the texture or null if none found.\n     */\n\n  }, {\n    key: \"getTextureByName\",\n    value: function getTextureByName(name) {\n      for (var index = 0; index < this.textures.length; index++) {\n        if (this.textures[index].name === name) {\n          return this.textures[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a camera using its Id\n     * @param id defines the Id to look for\n     * @returns the camera or null if not found\n     */\n\n  }, {\n    key: \"getCameraById\",\n    value: function getCameraById(id) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].id === id) {\n          return this.cameras[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a camera using its unique Id\n     * @param uniqueId defines the unique Id to look for\n     * @returns the camera or null if not found\n     */\n\n  }, {\n    key: \"getCameraByUniqueId\",\n    value: function getCameraByUniqueId(uniqueId) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].uniqueId === uniqueId) {\n          return this.cameras[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a camera using its name\n     * @param name defines the camera's name\n     * @returns the camera or null if none found.\n     */\n\n  }, {\n    key: \"getCameraByName\",\n    value: function getCameraByName(name) {\n      for (var index = 0; index < this.cameras.length; index++) {\n        if (this.cameras[index].name === name) {\n          return this.cameras[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a bone using its Id\n     * @param id defines the bone's Id\n     * @returns the bone or null if not found\n     */\n\n  }, {\n    key: \"getBoneById\",\n    value: function getBoneById(id) {\n      for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n        var skeleton = this.skeletons[skeletonIndex];\n\n        for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n          if (skeleton.bones[boneIndex].id === id) {\n            return skeleton.bones[boneIndex];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a bone using its id\n     * @param name defines the bone's name\n     * @returns the bone or null if not found\n     */\n\n  }, {\n    key: \"getBoneByName\",\n    value: function getBoneByName(name) {\n      for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {\n        var skeleton = this.skeletons[skeletonIndex];\n\n        for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {\n          if (skeleton.bones[boneIndex].name === name) {\n            return skeleton.bones[boneIndex];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a light node using its name\n     * @param name defines the the light's name\n     * @returns the light or null if none found.\n     */\n\n  }, {\n    key: \"getLightByName\",\n    value: function getLightByName(name) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].name === name) {\n          return this.lights[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a light node using its Id\n     * @param id defines the light's Id\n     * @returns the light or null if none found.\n     */\n\n  }, {\n    key: \"getLightById\",\n    value: function getLightById(id) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].id === id) {\n          return this.lights[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a light node using its scene-generated unique Id\n     * @param uniqueId defines the light's unique Id\n     * @returns the light or null if none found.\n     */\n\n  }, {\n    key: \"getLightByUniqueId\",\n    value: function getLightByUniqueId(uniqueId) {\n      for (var index = 0; index < this.lights.length; index++) {\n        if (this.lights[index].uniqueId === uniqueId) {\n          return this.lights[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a particle system by Id\n     * @param id defines the particle system Id\n     * @returns the corresponding system or null if none found\n     */\n\n  }, {\n    key: \"getParticleSystemById\",\n    value: function getParticleSystemById(id) {\n      for (var index = 0; index < this.particleSystems.length; index++) {\n        if (this.particleSystems[index].id === id) {\n          return this.particleSystems[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a geometry using its Id\n     * @param id defines the geometry's Id\n     * @returns the geometry or null if none found.\n     */\n\n  }, {\n    key: \"getGeometryById\",\n    value: function getGeometryById(id) {\n      for (var index = 0; index < this.geometries.length; index++) {\n        if (this.geometries[index].id === id) {\n          return this.geometries[index];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getGeometryByUniqueId\",\n    value: function _getGeometryByUniqueId(uniqueId) {\n      if (this._geometriesByUniqueId) {\n        var index = this._geometriesByUniqueId[uniqueId];\n\n        if (index !== undefined) {\n          return this.geometries[index];\n        }\n      } else {\n        for (var _index2 = 0; _index2 < this.geometries.length; _index2++) {\n          if (this.geometries[_index2].uniqueId === uniqueId) {\n            return this.geometries[_index2];\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Add a new geometry to this scene\n     * @param geometry defines the geometry to be added to the scene.\n     * @param force defines if the geometry must be pushed even if a geometry with this id already exists\n     * @returns a boolean defining if the geometry was added or not\n     */\n\n  }, {\n    key: \"pushGeometry\",\n    value: function pushGeometry(geometry, force) {\n      if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {\n        return false;\n      }\n\n      this.addGeometry(geometry);\n      this.onNewGeometryAddedObservable.notifyObservers(geometry);\n      return true;\n    }\n    /**\n     * Removes an existing geometry\n     * @param geometry defines the geometry to be removed from the scene\n     * @returns a boolean defining if the geometry was removed or not\n     */\n\n  }, {\n    key: \"removeGeometry\",\n    value: function removeGeometry(geometry) {\n      var index;\n\n      if (this._geometriesByUniqueId) {\n        index = this._geometriesByUniqueId[geometry.uniqueId];\n\n        if (index === undefined) {\n          return false;\n        }\n      } else {\n        index = this.geometries.indexOf(geometry);\n\n        if (index < 0) {\n          return false;\n        }\n      }\n\n      if (index !== this.geometries.length - 1) {\n        var lastGeometry = this.geometries[this.geometries.length - 1];\n\n        if (lastGeometry) {\n          this.geometries[index] = lastGeometry;\n\n          if (this._geometriesByUniqueId) {\n            this._geometriesByUniqueId[lastGeometry.uniqueId] = index;\n          }\n        }\n      }\n\n      if (this._geometriesByUniqueId) {\n        this._geometriesByUniqueId[geometry.uniqueId] = undefined;\n      }\n\n      this.geometries.pop();\n      this.onGeometryRemovedObservable.notifyObservers(geometry);\n      return true;\n    }\n    /**\n     * Gets the list of geometries attached to the scene\n     * @returns an array of Geometry\n     */\n\n  }, {\n    key: \"getGeometries\",\n    value: function getGeometries() {\n      return this.geometries;\n    }\n    /**\n     * Gets the first added mesh found of a given Id\n     * @param id defines the Id to search for\n     * @returns the mesh found or null if not found at all\n     */\n\n  }, {\n    key: \"getMeshById\",\n    value: function getMeshById(id) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a list of meshes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of meshes\n     */\n\n  }, {\n    key: \"getMeshesById\",\n    value: function getMeshesById(id) {\n      return this.meshes.filter(function (m) {\n        return m.id === id;\n      });\n    }\n    /**\n     * Gets the first added transform node found of a given Id\n     * @param id defines the Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n\n  }, {\n    key: \"getTransformNodeById\",\n    value: function getTransformNodeById(id) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].id === id) {\n          return this.transformNodes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a transform node with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found transform node or null if not found at all.\n     */\n\n  }, {\n    key: \"getTransformNodeByUniqueId\",\n    value: function getTransformNodeByUniqueId(uniqueId) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].uniqueId === uniqueId) {\n          return this.transformNodes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a list of transform nodes using their Id\n     * @param id defines the Id to search for\n     * @returns a list of transform nodes\n     */\n\n  }, {\n    key: \"getTransformNodesById\",\n    value: function getTransformNodesById(id) {\n      return this.transformNodes.filter(function (m) {\n        return m.id === id;\n      });\n    }\n    /**\n     * Gets a mesh with its auto-generated unique Id\n     * @param uniqueId defines the unique Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n\n  }, {\n    key: \"getMeshByUniqueId\",\n    value: function getMeshByUniqueId(uniqueId) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].uniqueId === uniqueId) {\n          return this.meshes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a the last added mesh using a given Id\n     * @param id defines the Id to search for\n     * @returns the found mesh or null if not found at all.\n     */\n\n  }, {\n    key: \"getLastMeshById\",\n    value: function getLastMeshById(id) {\n      for (var index = this.meshes.length - 1; index >= 0; index--) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a the last added node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n\n  }, {\n    key: \"getLastEntryById\",\n    value: function getLastEntryById(id) {\n      var index;\n\n      for (index = this.meshes.length - 1; index >= 0; index--) {\n        if (this.meshes[index].id === id) {\n          return this.meshes[index];\n        }\n      }\n\n      for (index = this.transformNodes.length - 1; index >= 0; index--) {\n        if (this.transformNodes[index].id === id) {\n          return this.transformNodes[index];\n        }\n      }\n\n      for (index = this.cameras.length - 1; index >= 0; index--) {\n        if (this.cameras[index].id === id) {\n          return this.cameras[index];\n        }\n      }\n\n      for (index = this.lights.length - 1; index >= 0; index--) {\n        if (this.lights[index].id === id) {\n          return this.lights[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given Id\n     * @param id defines the Id to search for\n     * @returns the found node or null if not found at all\n     */\n\n  }, {\n    key: \"getNodeById\",\n    value: function getNodeById(id) {\n      var mesh = this.getMeshById(id);\n\n      if (mesh) {\n        return mesh;\n      }\n\n      var transformNode = this.getTransformNodeById(id);\n\n      if (transformNode) {\n        return transformNode;\n      }\n\n      var light = this.getLightById(id);\n\n      if (light) {\n        return light;\n      }\n\n      var camera = this.getCameraById(id);\n\n      if (camera) {\n        return camera;\n      }\n\n      var bone = this.getBoneById(id);\n\n      if (bone) {\n        return bone;\n      }\n\n      return null;\n    }\n    /**\n     * Gets a node (Mesh, Camera, Light) using a given name\n     * @param name defines the name to search for\n     * @returns the found node or null if not found at all.\n     */\n\n  }, {\n    key: \"getNodeByName\",\n    value: function getNodeByName(name) {\n      var mesh = this.getMeshByName(name);\n\n      if (mesh) {\n        return mesh;\n      }\n\n      var transformNode = this.getTransformNodeByName(name);\n\n      if (transformNode) {\n        return transformNode;\n      }\n\n      var light = this.getLightByName(name);\n\n      if (light) {\n        return light;\n      }\n\n      var camera = this.getCameraByName(name);\n\n      if (camera) {\n        return camera;\n      }\n\n      var bone = this.getBoneByName(name);\n\n      if (bone) {\n        return bone;\n      }\n\n      return null;\n    }\n    /**\n     * Gets a mesh using a given name\n     * @param name defines the name to search for\n     * @returns the found mesh or null if not found at all.\n     */\n\n  }, {\n    key: \"getMeshByName\",\n    value: function getMeshByName(name) {\n      for (var index = 0; index < this.meshes.length; index++) {\n        if (this.meshes[index].name === name) {\n          return this.meshes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a transform node using a given name\n     * @param name defines the name to search for\n     * @returns the found transform node or null if not found at all.\n     */\n\n  }, {\n    key: \"getTransformNodeByName\",\n    value: function getTransformNodeByName(name) {\n      for (var index = 0; index < this.transformNodes.length; index++) {\n        if (this.transformNodes[index].name === name) {\n          return this.transformNodes[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given Id (if many are found, this function will pick the last one)\n     * @param id defines the Id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n\n  }, {\n    key: \"getLastSkeletonById\",\n    value: function getLastSkeletonById(id) {\n      for (var index = this.skeletons.length - 1; index >= 0; index--) {\n        if (this.skeletons[index].id === id) {\n          return this.skeletons[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given auto generated unique id\n     * @param  uniqueId defines the unique id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n\n  }, {\n    key: \"getSkeletonByUniqueId\",\n    value: function getSkeletonByUniqueId(uniqueId) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].uniqueId === uniqueId) {\n          return this.skeletons[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n\n  }, {\n    key: \"getSkeletonById\",\n    value: function getSkeletonById(id) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].id === id) {\n          return this.skeletons[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a skeleton using a given name\n     * @param name defines the name to search for\n     * @returns the found skeleton or null if not found at all.\n     */\n\n  }, {\n    key: \"getSkeletonByName\",\n    value: function getSkeletonByName(name) {\n      for (var index = 0; index < this.skeletons.length; index++) {\n        if (this.skeletons[index].name === name) {\n          return this.skeletons[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)\n     * @param id defines the id to search for\n     * @returns the found morph target manager or null if not found at all.\n     */\n\n  }, {\n    key: \"getMorphTargetManagerById\",\n    value: function getMorphTargetManagerById(id) {\n      for (var index = 0; index < this.morphTargetManagers.length; index++) {\n        if (this.morphTargetManagers[index].uniqueId === id) {\n          return this.morphTargetManagers[index];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a morph target using a given id (if many are found, this function will pick the first one)\n     * @param id defines the id to search for\n     * @returns the found morph target or null if not found at all.\n     */\n\n  }, {\n    key: \"getMorphTargetById\",\n    value: function getMorphTargetById(id) {\n      for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n        var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n        for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n          var target = morphTargetManager.getTarget(index);\n\n          if (target.id === id) {\n            return target;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a morph target using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found morph target or null if not found at all.\n     */\n\n  }, {\n    key: \"getMorphTargetByName\",\n    value: function getMorphTargetByName(name) {\n      for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {\n        var morphTargetManager = this.morphTargetManagers[managerIndex];\n\n        for (var index = 0; index < morphTargetManager.numTargets; ++index) {\n          var target = morphTargetManager.getTarget(index);\n\n          if (target.name === name) {\n            return target;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a post process using a given name (if many are found, this function will pick the first one)\n     * @param name defines the name to search for\n     * @returns the found post process or null if not found at all.\n     */\n\n  }, {\n    key: \"getPostProcessByName\",\n    value: function getPostProcessByName(name) {\n      for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {\n        var postProcess = this.postProcesses[postProcessIndex];\n\n        if (postProcess.name === name) {\n          return postProcess;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Gets a boolean indicating if the given mesh is active\n     * @param mesh defines the mesh to look for\n     * @returns true if the mesh is in the active list\n     */\n\n  }, {\n    key: \"isActiveMesh\",\n    value: function isActiveMesh(mesh) {\n      return this._activeMeshes.indexOf(mesh) !== -1;\n    }\n    /**\n     * Return a unique id as a string which can serve as an identifier for the scene\n     */\n\n  }, {\n    key: \"uid\",\n    get: function get() {\n      if (!this._uid) {\n        this._uid = Tools.RandomId();\n      }\n\n      return this._uid;\n    }\n    /**\n     * Add an externally attached data from its key.\n     * This method call will fail and return false, if such key already exists.\n     * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.\n     * @param key the unique key that identifies the data\n     * @param data the data object to associate to the key for this Engine instance\n     * @returns true if no such key were already present and the data was added successfully, false otherwise\n     */\n\n  }, {\n    key: \"addExternalData\",\n    value: function addExternalData(key, data) {\n      if (!this._externalData) {\n        this._externalData = new StringDictionary();\n      }\n\n      return this._externalData.add(key, data);\n    }\n    /**\n     * Get an externally attached data from its key\n     * @param key the unique key that identifies the data\n     * @returns the associated data, if present (can be null), or undefined if not present\n     */\n\n  }, {\n    key: \"getExternalData\",\n    value: function getExternalData(key) {\n      if (!this._externalData) {\n        return null;\n      }\n\n      return this._externalData.get(key);\n    }\n    /**\n     * Get an externally attached data from its key, create it using a factory if it's not already present\n     * @param key the unique key that identifies the data\n     * @param factory the factory that will be called to create the instance if and only if it doesn't exists\n     * @returns the associated data, can be null if the factory returned null.\n     */\n\n  }, {\n    key: \"getOrAddExternalDataWithFactory\",\n    value: function getOrAddExternalDataWithFactory(key, factory) {\n      if (!this._externalData) {\n        this._externalData = new StringDictionary();\n      }\n\n      return this._externalData.getOrAddWithFactory(key, factory);\n    }\n    /**\n     * Remove an externally attached data from the Engine instance\n     * @param key the unique key that identifies the data\n     * @returns true if the data was successfully removed, false if it doesn't exist\n     */\n\n  }, {\n    key: \"removeExternalData\",\n    value: function removeExternalData(key) {\n      return this._externalData.remove(key);\n    }\n  }, {\n    key: \"_evaluateSubMesh\",\n    value: function _evaluateSubMesh(subMesh, mesh, initialMesh) {\n      if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {\n        var _iterator9 = _createForOfIteratorHelper(this._evaluateSubMeshStage),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var step = _step9.value;\n            step.action(mesh, subMesh);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        var material = subMesh.getMaterial();\n\n        if (material !== null && material !== undefined) {\n          // Render targets\n          if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {\n            if (this._processedMaterials.indexOf(material) === -1) {\n              this._processedMaterials.push(material);\n\n              this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());\n            }\n          } // Dispatch\n\n\n          this._renderingManager.dispatch(subMesh, mesh, material);\n        }\n      }\n    }\n    /**\n     * Clear the processed materials smart array preventing retention point in material dispose.\n     */\n\n  }, {\n    key: \"freeProcessedMaterials\",\n    value: function freeProcessedMaterials() {\n      this._processedMaterials.dispose();\n    }\n    /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups\n     * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance\n     * when disposing several meshes in a row or a hierarchy of meshes.\n     * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.\n     */\n\n  }, {\n    key: \"blockfreeActiveMeshesAndRenderingGroups\",\n    get: function get() {\n      return this._preventFreeActiveMeshesAndRenderingGroups;\n    },\n    set: function set(value) {\n      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {\n        return;\n      }\n\n      if (value) {\n        this.freeActiveMeshes();\n        this.freeRenderingGroups();\n      }\n\n      this._preventFreeActiveMeshesAndRenderingGroups = value;\n    }\n    /**\n     * Clear the active meshes smart array preventing retention point in mesh dispose.\n     */\n\n  }, {\n    key: \"freeActiveMeshes\",\n    value: function freeActiveMeshes() {\n      if (this.blockfreeActiveMeshesAndRenderingGroups) {\n        return;\n      }\n\n      this._activeMeshes.dispose();\n\n      if (this.activeCamera && this.activeCamera._activeMeshes) {\n        this.activeCamera._activeMeshes.dispose();\n      }\n\n      if (this.activeCameras) {\n        for (var i = 0; i < this.activeCameras.length; i++) {\n          var activeCamera = this.activeCameras[i];\n\n          if (activeCamera && activeCamera._activeMeshes) {\n            activeCamera._activeMeshes.dispose();\n          }\n        }\n      }\n    }\n    /**\n     * Clear the info related to rendering groups preventing retention points during dispose.\n     */\n\n  }, {\n    key: \"freeRenderingGroups\",\n    value: function freeRenderingGroups() {\n      if (this.blockfreeActiveMeshesAndRenderingGroups) {\n        return;\n      }\n\n      if (this._renderingManager) {\n        this._renderingManager.freeRenderingGroups();\n      }\n\n      if (this.textures) {\n        for (var i = 0; i < this.textures.length; i++) {\n          var texture = this.textures[i];\n\n          if (texture && texture.renderList) {\n            texture.freeRenderingGroups();\n          }\n        }\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_isInIntermediateRendering\",\n    value: function _isInIntermediateRendering() {\n      return this._intermediateRendering;\n    }\n    /**\n     * Use this function to stop evaluating active meshes. The current list will be keep alive between frames\n     * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped\n     * @param onSuccess optional success callback\n     * @param onError optional error callback\n     * @param freezeMeshes defines if meshes should be frozen (true by default)\n     * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"freezeActiveMeshes\",\n    value: function freezeActiveMeshes() {\n      var _this9 = this;\n\n      var skipEvaluateActiveMeshes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var onSuccess = arguments.length > 1 ? arguments[1] : undefined;\n      var onError = arguments.length > 2 ? arguments[2] : undefined;\n      var freezeMeshes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var keepFrustumCulling = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      this.executeWhenReady(function () {\n        if (!_this9.activeCamera) {\n          onError && onError(\"No active camera found\");\n          return;\n        }\n\n        if (!_this9._frustumPlanes) {\n          _this9.updateTransformMatrix();\n        }\n\n        _this9._evaluateActiveMeshes();\n\n        _this9._activeMeshesFrozen = true;\n        _this9._activeMeshesFrozenButKeepClipping = keepFrustumCulling;\n        _this9._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;\n\n        if (freezeMeshes) {\n          for (var index = 0; index < _this9._activeMeshes.length; index++) {\n            _this9._activeMeshes.data[index]._freeze();\n          }\n        }\n\n        onSuccess && onSuccess();\n      });\n      return this;\n    }\n    /**\n     * Use this function to restart evaluating active meshes on every frame\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"unfreezeActiveMeshes\",\n    value: function unfreezeActiveMeshes() {\n      for (var index = 0; index < this.meshes.length; index++) {\n        var mesh = this.meshes[index];\n\n        if (mesh._internalAbstractMeshDataInfo) {\n          mesh._internalAbstractMeshDataInfo._isActive = false;\n        }\n      }\n\n      for (var _index3 = 0; _index3 < this._activeMeshes.length; _index3++) {\n        this._activeMeshes.data[_index3]._unFreeze();\n      }\n\n      this._activeMeshesFrozen = false;\n      return this;\n    }\n  }, {\n    key: \"_executeActiveContainerCleanup\",\n    value: function _executeActiveContainerCleanup(container) {\n      var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;\n\n      if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {\n        return; // Do not execute in frozen mode\n      } // We need to ensure we are not in the rendering loop\n\n\n      this.onBeforeRenderObservable.addOnce(function () {\n        return container.dispose();\n      });\n    }\n  }, {\n    key: \"_evaluateActiveMeshes\",\n    value: function _evaluateActiveMeshes() {\n      if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {\n        if (this._activeMeshes.length > 0) {\n          var _this$activeCamera;\n\n          (_this$activeCamera = this.activeCamera) === null || _this$activeCamera === void 0 ? void 0 : _this$activeCamera._activeMeshes.reset();\n\n          this._activeMeshes.reset();\n\n          this._renderingManager.reset();\n\n          this._processedMaterials.reset();\n\n          this._activeParticleSystems.reset();\n\n          this._activeSkeletons.reset();\n\n          this._softwareSkinnedMeshes.reset();\n        }\n\n        return;\n      }\n\n      if (this._activeMeshesFrozen && this._activeMeshes.length) {\n        if (!this._skipEvaluateActiveMeshesCompletely) {\n          var _len = this._activeMeshes.length;\n\n          for (var i = 0; i < _len; i++) {\n            var mesh = this._activeMeshes.data[i];\n            mesh.computeWorldMatrix();\n          }\n        }\n\n        if (this._activeParticleSystems) {\n          var psLength = this._activeParticleSystems.length;\n\n          for (var _i = 0; _i < psLength; _i++) {\n            this._activeParticleSystems.data[_i].animate();\n          }\n        }\n\n        return;\n      }\n\n      if (!this.activeCamera) {\n        return;\n      }\n\n      this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);\n\n      this.activeCamera._activeMeshes.reset();\n\n      this._activeMeshes.reset();\n\n      this._renderingManager.reset();\n\n      this._processedMaterials.reset();\n\n      this._activeParticleSystems.reset();\n\n      this._activeSkeletons.reset();\n\n      this._softwareSkinnedMeshes.reset();\n\n      this._materialsRenderTargets.reset();\n\n      var _iterator10 = _createForOfIteratorHelper(this._beforeEvaluateActiveMeshStage),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step12 = _step10.value;\n\n          _step12.action();\n        } // Determine mesh candidates\n\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      var meshes = this.getActiveMeshCandidates(); // Check each mesh\n\n      var len = meshes.length;\n\n      for (var _i2 = 0; _i2 < len; _i2++) {\n        var _mesh = meshes.data[_i2];\n        _mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;\n\n        if (_mesh.isBlocked) {\n          continue;\n        }\n\n        this._totalVertices.addCount(_mesh.getTotalVertices(), false);\n\n        if (!_mesh.isReady() || !_mesh.isEnabled() || _mesh.scaling.hasAZeroComponent) {\n          continue;\n        }\n\n        _mesh.computeWorldMatrix(); // Intersections\n\n\n        if (_mesh.actionManager && _mesh.actionManager.hasSpecificTriggers2(12, 13)) {\n          this._meshesForIntersections.pushNoDuplicate(_mesh);\n        } // Switch to current LOD\n\n\n        var meshToRender = this.customLODSelector ? this.customLODSelector(_mesh, this.activeCamera) : _mesh.getLOD(this.activeCamera);\n        _mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;\n        _mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;\n\n        if (meshToRender === undefined || meshToRender === null) {\n          continue;\n        } // Compute world matrix if LOD is billboard\n\n\n        if (meshToRender !== _mesh && meshToRender.billboardMode !== 0) {\n          meshToRender.computeWorldMatrix();\n        }\n\n        _mesh._preActivate();\n\n        if (_mesh.isVisible && _mesh.visibility > 0 && (_mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || _mesh.alwaysSelectAsActiveMesh || _mesh.isInFrustum(this._frustumPlanes))) {\n          this._activeMeshes.push(_mesh);\n\n          this.activeCamera._activeMeshes.push(_mesh);\n\n          if (meshToRender !== _mesh) {\n            meshToRender._activate(this._renderId, false);\n          }\n\n          var _iterator11 = _createForOfIteratorHelper(this._preActiveMeshStage),\n              _step11;\n\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var step = _step11.value;\n              step.action(_mesh);\n            }\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n\n          if (_mesh._activate(this._renderId, false)) {\n            if (!_mesh.isAnInstance) {\n              meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;\n            } else {\n              if (_mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {\n                meshToRender = _mesh;\n              }\n            }\n\n            meshToRender._internalAbstractMeshDataInfo._isActive = true;\n\n            this._activeMesh(_mesh, meshToRender);\n          }\n\n          _mesh._postActivate();\n        }\n      }\n\n      this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this); // Particle systems\n\n      if (this.particlesEnabled) {\n        this.onBeforeParticlesRenderingObservable.notifyObservers(this);\n\n        for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {\n          var particleSystem = this.particleSystems[particleIndex];\n\n          if (!particleSystem.isStarted() || !particleSystem.emitter) {\n            continue;\n          }\n\n          var emitter = particleSystem.emitter;\n\n          if (!emitter.position || emitter.isEnabled()) {\n            this._activeParticleSystems.push(particleSystem);\n\n            particleSystem.animate();\n\n            this._renderingManager.dispatchParticles(particleSystem);\n          }\n        }\n\n        this.onAfterParticlesRenderingObservable.notifyObservers(this);\n      }\n    }\n  }, {\n    key: \"_activeMesh\",\n    value: function _activeMesh(sourceMesh, mesh) {\n      if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== undefined) {\n        if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {\n          mesh.skeleton.prepare();\n\n          this._activeBones.addCount(mesh.skeleton.bones.length, false);\n        }\n\n        if (!mesh.computeBonesUsingShaders) {\n          this._softwareSkinnedMeshes.pushNoDuplicate(mesh);\n        }\n      }\n\n      if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {\n        var subMeshes = this.getActiveSubMeshCandidates(mesh);\n        var len = subMeshes.length;\n\n        for (var i = 0; i < len; i++) {\n          var subMesh = subMeshes.data[i];\n\n          this._evaluateSubMesh(subMesh, mesh, sourceMesh);\n        }\n      }\n    }\n    /**\n     * Update the transform matrix to update from the current active camera\n     * @param force defines a boolean used to force the update even if cache is up to date\n     */\n\n  }, {\n    key: \"updateTransformMatrix\",\n    value: function updateTransformMatrix(force) {\n      if (!this.activeCamera) {\n        return;\n      }\n\n      if (this.activeCamera._renderingMultiview) {\n        var leftCamera = this.activeCamera._rigCameras[0];\n        var rightCamera = this.activeCamera._rigCameras[1];\n        this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));\n      } else {\n        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));\n      }\n    }\n  }, {\n    key: \"_bindFrameBuffer\",\n    value: function _bindFrameBuffer(camera) {\n      var clear = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (camera && camera._multiviewTexture) {\n        camera._multiviewTexture._bindFrameBuffer();\n      } else if (camera && camera.outputRenderTarget) {\n        camera.outputRenderTarget._bindFrameBuffer();\n      } else {\n        if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {\n          this._engine.restoreDefaultFramebuffer();\n        }\n      }\n\n      if (clear) {\n        this._clearFrameBuffer(camera);\n      }\n    }\n  }, {\n    key: \"_clearFrameBuffer\",\n    value: function _clearFrameBuffer(camera) {\n      // we assume the framebuffer currently bound is the right one\n      if (camera && camera._multiviewTexture) {// no clearing?\n      } else if (camera && camera.outputRenderTarget) {\n        var rtt = camera.outputRenderTarget;\n\n        if (rtt.onClearObservable.hasObservers()) {\n          rtt.onClearObservable.notifyObservers(this._engine);\n        } else if (!rtt.skipInitialClear) {\n          if (this.autoClear) {\n            this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);\n          }\n\n          rtt._cleared = true;\n        }\n      } else {\n        if (!this._defaultFrameBufferCleared) {\n          this._defaultFrameBufferCleared = true;\n\n          this._clear();\n        } else {\n          this._engine.clear(null, false, true, true);\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_renderForCamera\",\n    value: function _renderForCamera(camera, rigParent) {\n      var _ref, _camera$outputRenderT, _camera$outputRenderT2;\n\n      var bindFrameBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      if (camera && camera._skipRendering) {\n        return;\n      }\n\n      var engine = this._engine; // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n      this._activeCamera = camera;\n\n      if (!this.activeCamera) {\n        throw new Error(\"Active camera not set\");\n      } // Viewport\n\n\n      engine.setViewport(this.activeCamera.viewport); // Camera\n\n      this.resetCachedMaterial();\n      this._renderId++;\n\n      if (!this.prePass && bindFrameBuffer) {\n        var skipInitialClear = true;\n\n        if (camera._renderingMultiview && camera.outputRenderTarget) {\n          skipInitialClear = camera.outputRenderTarget.skipInitialClear;\n\n          if (this.autoClear) {\n            camera.outputRenderTarget.skipInitialClear = false;\n          }\n        }\n\n        this._bindFrameBuffer(this._activeCamera);\n\n        if (camera._renderingMultiview && camera.outputRenderTarget) {\n          camera.outputRenderTarget.skipInitialClear = skipInitialClear;\n        }\n      }\n\n      this.updateTransformMatrix();\n      this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera); // Meshes\n\n      this._evaluateActiveMeshes(); // Software skinning\n\n\n      for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {\n        var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];\n        mesh.applySkeleton(mesh.skeleton);\n      } // Render targets\n\n\n      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n\n      this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);\n\n      if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {\n        this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);\n      }\n\n      if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {\n        this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);\n      }\n\n      if (this.environmentTexture && this.environmentTexture.isRenderTarget) {\n        this._renderTargets.pushNoDuplicate(this.environmentTexture);\n      } // Collects render targets from external components.\n\n\n      var _iterator12 = _createForOfIteratorHelper(this._gatherActiveCameraRenderTargetsStage),\n          _step13;\n\n      try {\n        for (_iterator12.s(); !(_step13 = _iterator12.n()).done;) {\n          var _step17 = _step13.value;\n\n          _step17.action(this._renderTargets);\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      var needRebind = false;\n\n      if (this.renderTargetsEnabled) {\n        this._intermediateRendering = true;\n\n        if (this._renderTargets.length > 0) {\n          Tools.StartPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n\n          for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {\n            var renderTarget = this._renderTargets.data[renderIndex];\n\n            if (renderTarget._shouldRender()) {\n              this._renderId++;\n              var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;\n              renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);\n              needRebind = true;\n            }\n          }\n\n          Tools.EndPerformanceCounter(\"Render targets\", this._renderTargets.length > 0);\n          this._renderId++;\n        }\n\n        var _iterator13 = _createForOfIteratorHelper(this._cameraDrawRenderTargetStage),\n            _step14;\n\n        try {\n          for (_iterator13.s(); !(_step14 = _iterator13.n()).done;) {\n            var step = _step14.value;\n            needRebind = step.action(this.activeCamera) || needRebind;\n          }\n        } catch (err) {\n          _iterator13.e(err);\n        } finally {\n          _iterator13.f();\n        }\n\n        this._intermediateRendering = false;\n      }\n\n      this._engine.currentRenderPassId = (_ref = (_camera$outputRenderT = (_camera$outputRenderT2 = camera.outputRenderTarget) === null || _camera$outputRenderT2 === void 0 ? void 0 : _camera$outputRenderT2.renderPassId) !== null && _camera$outputRenderT !== void 0 ? _camera$outputRenderT : camera.renderPassId) !== null && _ref !== void 0 ? _ref : 0; // Restore framebuffer after rendering to targets\n\n      if (needRebind && !this.prePass) {\n        this._bindFrameBuffer(this._activeCamera, false);\n      }\n\n      this.onAfterRenderTargetsRenderObservable.notifyObservers(this); // Prepare Frame\n\n      if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {\n        this.postProcessManager._prepareFrame();\n      } // Before Camera Draw\n\n\n      var _iterator14 = _createForOfIteratorHelper(this._beforeCameraDrawStage),\n          _step15;\n\n      try {\n        for (_iterator14.s(); !(_step15 = _iterator14.n()).done;) {\n          var _step18 = _step15.value;\n\n          _step18.action(this.activeCamera);\n        } // Render\n\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      this.onBeforeDrawPhaseObservable.notifyObservers(this);\n\n      if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {\n        this.finalizeSceneUbo();\n      }\n\n      this._renderingManager.render(null, null, true, true);\n\n      this.onAfterDrawPhaseObservable.notifyObservers(this); // After Camera Draw\n\n      var _iterator15 = _createForOfIteratorHelper(this._afterCameraDrawStage),\n          _step16;\n\n      try {\n        for (_iterator15.s(); !(_step16 = _iterator15.n()).done;) {\n          var _step19 = _step16.value;\n\n          _step19.action(this.activeCamera);\n        } // Finalize frame\n\n      } catch (err) {\n        _iterator15.e(err);\n      } finally {\n        _iterator15.f();\n      }\n\n      if (this.postProcessManager && !camera._multiviewTexture) {\n        // if the camera has an output render target, render the post process to the render target\n        var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : undefined;\n\n        this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);\n      } // Reset some special arrays\n\n\n      this._renderTargets.reset();\n\n      this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);\n    }\n  }, {\n    key: \"_processSubCameras\",\n    value: function _processSubCameras(camera) {\n      var bindFrameBuffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (camera.cameraRigMode === 0 || camera._renderingMultiview) {\n        if (camera._renderingMultiview && !this._multiviewSceneUbo) {\n          this._createMultiviewUbo();\n        }\n\n        this._renderForCamera(camera, undefined, bindFrameBuffer);\n\n        this.onAfterRenderCameraObservable.notifyObservers(camera);\n        return;\n      }\n\n      if (camera._useMultiviewToSingleView) {\n        this._renderMultiviewToSingleView(camera);\n      } else {\n        // rig cameras\n        this.onBeforeCameraRenderObservable.notifyObservers(camera);\n\n        for (var index = 0; index < camera._rigCameras.length; index++) {\n          this._renderForCamera(camera._rigCameras[index], camera);\n        }\n      } // Use _activeCamera instead of activeCamera to avoid onActiveCameraChanged\n\n\n      this._activeCamera = camera;\n      this.updateTransformMatrix();\n      this.onAfterRenderCameraObservable.notifyObservers(camera);\n    }\n  }, {\n    key: \"_checkIntersections\",\n    value: function _checkIntersections() {\n      for (var index = 0; index < this._meshesForIntersections.length; index++) {\n        var sourceMesh = this._meshesForIntersections.data[index];\n\n        if (!sourceMesh.actionManager) {\n          continue;\n        }\n\n        for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {\n          var action = sourceMesh.actionManager.actions[actionIndex];\n\n          if (action.trigger === 12 || action.trigger === 13) {\n            (function () {\n              var parameters = action.getTriggerParameter();\n              var otherMesh = parameters.mesh ? parameters.mesh : parameters;\n              var areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);\n\n              var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);\n\n              if (areIntersecting && currentIntersectionInProgress === -1) {\n                if (action.trigger === 12) {\n                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n\n                  sourceMesh._intersectionsInProgress.push(otherMesh);\n                } else if (action.trigger === 13) {\n                  sourceMesh._intersectionsInProgress.push(otherMesh);\n                }\n              } else if (!areIntersecting && currentIntersectionInProgress > -1) {\n                //They intersected, and now they don't.\n                //is this trigger an exit trigger? execute an event.\n                if (action.trigger === 13) {\n                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, undefined, otherMesh));\n                } //if this is an exit trigger, or no exit trigger exists, remove the id from the intersection in progress array.\n\n\n                if (!sourceMesh.actionManager.hasSpecificTrigger(13, function (parameter) {\n                  var parameterMesh = parameter.mesh ? parameter.mesh : parameter;\n                  return otherMesh === parameterMesh;\n                }) || action.trigger === 13) {\n                  sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);\n                }\n              }\n            })();\n          }\n        }\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_advancePhysicsEngineStep\",\n    value: function _advancePhysicsEngineStep(step) {// Do nothing. Code will be replaced if physics engine component is referenced\n    }\n    /** @internal */\n\n  }, {\n    key: \"_animate\",\n    value: function _animate() {// Nothing to do as long as Animatable have not been imported.\n    }\n    /** Execute all animations (for a frame) */\n\n  }, {\n    key: \"animate\",\n    value: function animate() {\n      if (this._engine.isDeterministicLockStep()) {\n        var deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;\n\n        var defaultFrameTime = this._engine.getTimeStep();\n\n        var defaultFPS = 1000.0 / defaultFrameTime / 1000.0;\n        var stepsTaken = 0;\n\n        var maxSubSteps = this._engine.getLockstepMaxSteps();\n\n        var internalSteps = Math.floor(deltaTime / defaultFrameTime);\n        internalSteps = Math.min(internalSteps, maxSubSteps);\n\n        while (deltaTime > 0 && stepsTaken < internalSteps) {\n          this.onBeforeStepObservable.notifyObservers(this); // Animations\n\n          this._animationRatio = defaultFrameTime * defaultFPS;\n\n          this._animate();\n\n          this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n          if (this.physicsEnabled) {\n            this._advancePhysicsEngineStep(defaultFrameTime);\n          }\n\n          this.onAfterStepObservable.notifyObservers(this);\n          this._currentStepId++;\n          stepsTaken++;\n          deltaTime -= defaultFrameTime;\n        }\n\n        this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;\n      } else {\n        // Animations\n        var _deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));\n\n        this._animationRatio = _deltaTime * (60.0 / 1000.0);\n\n        this._animate();\n\n        this.onAfterAnimationsObservable.notifyObservers(this); // Physics\n\n        if (this.physicsEnabled) {\n          this._advancePhysicsEngineStep(_deltaTime);\n        }\n      }\n    }\n  }, {\n    key: \"_clear\",\n    value: function _clear() {\n      if (this.autoClearDepthAndStencil || this.autoClear) {\n        this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);\n      }\n    }\n  }, {\n    key: \"_checkCameraRenderTarget\",\n    value: function _checkCameraRenderTarget(camera) {\n      var _camera$rigCameras;\n\n      if (camera !== null && camera !== void 0 && camera.outputRenderTarget && !(camera !== null && camera !== void 0 && camera.isRigCamera)) {\n        camera.outputRenderTarget._cleared = false;\n      }\n\n      if (camera !== null && camera !== void 0 && (_camera$rigCameras = camera.rigCameras) !== null && _camera$rigCameras !== void 0 && _camera$rigCameras.length) {\n        for (var i = 0; i < camera.rigCameras.length; ++i) {\n          var rtt = camera.rigCameras[i].outputRenderTarget;\n\n          if (rtt) {\n            rtt._cleared = false;\n          }\n        }\n      }\n    }\n    /**\n     * Resets the draw wrappers cache of all meshes\n     * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n     */\n\n  }, {\n    key: \"resetDrawCache\",\n    value: function resetDrawCache(passId) {\n      if (!this.meshes) {\n        return;\n      }\n\n      var _iterator16 = _createForOfIteratorHelper(this.meshes),\n          _step20;\n\n      try {\n        for (_iterator16.s(); !(_step20 = _iterator16.n()).done;) {\n          var mesh = _step20.value;\n          mesh.resetDrawCache(passId);\n        }\n      } catch (err) {\n        _iterator16.e(err);\n      } finally {\n        _iterator16.f();\n      }\n    }\n    /**\n     * Render the scene\n     * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)\n     * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$activeCameras, _this$activeCameras2, _currentActiveCamera$;\n\n      var updateCameras = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var ignoreAnimations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.isDisposed) {\n        return;\n      }\n\n      if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {\n        this._checkIsReady();\n      }\n\n      this._frameId++;\n      this._defaultFrameBufferCleared = false;\n\n      this._checkCameraRenderTarget(this.activeCamera);\n\n      if ((_this$activeCameras = this.activeCameras) !== null && _this$activeCameras !== void 0 && _this$activeCameras.length) {\n        this.activeCameras.forEach(this._checkCameraRenderTarget);\n      } // Register components that have been associated lately to the scene.\n\n\n      this._registerTransientComponents();\n\n      this._activeParticles.fetchNewFrame();\n\n      this._totalVertices.fetchNewFrame();\n\n      this._activeIndices.fetchNewFrame();\n\n      this._activeBones.fetchNewFrame();\n\n      this._meshesForIntersections.reset();\n\n      this.resetCachedMaterial();\n      this.onBeforeAnimationsObservable.notifyObservers(this); // Actions\n\n      if (this.actionManager) {\n        this.actionManager.processTrigger(11);\n      } // Animations\n\n\n      if (!ignoreAnimations) {\n        this.animate();\n      } // Before camera update steps\n\n\n      var _iterator17 = _createForOfIteratorHelper(this._beforeCameraUpdateStage),\n          _step21;\n\n      try {\n        for (_iterator17.s(); !(_step21 = _iterator17.n()).done;) {\n          var step = _step21.value;\n          step.action();\n        } // Update Cameras\n\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      if (updateCameras) {\n        if (this.activeCameras && this.activeCameras.length > 0) {\n          for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {\n            var camera = this.activeCameras[cameraIndex];\n            camera.update();\n\n            if (camera.cameraRigMode !== 0) {\n              // rig cameras\n              for (var index = 0; index < camera._rigCameras.length; index++) {\n                camera._rigCameras[index].update();\n              }\n            }\n          }\n        } else if (this.activeCamera) {\n          this.activeCamera.update();\n\n          if (this.activeCamera.cameraRigMode !== 0) {\n            // rig cameras\n            for (var _index4 = 0; _index4 < this.activeCamera._rigCameras.length; _index4++) {\n              this.activeCamera._rigCameras[_index4].update();\n            }\n          }\n        }\n      } // Before render\n\n\n      this.onBeforeRenderObservable.notifyObservers(this);\n      var engine = this.getEngine(); // Customs render targets\n\n      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);\n      var currentActiveCamera = (_this$activeCameras2 = this.activeCameras) !== null && _this$activeCameras2 !== void 0 && _this$activeCameras2.length ? this.activeCameras[0] : this.activeCamera;\n\n      if (this.renderTargetsEnabled) {\n        Tools.StartPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n        this._intermediateRendering = true;\n\n        for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {\n          var renderTarget = this.customRenderTargets[customIndex];\n\n          if (renderTarget._shouldRender()) {\n            this._renderId++;\n            this.activeCamera = renderTarget.activeCamera || this.activeCamera;\n\n            if (!this.activeCamera) {\n              throw new Error(\"Active camera not set\");\n            } // Viewport\n\n\n            engine.setViewport(this.activeCamera.viewport); // Camera\n\n            this.updateTransformMatrix();\n            renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);\n          }\n        }\n\n        Tools.EndPerformanceCounter(\"Custom render targets\", this.customRenderTargets.length > 0);\n        this._intermediateRendering = false;\n        this._renderId++;\n      }\n\n      this._engine.currentRenderPassId = (_currentActiveCamera$ = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _currentActiveCamera$ !== void 0 ? _currentActiveCamera$ : 0; // Restore back buffer\n\n      this.activeCamera = currentActiveCamera;\n\n      if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {\n        this._bindFrameBuffer(this._activeCamera, false);\n      }\n\n      this.onAfterRenderTargetsRenderObservable.notifyObservers(this);\n\n      var _iterator18 = _createForOfIteratorHelper(this._beforeClearStage),\n          _step22;\n\n      try {\n        for (_iterator18.s(); !(_step22 = _iterator18.n()).done;) {\n          var _step25 = _step22.value;\n\n          _step25.action();\n        } // Clear\n\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      this._clearFrameBuffer(this.activeCamera); // Collects render targets from external components.\n\n\n      var _iterator19 = _createForOfIteratorHelper(this._gatherRenderTargetsStage),\n          _step23;\n\n      try {\n        for (_iterator19.s(); !(_step23 = _iterator19.n()).done;) {\n          var _step26 = _step23.value;\n\n          _step26.action(this._renderTargets);\n        } // Multi-cameras?\n        // save current active camera, following calls will change it, discarding user settings\n\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      var activeCamera = this._activeCamera;\n\n      if (this.activeCameras && this.activeCameras.length > 0) {\n        for (var _cameraIndex = 0; _cameraIndex < this.activeCameras.length; _cameraIndex++) {\n          this._processSubCameras(this.activeCameras[_cameraIndex], _cameraIndex > 0);\n        }\n      } else {\n        if (!this.activeCamera) {\n          throw new Error(\"No camera defined\");\n        }\n\n        this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);\n      }\n\n      this._activeCamera = activeCamera; // Intersection checks\n\n      this._checkIntersections(); // Executes the after render stage actions.\n\n\n      var _iterator20 = _createForOfIteratorHelper(this._afterRenderStage),\n          _step24;\n\n      try {\n        for (_iterator20.s(); !(_step24 = _iterator20.n()).done;) {\n          var _step27 = _step24.value;\n\n          _step27.action();\n        } // After render\n\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      if (this.afterRender) {\n        this.afterRender();\n      }\n\n      this.onAfterRenderObservable.notifyObservers(this); // Cleaning\n\n      if (this._toBeDisposed.length) {\n        for (var _index5 = 0; _index5 < this._toBeDisposed.length; _index5++) {\n          var data = this._toBeDisposed[_index5];\n\n          if (data) {\n            data.dispose();\n          }\n        }\n\n        this._toBeDisposed.length = 0;\n      }\n\n      if (this.dumpNextRenderTargets) {\n        this.dumpNextRenderTargets = false;\n      }\n\n      this._activeBones.addCount(0, true);\n\n      this._activeIndices.addCount(0, true);\n\n      this._activeParticles.addCount(0, true);\n\n      this._engine.restoreDefaultFramebuffer();\n    }\n    /**\n     * Freeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n\n  }, {\n    key: \"freezeMaterials\",\n    value: function freezeMaterials() {\n      for (var i = 0; i < this.materials.length; i++) {\n        this.materials[i].freeze();\n      }\n    }\n    /**\n     * Unfreeze all materials\n     * A frozen material will not be updatable but should be faster to render\n     */\n\n  }, {\n    key: \"unfreezeMaterials\",\n    value: function unfreezeMaterials() {\n      for (var i = 0; i < this.materials.length; i++) {\n        this.materials[i].unfreeze();\n      }\n    }\n    /**\n     * Releases all held resources\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this$_computePressur;\n\n      if (this.isDisposed) {\n        return;\n      }\n\n      this.beforeRender = null;\n      this.afterRender = null;\n      this.metadata = null;\n      this.skeletons.length = 0;\n      this.morphTargetManagers.length = 0;\n      this._transientComponents.length = 0;\n\n      this._isReadyForMeshStage.clear();\n\n      this._beforeEvaluateActiveMeshStage.clear();\n\n      this._evaluateSubMeshStage.clear();\n\n      this._preActiveMeshStage.clear();\n\n      this._cameraDrawRenderTargetStage.clear();\n\n      this._beforeCameraDrawStage.clear();\n\n      this._beforeRenderTargetDrawStage.clear();\n\n      this._beforeRenderingGroupDrawStage.clear();\n\n      this._beforeRenderingMeshStage.clear();\n\n      this._afterRenderingMeshStage.clear();\n\n      this._afterRenderingGroupDrawStage.clear();\n\n      this._afterCameraDrawStage.clear();\n\n      this._afterRenderTargetDrawStage.clear();\n\n      this._afterRenderStage.clear();\n\n      this._beforeCameraUpdateStage.clear();\n\n      this._beforeClearStage.clear();\n\n      this._gatherRenderTargetsStage.clear();\n\n      this._gatherActiveCameraRenderTargetsStage.clear();\n\n      this._pointerMoveStage.clear();\n\n      this._pointerDownStage.clear();\n\n      this._pointerUpStage.clear();\n\n      this.importedMeshesFiles = new Array();\n\n      if (this.stopAllAnimations) {\n        this.stopAllAnimations();\n      }\n\n      this.resetCachedMaterial(); // Smart arrays\n\n      if (this.activeCamera) {\n        this.activeCamera._activeMeshes.dispose();\n\n        this.activeCamera = null;\n      }\n\n      this.activeCameras = null;\n\n      this._activeMeshes.dispose();\n\n      this._renderingManager.dispose();\n\n      this._processedMaterials.dispose();\n\n      this._activeParticleSystems.dispose();\n\n      this._activeSkeletons.dispose();\n\n      this._softwareSkinnedMeshes.dispose();\n\n      this._renderTargets.dispose();\n\n      this._materialsRenderTargets.dispose();\n\n      this._registeredForLateAnimationBindings.dispose();\n\n      this._meshesForIntersections.dispose();\n\n      this._toBeDisposed.length = 0; // Abort active requests\n\n      var activeRequests = this._activeRequests.slice();\n\n      var _iterator21 = _createForOfIteratorHelper(activeRequests),\n          _step28;\n\n      try {\n        for (_iterator21.s(); !(_step28 = _iterator21.n()).done;) {\n          var request = _step28.value;\n          request.abort();\n        }\n      } catch (err) {\n        _iterator21.e(err);\n      } finally {\n        _iterator21.f();\n      }\n\n      this._activeRequests.length = 0; // Events\n\n      this.onDisposeObservable.notifyObservers(this);\n      this.onDisposeObservable.clear();\n      this.onBeforeRenderObservable.clear();\n      this.onAfterRenderObservable.clear();\n      this.onBeforeRenderTargetsRenderObservable.clear();\n      this.onAfterRenderTargetsRenderObservable.clear();\n      this.onAfterStepObservable.clear();\n      this.onBeforeStepObservable.clear();\n      this.onBeforeActiveMeshesEvaluationObservable.clear();\n      this.onAfterActiveMeshesEvaluationObservable.clear();\n      this.onBeforeParticlesRenderingObservable.clear();\n      this.onAfterParticlesRenderingObservable.clear();\n      this.onBeforeDrawPhaseObservable.clear();\n      this.onAfterDrawPhaseObservable.clear();\n      this.onBeforeAnimationsObservable.clear();\n      this.onAfterAnimationsObservable.clear();\n      this.onDataLoadedObservable.clear();\n      this.onBeforeRenderingGroupObservable.clear();\n      this.onAfterRenderingGroupObservable.clear();\n      this.onMeshImportedObservable.clear();\n      this.onBeforeCameraRenderObservable.clear();\n      this.onAfterCameraRenderObservable.clear();\n      this.onReadyObservable.clear();\n      this.onNewCameraAddedObservable.clear();\n      this.onCameraRemovedObservable.clear();\n      this.onNewLightAddedObservable.clear();\n      this.onLightRemovedObservable.clear();\n      this.onNewGeometryAddedObservable.clear();\n      this.onGeometryRemovedObservable.clear();\n      this.onNewTransformNodeAddedObservable.clear();\n      this.onTransformNodeRemovedObservable.clear();\n      this.onNewMeshAddedObservable.clear();\n      this.onMeshRemovedObservable.clear();\n      this.onNewSkeletonAddedObservable.clear();\n      this.onSkeletonRemovedObservable.clear();\n      this.onNewMaterialAddedObservable.clear();\n      this.onNewMultiMaterialAddedObservable.clear();\n      this.onMaterialRemovedObservable.clear();\n      this.onMultiMaterialRemovedObservable.clear();\n      this.onNewTextureAddedObservable.clear();\n      this.onTextureRemovedObservable.clear();\n      this.onPrePointerObservable.clear();\n      this.onPointerObservable.clear();\n      this.onPreKeyboardObservable.clear();\n      this.onKeyboardObservable.clear();\n      this.onActiveCameraChanged.clear();\n      this.onComputePressureChanged.clear();\n      (_this$_computePressur = this._computePressureObserver) === null || _this$_computePressur === void 0 ? void 0 : _this$_computePressur.unobserve(\"cpu\");\n      this._computePressureObserver = undefined;\n      this.detachControl(); // Detach cameras\n\n      var canvas = this._engine.getInputElement();\n\n      if (canvas) {\n        for (var _index6 = 0; _index6 < this.cameras.length; _index6++) {\n          this.cameras[_index6].detachControl();\n        }\n      } // Release animation groups\n\n\n      this._disposeList(this.animationGroups); // Release lights\n\n\n      this._disposeList(this.lights); // Release meshes\n\n\n      this._disposeList(this.meshes, function (item) {\n        return item.dispose(true);\n      });\n\n      this._disposeList(this.transformNodes, function (item) {\n        return item.dispose(true);\n      }); // Release cameras\n\n\n      var cameras = this.cameras;\n\n      this._disposeList(cameras); // Release materials\n\n\n      if (this._defaultMaterial) {\n        this._defaultMaterial.dispose();\n      }\n\n      this._disposeList(this.multiMaterials);\n\n      this._disposeList(this.materials); // Release particles\n\n\n      this._disposeList(this.particleSystems); // Release postProcesses\n\n\n      this._disposeList(this.postProcesses); // Release textures\n\n\n      this._disposeList(this.textures); // Release morph targets\n\n\n      this._disposeList(this.morphTargetManagers); // Release UBO\n\n\n      this._sceneUbo.dispose();\n\n      if (this._multiviewSceneUbo) {\n        this._multiviewSceneUbo.dispose();\n      } // Post-processes\n\n\n      this.postProcessManager.dispose(); // Components\n\n      this._disposeList(this._components); // Remove from engine\n\n\n      var index = this._engine.scenes.indexOf(this);\n\n      if (index > -1) {\n        this._engine.scenes.splice(index, 1);\n      }\n\n      if (EngineStore._LastCreatedScene === this) {\n        if (this._engine.scenes.length > 0) {\n          EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];\n        } else {\n          EngineStore._LastCreatedScene = null;\n        }\n      }\n\n      index = this._engine._virtualScenes.indexOf(this);\n\n      if (index > -1) {\n        this._engine._virtualScenes.splice(index, 1);\n      }\n\n      this._engine.wipeCaches(true);\n\n      this._isDisposed = true;\n    }\n  }, {\n    key: \"_disposeList\",\n    value: function _disposeList(items, callback) {\n      var _callback;\n\n      var itemsCopy = items.slice(0);\n      callback = (_callback = callback) !== null && _callback !== void 0 ? _callback : function (item) {\n        return item.dispose();\n      };\n\n      var _iterator22 = _createForOfIteratorHelper(itemsCopy),\n          _step29;\n\n      try {\n        for (_iterator22.s(); !(_step29 = _iterator22.n()).done;) {\n          var item = _step29.value;\n          callback(item);\n        }\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      items.length = 0;\n    }\n    /**\n     * Gets if the scene is already disposed\n     */\n\n  }, {\n    key: \"isDisposed\",\n    get: function get() {\n      return this._isDisposed;\n    }\n    /**\n     * Call this function to reduce memory footprint of the scene.\n     * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)\n     */\n\n  }, {\n    key: \"clearCachedVertexData\",\n    value: function clearCachedVertexData() {\n      for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {\n        var mesh = this.meshes[meshIndex];\n        var geometry = mesh.geometry;\n\n        if (geometry) {\n          geometry.clearCachedData();\n        }\n      }\n    }\n    /**\n     * This function will remove the local cached buffer data from texture.\n     * It will save memory but will prevent the texture from being rebuilt\n     */\n\n  }, {\n    key: \"cleanCachedTextureBuffer\",\n    value: function cleanCachedTextureBuffer() {\n      var _iterator23 = _createForOfIteratorHelper(this.textures),\n          _step30;\n\n      try {\n        for (_iterator23.s(); !(_step30 = _iterator23.n()).done;) {\n          var baseTexture = _step30.value;\n          var buffer = baseTexture._buffer;\n\n          if (buffer) {\n            baseTexture._buffer = null;\n          }\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n    }\n    /**\n     * Get the world extend vectors with an optional filter\n     *\n     * @param filterPredicate the predicate - which meshes should be included when calculating the world size\n     * @returns {{ min: Vector3; max: Vector3 }} min and max vectors\n     */\n\n  }, {\n    key: \"getWorldExtends\",\n    value: function getWorldExtends(filterPredicate) {\n      var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n      var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\n      filterPredicate = filterPredicate || function () {\n        return true;\n      };\n\n      this.meshes.filter(filterPredicate).forEach(function (mesh) {\n        mesh.computeWorldMatrix(true);\n\n        if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {\n          return;\n        }\n\n        var boundingInfo = mesh.getBoundingInfo();\n        var minBox = boundingInfo.boundingBox.minimumWorld;\n        var maxBox = boundingInfo.boundingBox.maximumWorld;\n        Vector3.CheckExtends(minBox, min, max);\n        Vector3.CheckExtends(maxBox, min, max);\n      });\n      return {\n        min: min,\n        max: max\n      };\n    } // Picking\n\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @returns a Ray\n     */\n\n  }, {\n    key: \"createPickingRay\",\n    value: function createPickingRay(x, y, world, camera) {\n      var cameraViewSpace = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @param cameraViewSpace defines if picking will be done in view space (false by default)\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"createPickingRayToRef\",\n    value: function createPickingRayToRef(x, y, world, result, camera) {\n      var cameraViewSpace = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      var enableDistantPicking = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param camera defines the camera to use for the picking\n     * @returns a Ray\n     */\n\n  }, {\n    key: \"createPickingRayInCameraSpace\",\n    value: function createPickingRayInCameraSpace(x, y, camera) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Creates a ray that can be used to pick in the scene\n     * @param x defines the x coordinate of the origin (on-screen)\n     * @param y defines the y coordinate of the origin (on-screen)\n     * @param result defines the ray where to store the picking ray\n     * @param camera defines the camera to use for the picking\n     * @returns the current scene\n     */\n\n  }, {\n    key: \"createPickingRayInCameraSpaceToRef\",\n    value: function createPickingRayInCameraSpaceToRef(x, y, result, camera) {\n      throw _WarnImport(\"Ray\");\n    }\n    /** Launch a ray to try to pick a mesh in the scene\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n\n  }, {\n    key: \"pick\",\n    value: function pick(x, y, predicate, fastCheck, camera, trianglePredicate) {\n      // Dummy info if picking as not been imported\n      var pi = new PickingInfo();\n      pi._pickingUnavailable = true;\n      return pi;\n    }\n    /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n     * @param x position on screen\n     * @param y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n     */\n\n  }, {\n    key: \"pickWithBoundingInfo\",\n    value: function pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {\n      // Dummy info if picking as not been imported\n      var pi = new PickingInfo();\n      pi._pickingUnavailable = true;\n      return pi;\n    }\n    /** Use the given ray to pick a mesh in the scene\n     * @param ray The ray to use to pick meshes\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns a PickingInfo\n     */\n\n  }, {\n    key: \"pickWithRay\",\n    value: function pickWithRay(ray, predicate, fastCheck, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param x X position on screen\n     * @param y Y position on screen\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n\n  }, {\n    key: \"multiPick\",\n    value: function multiPick(x, y, predicate, camera, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Launch a ray to try to pick a mesh in the scene\n     * @param ray Ray to use\n     * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @returns an array of PickingInfo\n     */\n\n  }, {\n    key: \"multiPickWithRay\",\n    value: function multiPickWithRay(ray, predicate, trianglePredicate) {\n      throw _WarnImport(\"Ray\");\n    }\n    /**\n     * Force the value of meshUnderPointer\n     * @param mesh defines the mesh to use\n     * @param pointerId optional pointer id when using more than one pointer\n     * @param pickResult optional pickingInfo data used to find mesh\n     */\n\n  }, {\n    key: \"setPointerOverMesh\",\n    value: function setPointerOverMesh(mesh, pointerId, pickResult) {\n      this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);\n    }\n    /**\n     * Gets the mesh under the pointer\n     * @returns a Mesh or null if no mesh is under the pointer\n     */\n\n  }, {\n    key: \"getPointerOverMesh\",\n    value: function getPointerOverMesh() {\n      return this._inputManager.getPointerOverMesh();\n    } // Misc.\n\n    /** @internal */\n\n  }, {\n    key: \"_rebuildGeometries\",\n    value: function _rebuildGeometries() {\n      var _iterator24 = _createForOfIteratorHelper(this.geometries),\n          _step31;\n\n      try {\n        for (_iterator24.s(); !(_step31 = _iterator24.n()).done;) {\n          var geometry = _step31.value;\n\n          geometry._rebuild();\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n\n      var _iterator25 = _createForOfIteratorHelper(this.meshes),\n          _step32;\n\n      try {\n        for (_iterator25.s(); !(_step32 = _iterator25.n()).done;) {\n          var mesh = _step32.value;\n\n          mesh._rebuild();\n        }\n      } catch (err) {\n        _iterator25.e(err);\n      } finally {\n        _iterator25.f();\n      }\n\n      if (this.postProcessManager) {\n        this.postProcessManager._rebuild();\n      }\n\n      var _iterator26 = _createForOfIteratorHelper(this._components),\n          _step33;\n\n      try {\n        for (_iterator26.s(); !(_step33 = _iterator26.n()).done;) {\n          var component = _step33.value;\n          component.rebuild();\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n\n      var _iterator27 = _createForOfIteratorHelper(this.particleSystems),\n          _step34;\n\n      try {\n        for (_iterator27.s(); !(_step34 = _iterator27.n()).done;) {\n          var system = _step34.value;\n          system.rebuild();\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      if (this.spriteManagers) {\n        var _iterator28 = _createForOfIteratorHelper(this.spriteManagers),\n            _step35;\n\n        try {\n          for (_iterator28.s(); !(_step35 = _iterator28.n()).done;) {\n            var spriteMgr = _step35.value;\n            spriteMgr.rebuild();\n          }\n        } catch (err) {\n          _iterator28.e(err);\n        } finally {\n          _iterator28.f();\n        }\n      }\n    }\n    /** @internal */\n\n  }, {\n    key: \"_rebuildTextures\",\n    value: function _rebuildTextures() {\n      var _iterator29 = _createForOfIteratorHelper(this.textures),\n          _step36;\n\n      try {\n        for (_iterator29.s(); !(_step36 = _iterator29.n()).done;) {\n          var texture = _step36.value;\n\n          texture._rebuild();\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      this.markAllMaterialsAsDirty(1);\n    } // Tags\n\n  }, {\n    key: \"_getByTags\",\n    value: function _getByTags(list, tagsQuery, forEach) {\n      if (tagsQuery === undefined) {\n        // returns the complete list (could be done with Tags.MatchesQuery but no need to have a for-loop here)\n        return list;\n      }\n\n      var listByTags = [];\n\n      forEach = forEach || function (item) {\n        return;\n      };\n\n      for (var i in list) {\n        var item = list[i];\n\n        if (Tags && Tags.MatchesQuery(item, tagsQuery)) {\n          listByTags.push(item);\n          forEach(item);\n        }\n      }\n\n      return listByTags;\n    }\n    /**\n     * Get a list of meshes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Mesh\n     */\n\n  }, {\n    key: \"getMeshesByTags\",\n    value: function getMeshesByTags(tagsQuery, forEach) {\n      return this._getByTags(this.meshes, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of cameras by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Camera\n     */\n\n  }, {\n    key: \"getCamerasByTags\",\n    value: function getCamerasByTags(tagsQuery, forEach) {\n      return this._getByTags(this.cameras, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of lights by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Light\n     */\n\n  }, {\n    key: \"getLightsByTags\",\n    value: function getLightsByTags(tagsQuery, forEach) {\n      return this._getByTags(this.lights, tagsQuery, forEach);\n    }\n    /**\n     * Get a list of materials by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of Material\n     */\n\n  }, {\n    key: \"getMaterialByTags\",\n    value: function getMaterialByTags(tagsQuery, forEach) {\n      return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));\n    }\n    /**\n     * Get a list of transform nodes by tags\n     * @param tagsQuery defines the tags query to use\n     * @param forEach defines a predicate used to filter results\n     * @returns an array of TransformNode\n     */\n\n  }, {\n    key: \"getTransformNodesByTags\",\n    value: function getTransformNodesByTags(tagsQuery, forEach) {\n      return this._getByTags(this.transformNodes, tagsQuery, forEach);\n    }\n    /**\n     * Overrides the default sort function applied in the rendering group to prepare the meshes.\n     * This allowed control for front to back rendering or reversly depending of the special needs.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param opaqueSortCompareFn The opaque queue comparison function use to sort.\n     * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.\n     * @param transparentSortCompareFn The transparent queue comparison function use to sort.\n     */\n\n  }, {\n    key: \"setRenderingOrder\",\n    value: function setRenderingOrder(renderingGroupId) {\n      var opaqueSortCompareFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var alphaTestSortCompareFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var transparentSortCompareFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n      this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);\n    }\n    /**\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.\n     *\n     * @param renderingGroupId The rendering group id corresponding to its index\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\n     * @param depth Automatically clears depth between groups if true and autoClear is true.\n     * @param stencil Automatically clears stencil between groups if true and autoClear is true.\n     */\n\n  }, {\n    key: \"setRenderingAutoClearDepthStencil\",\n    value: function setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {\n      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var stencil = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);\n    }\n    /**\n     * Gets the current auto clear configuration for one rendering group of the rendering\n     * manager.\n     * @param index the rendering group index to get the information for\n     * @returns The auto clear setup for the requested rendering group\n     */\n\n  }, {\n    key: \"getAutoClearDepthStencilSetup\",\n    value: function getAutoClearDepthStencilSetup(index) {\n      return this._renderingManager.getAutoClearDepthStencilSetup(index);\n    }\n    /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */\n\n  }, {\n    key: \"blockMaterialDirtyMechanism\",\n    get: function get() {\n      return this._blockMaterialDirtyMechanism;\n    },\n    set: function set(value) {\n      if (this._blockMaterialDirtyMechanism === value) {\n        return;\n      }\n\n      this._blockMaterialDirtyMechanism = value;\n\n      if (!value) {\n        // Do a complete update\n        this.markAllMaterialsAsDirty(63);\n      }\n    }\n    /**\n     * Will flag all materials as dirty to trigger new shader compilation\n     * @param flag defines the flag used to specify which material part must be marked as dirty\n     * @param predicate If not null, it will be used to specify if a material has to be marked as dirty\n     */\n\n  }, {\n    key: \"markAllMaterialsAsDirty\",\n    value: function markAllMaterialsAsDirty(flag, predicate) {\n      if (this._blockMaterialDirtyMechanism) {\n        return;\n      }\n\n      var _iterator30 = _createForOfIteratorHelper(this.materials),\n          _step37;\n\n      try {\n        for (_iterator30.s(); !(_step37 = _iterator30.n()).done;) {\n          var material = _step37.value;\n\n          if (predicate && !predicate(material)) {\n            continue;\n          }\n\n          material.markAsDirty(flag);\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_loadFile\",\n    value: function _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n      var _this10 = this;\n\n      var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n      this._activeRequests.push(request);\n\n      request.onCompleteObservable.add(function (request) {\n        _this10._activeRequests.splice(_this10._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_loadFileAsync\",\n    value: function _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n      var _this11 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this11._loadFile(fileOrUrl, function (data) {\n          resolve(data);\n        }, onProgress, useOfflineSupport, useArrayBuffer, function (request, exception) {\n          reject(exception);\n        }, onOpened);\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_requestFile\",\n    value: function _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {\n      var _this12 = this;\n\n      var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : undefined, useArrayBuffer, onError, onOpened);\n\n      this._activeRequests.push(request);\n\n      request.onCompleteObservable.add(function (request) {\n        _this12._activeRequests.splice(_this12._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_requestFileAsync\",\n    value: function _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {\n      var _this13 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this13._requestFile(url, function (data) {\n          resolve(data);\n        }, onProgress, useOfflineSupport, useArrayBuffer, function (error) {\n          reject(error);\n        }, onOpened);\n      });\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_readFile\",\n    value: function _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {\n      var _this14 = this;\n\n      var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);\n\n      this._activeRequests.push(request);\n\n      request.onCompleteObservable.add(function (request) {\n        _this14._activeRequests.splice(_this14._activeRequests.indexOf(request), 1);\n      });\n      return request;\n    }\n    /**\n     * @internal\n     */\n\n  }, {\n    key: \"_readFileAsync\",\n    value: function _readFileAsync(file, onProgress, useArrayBuffer) {\n      var _this15 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this15._readFile(file, function (data) {\n          resolve(data);\n        }, onProgress, useArrayBuffer, function (error) {\n          reject(error);\n        });\n      });\n    }\n    /**\n     * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.\n     * @returns the perf collector belonging to the scene.\n     */\n\n  }, {\n    key: \"getPerfCollector\",\n    value: function getPerfCollector() {\n      throw _WarnImport(\"performanceViewerSceneExtension\");\n    }\n  }], [{\n    key: \"DefaultMaterialFactory\",\n    value: function DefaultMaterialFactory(scene) {\n      throw _WarnImport(\"StandardMaterial\");\n    }\n    /**\n     * Factory used to create the a collision coordinator.\n     * @returns The collision coordinator\n     */\n\n  }, {\n    key: \"CollisionCoordinatorFactory\",\n    value: function CollisionCoordinatorFactory() {\n      throw _WarnImport(\"DefaultCollisionCoordinator\");\n    }\n  }, {\n    key: \"DragMovementThreshold\",\n    get: function get() {\n      return InputManager.DragMovementThreshold;\n    },\n    set: function set(value) {\n      InputManager.DragMovementThreshold = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms\n     */\n\n  }, {\n    key: \"LongPressDelay\",\n    get: function get() {\n      return InputManager.LongPressDelay;\n    },\n    set: function set(value) {\n      InputManager.LongPressDelay = value;\n    }\n    /**\n     * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms\n     */\n\n  }, {\n    key: \"DoubleClickDelay\",\n    get: function get() {\n      return InputManager.DoubleClickDelay;\n    },\n    set: function set(value) {\n      InputManager.DoubleClickDelay = value;\n    }\n    /** If you need to check double click without raising a single click at first click, enable this flag */\n\n  }, {\n    key: \"ExclusiveDoubleClickMode\",\n    get: function get() {\n      return InputManager.ExclusiveDoubleClickMode;\n    },\n    set: function set(value) {\n      InputManager.ExclusiveDoubleClickMode = value;\n    }\n  }]);\n\n  return Scene;\n}(AbstractScene);\n/** The fog is deactivated */\n\nScene.FOGMODE_NONE = 0;\n/** The fog density is following an exponential function */\n\nScene.FOGMODE_EXP = 1;\n/** The fog density is following an exponential function faster than FOGMODE_EXP */\n\nScene.FOGMODE_EXP2 = 2;\n/** The fog density is following a linear function. */\n\nScene.FOGMODE_LINEAR = 3;\n/**\n * Gets or sets the minimum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n */\n\nScene.MinDeltaTime = 1.0;\n/**\n * Gets or sets the maximum deltatime when deterministic lock step is enabled\n * @see https://doc.babylonjs.com/babylon101/animations#deterministic-lockstep\n */\n\nScene.MaxDeltaTime = 1000.0;\n/**\n * @internal\n */\n\nScene.prototype.setActiveCameraByID = function (id) {\n  return this.setActiveCameraById(id);\n};\n\nScene.prototype.getLastMaterialByID = function (id) {\n  return this.getLastMaterialById(id);\n};\n\nScene.prototype.getMaterialByID = function (id) {\n  return this.getMaterialById(id);\n};\n\nScene.prototype.getTextureByUniqueID = function (uniqueId) {\n  return this.getTextureByUniqueId(uniqueId);\n};\n\nScene.prototype.getCameraByID = function (id) {\n  return this.getCameraById(id);\n};\n\nScene.prototype.getCameraByUniqueID = function (uniqueId) {\n  return this.getCameraByUniqueId(uniqueId);\n};\n\nScene.prototype.getBoneByID = function (id) {\n  return this.getBoneById(id);\n};\n\nScene.prototype.getLightByID = function (id) {\n  return this.getLightById(id);\n};\n\nScene.prototype.getLightByUniqueID = function (uniqueId) {\n  return this.getLightByUniqueId(uniqueId);\n};\n\nScene.prototype.getParticleSystemByID = function (id) {\n  return this.getParticleSystemById(id);\n};\n\nScene.prototype.getGeometryByID = function (id) {\n  return this.getGeometryById(id);\n};\n\nScene.prototype.getMeshByID = function (id) {\n  return this.getMeshById(id);\n};\n\nScene.prototype.getMeshesByID = function (id) {\n  return this.getMeshesById(id);\n};\n\nScene.prototype.getTransformNodeByID = function (id) {\n  return this.getTransformNodeById(id);\n};\n\nScene.prototype.getTransformNodeByUniqueID = function (uniqueId) {\n  return this.getTransformNodeByUniqueId(uniqueId);\n};\n\nScene.prototype.getTransformNodesByID = function (id) {\n  return this.getTransformNodesById(id);\n};\n\nScene.prototype.getMeshByUniqueID = function (uniqueId) {\n  return this.getMeshByUniqueId(uniqueId);\n};\n\nScene.prototype.getLastMeshByID = function (id) {\n  return this.getLastMeshById(id);\n};\n\nScene.prototype.getLastEntryByID = function (id) {\n  return this.getLastEntryById(id);\n};\n\nScene.prototype.getNodeByID = function (id) {\n  return this.getNodeById(id);\n};\n\nScene.prototype.getLastSkeletonByID = function (id) {\n  return this.getLastSkeletonById(id);\n};"],"names":["ScenePerformancePriority","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","length","i","F","s","done","value","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","return","arr","len","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_isNativeReflectConstruct","result","Super","NewTarget","this","arguments","Scene","_AbstractScene","_super","engine","options","_this","_inputManager","cameraToUseForPointers","_isScene","_blockEntityCollection","autoClear","autoClearDepthAndStencil","clearColor","ambientColor","environmentIntensity","_performancePriority","BackwardCompatible","_forceWireframe","_skipFrustumClipping","_forcePointsCloud","animationsEnabled","_animationPropertiesOverride","useConstantAnimationDeltaTime","constantlyUpdateMeshUnderPointer","hoverCursor","defaultCursor","doNotHandleCursors","preventDefaultOnPointerDown","preventDefaultOnPointerUp","metadata","reservedDataStore","disableOfflineSupportExceptionRules","onDisposeObservable","_onDisposeObserver","onBeforeRenderObservable","_onBeforeRenderObserver","onAfterRenderObservable","onAfterRenderCameraObservable","_onAfterRenderObserver","onBeforeAnimationsObservable","onAfterAnimationsObservable","onBeforeDrawPhaseObservable","onAfterDrawPhaseObservable","onReadyObservable","onBeforeCameraRenderObservable","_onBeforeCameraRenderObserver","onAfterCameraRenderObservable","_onAfterCameraRenderObserver","onBeforeActiveMeshesEvaluationObservable","onAfterActiveMeshesEvaluationObservable","onBeforeParticlesRenderingObservable","onAfterParticlesRenderingObservable","onDataLoadedObservable","onNewCameraAddedObservable","onCameraRemovedObservable","onNewLightAddedObservable","onLightRemovedObservable","onNewGeometryAddedObservable","onGeometryRemovedObservable","onNewTransformNodeAddedObservable","onTransformNodeRemovedObservable","onNewMeshAddedObservable","onMeshRemovedObservable","onNewSkeletonAddedObservable","onSkeletonRemovedObservable","onNewMaterialAddedObservable","onNewMultiMaterialAddedObservable","onMaterialRemovedObservable","onMultiMaterialRemovedObservable","onNewTextureAddedObservable","onTextureRemovedObservable","onBeforeRenderTargetsRenderObservable","onAfterRenderTargetsRenderObservable","onBeforeStepObservable","onAfterStepObservable","onActiveCameraChanged","onActiveCamerasChanged","onBeforeRenderingGroupObservable","onAfterRenderingGroupObservable","onMeshImportedObservable","onAnimationFileImportedObservable","_registeredForLateAnimationBindings","skipPointerMovePicking","skipPointerDownPicking","skipPointerUpPicking","onPrePointerObservable","onPointerObservable","onPreKeyboardObservable","onKeyboardObservable","_useRightHandedSystem","_timeAccumulator","_currentStepId","_currentInternalStep","_fogEnabled","_fogMode","FOGMODE_NONE","fogColor","fogDensity","fogStart","fogEnd","needsPreviousWorldMatrices","_shadowsEnabled","_lightsEnabled","_unObserveActiveCameras","_texturesEnabled","physicsEnabled","particlesEnabled","spritesEnabled","_skeletonsEnabled","lensFlaresEnabled","collisionsEnabled","gravity","postProcessesEnabled","renderTargetsEnabled","dumpNextRenderTargets","customRenderTargets","importedMeshesFiles","probesEnabled","_meshesForIntersections","proceduralTexturesEnabled","_totalVertices","_activeIndices","_activeParticles","_activeBones","_animationTime","animationTimeScale","_renderId","_frameId","_executeWhenReadyTimeoutId","_intermediateRendering","_defaultFrameBufferCleared","_viewUpdateFlag","_projectionUpdateFlag","_toBeDisposed","_activeRequests","_pendingData","_isDisposed","dispatchAllSubMeshesOfActiveMeshes","_activeMeshes","_processedMaterials","_renderTargets","_materialsRenderTargets","_activeParticleSystems","_activeSkeletons","_softwareSkinnedMeshes","_activeAnimatables","_transformMatrix","requireLightSorting","_components","_serializableComponents","_transientComponents","_beforeCameraUpdateStage","_beforeClearStage","_beforeRenderTargetClearStage","_gatherRenderTargetsStage","_gatherActiveCameraRenderTargetsStage","_isReadyForMeshStage","_beforeEvaluateActiveMeshStage","_evaluateSubMeshStage","_preActiveMeshStage","_cameraDrawRenderTargetStage","_beforeCameraDrawStage","_beforeRenderTargetDrawStage","_beforeRenderingGroupDrawStage","_beforeRenderingMeshStage","_afterRenderingMeshStage","_afterRenderingGroupDrawStage","_afterCameraDrawStage","_afterRenderTargetDrawStage","_afterRenderStage","_pointerMoveStage","_pointerDownStage","_pointerUpStage","_geometriesByUniqueId","_defaultMeshCandidates","data","_defaultSubMeshCandidates","_preventFreeActiveMeshesAndRenderingGroups","_activeMeshesFrozen","_activeMeshesFrozenButKeepClipping","_skipEvaluateActiveMeshesCompletely","_allowPostProcessClearColor","getDeterministicFrameTime","_engine","getTimeStep","_blockMaterialDirtyMechanism","_perfCollector","onComputePressureChanged","activeCameras","fullOptions","target","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_objectSpread","useGeometryUniqueIdsMap","useMaterialMeshMap","useClonedMeshMap","virtual","_virtualScenes","scenes","_uid","_renderingManager","postProcessManager","attachControl","_createUbo","_imageProcessingConfiguration","setDefaultCandidateProviders","onNewSceneAddedObservable","notifyObservers","_computePressureObserver","update","cpuUtilizationThresholds","cpuSpeedThresholds","observe","get","_environmentTexture","set","markAllMaterialsAsDirty","Aggressive","skipFrustumClipping","Intermediate","callback","remove","add","unTranslatedPointer","effect","_this$activeCamera$gl","variableName","undefined","isVector3","eyePosition","_forcedViewPosition","_mirroredCameraPosition","activeCamera","globalPosition","devicePosition","invertNormal","useRightHandedSystem","x","y","z","setFloat3","setVector4","ubo","getSceneUniformBuffer","bindEyePosition","updateFloat4","w","newStepId","prePassRenderer","defaultRT","enabled","_activeCameras","cameras","_this2","_activeCamera","_defaultMaterial","DefaultMaterialFactory","_collisionCoordinator","CollisionCoordinatorFactory","init","_frustumPlanes","_step","_iterator","register","component","serializableComponent","addFromContainer","serialize","_step2","_iterator2","meshes","mesh","subMeshes","getActiveMeshCandidates","_getDefaultMeshCandidates","bind","getActiveSubMeshCandidates","_getDefaultSubMeshCandidates","getIntersectingSubMeshCandidates","getCollidingSubMeshCandidates","meshUnderPointer","pointerX","pointerY","_cachedMaterial","_cachedEffect","_cachedVisibility","material","visibility","current","_animationRatio","setSceneUniformBuffer","createSceneUniformBuffer","pickResult","pointerEventInit","simulatePointerMove","simulatePointerDown","doubleTap","simulatePointerUp","pointerId","isPointerCaptured","attachUp","attachDown","attachMove","detachControl","index","checkRenderTargets","getEngine","isReady","reset","_step3","hardwareInstancedRendering","hasThinInstances","getClassName","getCaps","instancedArrays","instances","_iterator3","action","mat","defaultMaterial","_storeEffectOnSubMeshes","_step4","_iterator4","subMesh","getMaterial","hasRenderTargetTextures","getRenderTargetTextures","indexOf","concatWithNoDuplicate","areAllEffectsReady","rtt","isReadyForRendering","geometries","geometry","delayLoadState","_step5","_iterator5","camera","_step6","_iterator6","particleSystems","particleSystem","func","removeCallback","_this3","registerBeforeRender","execFunc","setTimeout","unregisterBeforeRender","timeout","_this4","_executeOnceBeforeRender","wasLoading","isLoading","splice","_checkIsReady","_this5","Promise","resolve","executeWhenReady","_this6","_registerTransientComponents","clear","incrementRenderId","_animationTimeLast","_viewMatrix","_projectionMatrix","viewL","projectionL","viewR","projectionR","_multiviewSceneUbo","dispose","updateFlag","multiplyToRef","useUbo","_updateMultiviewUbo","_sceneUbo","updateMatrix","sceneUbo","addUniform","UniqueId","newMesh","_this7","recursive","_resyncLightSources","parent","_addToSceneRootNodes","getChildMeshes","m","addMesh","toRemove","_this8","pop","_removeFromSceneRootNodes","_invalidateMesh","removeMesh","newTransformNode","getScene","_indexInSceneTransformNodesArray","transformNodes","lastNode","skeletons","_executeActiveContainerCleanup","morphTargetManagers","lights","_step7","_iterator7","_removeLightSource","sortLightsByPriority","index2","animations","animationName","targetMask","animationGroups","multiMaterials","_indexInSceneMaterialArray","materials","lastMaterial","actionManagers","textures","newLight","_step8","_iterator8","lightSources","sort","newCamera","newSkeleton","newParticleSystem","newAnimation","newAnimationGroup","newMultiMaterial","newMaterial","newMorphTargetManager","newGeometry","uniqueId","newActionManager","newTexture","canvas","getInputElement","id","getCameraById","getCameraByName","allowMultiMaterials","_index","skeletonIndex","skeleton","boneIndex","bones","_index2","force","_getGeometryByUniqueId","addGeometry","lastGeometry","getMeshById","transformNode","getTransformNodeById","light","getLightById","bone","getBoneById","getMeshByName","getTransformNodeByName","getLightByName","getBoneByName","managerIndex","morphTargetManager","numTargets","getTarget","postProcessIndex","postProcesses","postProcess","_externalData","factory","getOrAddWithFactory","initialMesh","hasInstances","isAnInstance","alwaysSelectAsActiveMesh","isInFrustum","_step9","_iterator9","dispatch","freeActiveMeshes","freeRenderingGroups","blockfreeActiveMeshesAndRenderingGroups","texture","renderList","_this9","skipEvaluateActiveMeshes","onSuccess","onError","freezeMeshes","keepFrustumCulling","updateTransformMatrix","_evaluateActiveMeshes","_freeze","_internalAbstractMeshDataInfo","_isActive","_index3","_unFreeze","container","snapshotRendering","snapshotRenderingMode","addOnce","_this$activeCamera","_len","computeWorldMatrix","psLength","_i","animate","_step10","_iterator10","_i2","_mesh","_currentLODIsUpToDate","isBlocked","addCount","getTotalVertices","isEnabled","scaling","hasAZeroComponent","actionManager","hasSpecificTriggers2","pushNoDuplicate","meshToRender","customLODSelector","getLOD","_currentLOD","billboardMode","_preActivate","isVisible","layerMask","_activate","_step11","_iterator11","_actAsRegularMesh","_onlyForInstances","_activeMesh","_postActivate","particleIndex","isStarted","emitter","position","dispatchParticles","sourceMesh","prepare","computeBonesUsingShaders","_evaluateSubMesh","_renderingMultiview","leftCamera","_rigCameras","rightCamera","setTransformMatrix","getViewMatrix","getProjectionMatrix","_multiviewTexture","_bindFrameBuffer","outputRenderTarget","_currentFrameBufferIsDefaultFrameBuffer","restoreDefaultFramebuffer","_clearFrameBuffer","onClearObservable","hasObservers","skipInitialClear","_cleared","_clear","rigParent","_ref","_camera$outputRenderT","_camera$outputRenderT2","bindFrameBuffer","_skipRendering","Error","setViewport","viewport","resetCachedMaterial","prePass","softwareSkinnedMeshIndex","applySkeleton","environmentTexture","isRenderTarget","_step13","_iterator12","_step17","needRebind","renderIndex","renderTarget","_shouldRender","hasSpecialRenderTargetCamera","render","_step14","_iterator13","currentRenderPassId","renderPassId","_prepareFrame","_step15","_iterator14","_step18","finalizeSceneUbo","_step16","_iterator15","_step19","_finalizeFrame","isIntermediate","cameraRigMode","_createMultiviewUbo","_renderForCamera","_useMultiviewToSingleView","_renderMultiviewToSingleView","actionIndex","actions","trigger","parameters","getTriggerParameter","otherMesh","areIntersecting","intersectsMesh","usePreciseIntersection","currentIntersectionInProgress","_intersectionsInProgress","_executeCurrent","hasSpecificTrigger","parameter","parameterMesh","isDeterministicLockStep","deltaTime","Math","max","MinDeltaTime","min","getDeltaTime","MaxDeltaTime","defaultFrameTime","defaultFPS","stepsTaken","maxSubSteps","getLockstepMaxSteps","internalSteps","floor","_animate","_advancePhysicsEngineStep","_deltaTime","forceWireframe","forcePointsCloud","_camera$rigCameras","isRigCamera","rigCameras","passId","_step20","_iterator16","resetDrawCache","_this$activeCameras","_this$activeCameras2","_currentActiveCamera$","updateCameras","ignoreAnimations","isDisposed","_checkCameraRenderTarget","fetchNewFrame","processTrigger","_step21","_iterator17","cameraIndex","_index4","currentActiveCamera","customIndex","_step22","_iterator18","_step25","_step23","_iterator19","_step26","_cameraIndex","_processSubCameras","_checkIntersections","_step24","_iterator20","_step27","afterRender","_index5","freeze","unfreeze","_this$_computePressur","beforeRender","stopAllAnimations","_step28","_iterator21","abort","unobserve","_index6","_disposeList","item","wipeCaches","items","_callback","_step29","_iterator22","meshIndex","clearCachedData","_step30","_iterator23","baseTexture","_buffer","filterPredicate","Number","MAX_VALUE","infiniteDistance","boundingInfo","getBoundingInfo","minBox","boundingBox","minimumWorld","maxBox","maximumWorld","world","predicate","fastCheck","trianglePredicate","pi","_pickingUnavailable","ray","setPointerOverMesh","getPointerOverMesh","_step31","_iterator24","_rebuild","_step32","_iterator25","_step33","_iterator26","rebuild","_step34","_iterator27","spriteManagers","_step35","_iterator28","_step36","_iterator29","list","tagsQuery","listByTags","_getByTags","concat","renderingGroupId","opaqueSortCompareFn","alphaTestSortCompareFn","transparentSortCompareFn","setRenderingOrder","autoClearDepthStencil","depth","stencil","setRenderingAutoClearDepthStencil","getAutoClearDepthStencilSetup","flag","_step37","_iterator30","markAsDirty","fileOrUrl","onProgress","useOfflineSupport","useArrayBuffer","onOpened","_this10","request","offlineProvider","onCompleteObservable","_this11","reject","_loadFile","exception","url","_this12","_this13","_requestFile","error","file","_this14","_this15","_readFile","scene","FOGMODE_EXP","FOGMODE_EXP2","FOGMODE_LINEAR","setActiveCameraByID","setActiveCameraById","getLastMaterialByID","getLastMaterialById","getMaterialByID","getMaterialById","getTextureByUniqueID","getTextureByUniqueId","getCameraByID","getCameraByUniqueID","getCameraByUniqueId","getBoneByID","getLightByID","getLightByUniqueID","getLightByUniqueId","getParticleSystemByID","getParticleSystemById","getGeometryByID","getGeometryById","getMeshByID","getMeshesByID","getMeshesById","getTransformNodeByID","getTransformNodeByUniqueID","getTransformNodeByUniqueId","getTransformNodesByID","getTransformNodesById","getMeshByUniqueID","getMeshByUniqueId","getLastMeshByID","getLastMeshById","getLastEntryByID","getLastEntryById","getNodeByID","getNodeById","getLastSkeletonByID","getLastSkeletonById"],"sourceRoot":""}